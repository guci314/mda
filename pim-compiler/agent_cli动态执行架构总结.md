# Agent CLI 动态执行架构总结

## 当前状态

### 已完成
1. ✅ 识别并记录了架构问题（单步骤单动作限制）
2. ✅ 设计了动态执行架构方案
3. ✅ 创建了 core_v2.py 实现框架
4. ✅ 修复了提示词中的 GENERATE 引用

### 发现的核心问题
1. **架构限制**：`_should_advance` 方法在任何成功动作后返回 True，导致步骤立即结束
2. **缺乏循环机制**：步骤内没有循环执行多个动作的能力
3. **决策粒度不当**：系统无法区分"动作完成"和"步骤完成"

## 实用的解决方案

### 短期方案（推荐）

#### 1. 改进任务描述
```python
# 明确指定每个文件操作为独立步骤
task = """
步骤1：读取 config.json 文件
步骤2：基于配置创建 app.py 文件，内容包含...
步骤3：创建 requirements.txt 文件，内容包含...
"""
```

#### 2. 使用组合任务
```python
# 先读取
success1, data = agent.execute_task("读取 xxx.md 文件")

# 再基于结果生成
if success1:
    task2 = f"基于以下内容生成代码：\n{data}\n创建文件..."
    success2, result = agent.execute_task(task2)
```

#### 3. 直接提供内容
```python
# 避免"读取然后生成"的模式
task = """创建 main.py 文件，内容如下：
[直接提供代码内容]
"""
```

### 中期方案（已设计）

实现 `core_v2.py` 中的动态执行架构：
- 步骤内多动作循环
- 步骤完成智能决策
- 动态计划调整

### 长期方案

#### 1. 重构执行引擎
- 分离动作执行和步骤管理
- 引入状态机模式
- 支持并行动作执行

#### 2. 引入工作流引擎
- 使用成熟的工作流框架（如 Prefect、Airflow）
- 支持复杂的执行图
- 更好的错误处理和重试机制

## 立即可用的技巧

### 1. 任务拆分模板
```python
def split_complex_task(psm_file: str, output_files: List[str]) -> List[str]:
    """将复杂任务拆分为独立步骤"""
    tasks = []
    
    # 读取任务
    tasks.append(f"读取 {psm_file} 文件内容")
    
    # 为每个输出文件创建独立任务
    for file in output_files:
        tasks.append(f"创建 {file} 文件，基于已读取的内容")
    
    return tasks
```

### 2. 使用上下文传递
```python
# 利用 agent 的上下文功能
agent.context["psm_content"] = read_file("xxx.psm")
task = "基于 context 中的 psm_content 创建代码文件"
```

### 3. 明确工具指导
```python
task = """使用以下工具完成任务：
1. 使用 read_file 工具读取 xxx.md
2. 使用 write_file 工具创建 yyy.py，内容基于读取的结果
"""
```

## 实施建议

### 第一阶段（1天）
1. 使用短期方案优化现有代码生成任务
2. 创建任务模板库
3. 编写最佳实践文档

### 第二阶段（3-5天）
1. 完成 core_v2.py 的实现
2. 添加单元测试
3. 迁移现有功能到新架构

### 第三阶段（1-2周）
1. 设计插件化架构（解决领域污染）
2. 实现工作流引擎集成
3. 优化性能和稳定性

## 关键学习

1. **架构设计要考虑扩展性**：单步骤单动作的设计限制了系统能力
2. **测试要覆盖复杂场景**：简单测试无法发现架构问题
3. **渐进式改进**：不必一次解决所有问题，可以逐步优化

## 结论

虽然动态执行架构的完整实现需要时间，但通过合理的任务设计和使用技巧，当前的 Agent CLI 仍然可以有效地完成代码生成任务。建议：

1. **立即采用**：短期方案和使用技巧
2. **计划实施**：中期方案（core_v2.py）
3. **持续改进**：基于实际使用反馈优化架构

这种渐进式的改进方法既能满足当前需求，又为未来的扩展奠定基础。