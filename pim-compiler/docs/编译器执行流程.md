# PIM 编译器执行流程

## 概述

PIM 编译器是一个基于 Gemini CLI 的纯 AI 驱动编译器，它将平台无关模型（PIM）转换为平台特定模型（PSM），最终生成可运行的代码。整个过程分为三个主要阶段：PSM 生成、代码生成和测试修复。

## 核心执行流程

```mermaid
flowchart TD
    Start([开始编译]) --> LoadPIM[加载 PIM 文件]
    LoadPIM --> ValidatePIM{验证 PIM 格式}
    
    ValidatePIM -->|无效| ErrorPIM[返回错误信息]
    ErrorPIM --> End([结束])
    
    ValidatePIM -->|有效| PrepareDir[准备目录结构]
    PrepareDir --> CopyPIM[复制 PIM 到工作目录]
    
    CopyPIM --> GeneratePSM[调用 Gemini CLI 生成 PSM]
    GeneratePSM --> CheckPSM{检查 PSM 文件}
    
    CheckPSM -->|未找到| SearchPSM[搜索可能的位置]
    SearchPSM --> FoundPSM{找到 PSM?}
    FoundPSM -->|否| ErrorPSM2[PSM 生成失败]
    ErrorPSM2 --> End
    FoundPSM -->|是| MovePSM[移动到正确位置]
    MovePSM --> GenerateCode
    
    CheckPSM -->|存在| GenerateCode[调用 Gemini CLI 生成代码]
    GenerateCode --> MonitorProgress[监控生成进度]
    MonitorProgress --> CheckFiles{检查生成的文件}
    
    CheckFiles -->|无关键文件| WaitMore{等待超时?}
    WaitMore -->|否| MonitorProgress
    WaitMore -->|是| ErrorCode[代码生成失败]
    ErrorCode --> End
    
    CheckFiles -->|有关键文件| RunLint[运行 Lint 检查]
    RunLint --> HasErrors{有 Lint 错误?}
    
    HasErrors -->|是| FixLint[调用 Gemini 修复]
    FixLint --> RunTests
    HasErrors -->|否| RunTests[运行单元测试]
    
    RunTests --> TestResult{测试结果}
    TestResult -->|失败| FixTests[调用 Gemini 修复测试]
    FixTests --> RunTests2[重新运行测试]
    RunTests2 --> FinalCheck{最终检查}
    
    TestResult -->|通过| FinalCheck
    FinalCheck --> Success[编译成功]
    Success --> End
```

## 详细步骤说明

### 1. 初始化阶段

```mermaid
flowchart LR
    subgraph 初始化
        A[检查 Gemini CLI] --> B[加载环境变量]
        B --> C[创建编译器实例]
        C --> D[设置工作目录]
    end
```

**关键代码位置**: `pure_gemini_compiler.py::__init__`

- 检查 Gemini CLI 是否安装
- 加载 `.env` 配置（GEMINI_API_KEY, GEMINI_MODEL 等）
- 设置输出目录结构

### 2. PSM 生成阶段

```mermaid
flowchart TD
    subgraph PSM生成
        A[读取 PIM 内容] --> B[构建 Gemini 提示词]
        B --> C[执行 Gemini CLI]
        C --> D{检查输出}
        D -->|成功| E[保存 PSM 文件]
        D -->|失败| F[错误处理]
    end
```

**关键代码位置**: `pure_gemini_compiler.py::_generate_psm`

#### 提示词模板
```
你是一个专业的软件架构师，精通模型驱动架构（MDA）。
请将这个 PIM 转换为 {platform} 平台的平台特定模型（PSM）。
```

#### 文件命名规则
- 输入: `{name}.md` 或 `{name}.yaml`
- 输出: `psm/{name}_psm.md`

### 3. 代码生成阶段

```mermaid
flowchart TD
    subgraph 代码生成
        A[读取 PSM 内容] --> B[构建代码生成提示词]
        B --> C[执行 Gemini CLI]
        C --> D[监控文件生成]
        D --> E{检查关键文件}
        E -->|未完成| D
        E -->|完成| F[统计生成结果]
    end
```

**关键代码位置**: `pure_gemini_compiler.py::_generate_code`

#### 监控逻辑
```python
# 每10秒检查一次新生成的文件
# 如果60秒内没有新文件且已有关键文件，则认为完成
```

#### 关键文件检查
- FastAPI: `main.py`, `requirements.txt`
- Django: `manage.py`, `settings.py`
- Flask: `app.py`, `requirements.txt`

### 4. 测试与修复阶段（反馈循环）

```mermaid
flowchart TD
    subgraph 测试修复反馈循环
        Start[开始测试阶段] --> InitCounter[初始化循环计数器 = 0]
        InitCounter --> LintCheck[Lint 检查]
        
        LintCheck --> LintError{有 Lint 错误?}
        LintError -->|是| FixLint[调用 Gemini CLI 修复]
        FixLint --> LintCheck
        LintError -->|否| RunTests[Engine 运行 pytest]
        
        RunTests --> CollectErrors[收集测试结果和错误信息]
        CollectErrors --> TestPass{测试通过?}
        
        TestPass -->|是| Success[编译成功]
        TestPass -->|否| CheckCounter{循环次数 < 5?}
        
        CheckCounter -->|否| CompileFail[编译失败<br/>需要人类介入]
        CheckCounter -->|是| IncCounter[循环计数器 + 1]
        
        IncCounter --> AnalyzeErrors[分析错误信息]
        AnalyzeErrors --> GeneratePrompt[生成修复提示词]
        
        GeneratePrompt --> CallGemini[调用 Gemini CLI<br/>传入错误信息]
        CallGemini --> ApplyFix[应用修复代码]
        ApplyFix --> RunTests
        
        Success --> End[结束]
        CompileFail --> End
    end
```

**关键代码位置**: `pure_gemini_compiler.py::_run_tests_and_fix`

#### 反馈循环详细流程

1. **初始化阶段**
   ```python
   max_attempts = 5
   current_attempt = 0
   test_passed = False
   ```

2. **测试执行**
   ```python
   # Engine 运行测试
   result = subprocess.run(
       ["python", "-m", "pytest", "tests/", "-v"],
       capture_output=True,
       text=True,
       cwd=code_dir
   )
   ```

3. **错误收集与分析**
   ```python
   if result.returncode != 0:
       # 收集详细错误信息
       error_info = {
           "stdout": result.stdout,
           "stderr": result.stderr,
           "failed_tests": extract_failed_tests(result.stdout),
           "error_types": categorize_errors(result.stderr)
       }
   ```

4. **生成修复提示词**
   ```python
   prompt = f"""
   测试执行失败，需要修复以下问题：
   
   失败的测试：
   {error_info['failed_tests']}
   
   错误信息：
   {error_info['stderr']}
   
   请分析错误原因并修复代码，确保：
   1. 修复所有测试失败
   2. 不要破坏已通过的测试
   3. 保持代码质量和规范
   
   这是第 {current_attempt + 1} 次尝试（最多 5 次）
   """
   ```

5. **循环控制**
   ```python
   while current_attempt < max_attempts and not test_passed:
       current_attempt += 1
       
       # 执行测试
       test_result = run_tests()
       
       if test_result.success:
           test_passed = True
           break
       
       # 如果是最后一次尝试，不再修复
       if current_attempt >= max_attempts:
           return CompilationResult(
               success=False,
               error=f"测试修复失败，已尝试 {max_attempts} 次，需要人类介入"
           )
       
       # 调用 Gemini 修复
       fix_tests(test_result.errors)
   ```

#### 错误分类与处理策略

```mermaid
flowchart LR
    subgraph 错误分类
        A[测试错误] --> B{错误类型}
        B -->|导入错误| C[修复 import 路径]
        B -->|断言失败| D[修复业务逻辑]
        B -->|类型错误| E[修复类型注解]
        B -->|语法错误| F[修复代码语法]
        B -->|依赖缺失| G[更新 requirements.txt]
    end
```

#### 反馈信息结构

每次反馈给 Gemini CLI 的信息包含：

1. **测试执行上下文**
   - 当前是第几次尝试
   - 之前的修复历史
   - 哪些测试已通过

2. **详细错误信息**
   - 完整的错误堆栈
   - 失败的测试名称
   - 具体的断言信息

3. **修复指导**
   - 优先级（先修复语法错误，再修复逻辑错误）
   - 约束条件（不要修改已通过的测试）
   - 质量要求（保持代码风格一致）

## 文件组织结构

```
output_dir/
├── pim/                    # PIM 文件副本
│   └── {name}.md
├── psm/                    # 生成的 PSM
│   └── {name}_psm.md
└── generated/              # 生成的代码
    └── {name}/
        ├── main.py         # 应用入口
        ├── requirements.txt # 依赖
        ├── README.md       # 文档
        ├── .env.example    # 配置示例
        ├── app/            # 应用代码
        │   ├── models.py
        │   ├── schemas.py
        │   └── services.py
        └── tests/          # 测试代码
            └── test_*.py
```

## 执行时间分析

基于实际测试数据：

| 阶段 | Gemini 2.5 Pro | Gemini 2.5 Flash |
|------|----------------|------------------|
| PSM 生成 | 60-120秒 | 15-25秒 |
| 代码生成 | 90-150秒 | 40-60秒 |
| 修复阶段（每次） | 30-60秒 | 20-40秒 |
| **总计（无错误）** | **180-330秒** | **75-125秒** |
| **最坏情况（5次循环）** | **330-630秒** | **175-325秒** |

注：修复阶段的时间取决于测试失败的次数，最多进行 5 次反馈循环。

## 错误处理流程

```mermaid
flowchart TD
    subgraph 错误处理
        A[捕获异常] --> B{错误类型}
        B -->|文件未找到| C[FileNotFoundError]
        B -->|API 错误| D[API Error]
        B -->|超时| E[TimeoutError]
        B -->|测试失败| T[Test Failure]
        B -->|其他| F[General Error]
        
        C --> G[返回具体错误信息]
        D --> H[检查 API Key]
        E --> I[记录超时位置]
        T --> T1{重试次数?}
        T1 -->|< 5| T2[进入反馈循环]
        T1 -->|>= 5| T3[需要人类介入]
        F --> J[记录堆栈信息]
        
        G --> K[CompilationResult.error]
        H --> K
        I --> K
        T2 --> K
        T3 --> K
        J --> K
    end
```

## 关键决策点

### 1. PSM 文件位置搜索
```python
possible_files = [
    work_dir / psm_file.name,
    work_dir / f"{pim_file.stem}_psm.md",
    work_dir / "psm" / psm_file.name,
    work_dir / "psm" / f"{pim_file.stem}_psm_psm.md",
]
```

### 2. 文件生成完成判断
- 连续 60 秒没有新文件生成
- 已经生成了关键文件（main.py 等）
- 或者达到最大超时时间（10分钟）

### 3. 测试失败处理
- 最多重试 5 次（反馈循环）
- 每次失败后收集详细错误信息
- 生成针对性的修复提示词
- 超过 5 次自动停止，需要人类介入

## 环境变量配置

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| GEMINI_API_KEY | Gemini API 密钥 | 必需 |
| GEMINI_MODEL | 使用的模型 | gemini-2.5-pro |
| PROXY_HOST | 代理主机 | localhost |
| PROXY_PORT | 代理端口 | 7890 |

## 使用示例

### 命令行使用
```bash
# 基本用法
python -m compiler.cli compile input.md -o output/

# 指定平台
python -m compiler.cli compile input.md -p django -o output/

# 启用缓存
python -m compiler.cli compile input.md --cache -o output/
```

### Python API 使用
```python
from compiler import PureGeminiCompiler, CompilerConfig

config = CompilerConfig(
    output_dir=Path("output"),
    target_platform="fastapi",
    enable_cache=False
)

compiler = PureGeminiCompiler(config)
result = compiler.compile(Path("input.md"))

if result.success:
    print(f"编译成功！生成了 {result.statistics['total_files']} 个文件")
else:
    print(f"编译失败：{result.error}")
```

## 常见问题

### Q1: PSM 文件没有生成？
- 检查 GEMINI_API_KEY 是否正确设置
- 确保没有同时设置 GOOGLE_API_KEY
- 查看日志中的具体错误信息

### Q2: 代码生成卡住？
- 可能是 Gemini API 响应慢
- 检查网络连接和代理设置
- 考虑使用 gemini-2.5-flash 模型加速

### Q3: 测试一直失败？
- 检查生成的代码质量
- 查看具体的测试错误信息
- 可能需要手动调整部分代码

## 优化建议

1. **使用更快的模型**: `models/gemini-2.5-flash` 比 `gemini-2.5-pro` 快 3-4 倍
2. **启用缓存**: 对于重复编译，启用缓存可以跳过 PSM 生成
3. **并行处理**: 未来可以考虑并行生成多个模块
4. **增量编译**: 只重新编译修改的部分

## 总结

PIM 编译器通过三阶段流程（PSM生成 → 代码生成 → 测试修复）实现了从业务模型到可运行代码的自动转换。整个过程完全由 AI 驱动，无需人工干预即可生成高质量的代码。