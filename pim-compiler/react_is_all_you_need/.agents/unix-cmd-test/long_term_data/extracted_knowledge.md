```markdown
# 知识库

## 元知识
- 通过具体代码示例学习编程规范时，应关注：命名约定、文档标准、异常处理和性能考量
- 验证函数正确性时，需包含边界条件测试（如n=0）和异常输入测试（如负数）
- 学习高级Python特性（如装饰器）时，需理解其底层机制（函数作为一等对象和闭包）

## 原理与设计
- 斐波那契数列实现优先选择迭代而非递归，以避免栈溢出和性能问题
- 函数设计应遵循单一职责原则，同时处理计算和输入验证
- 装饰器设计理念：通过函数替换实现行为扩展，保持原函数代码不变
- 多层装饰器执行顺序为从下往上（装饰器栈）

## 接口与API
- Python函数标准文档字符串格式：
  ```python
  """
  功能说明

  参数:
    参数名 (类型): 描述

  返回:
    类型: 描述

  异常:
    异常类型: 触发条件

  示例:
    >>> 调用示例
    预期输出
  """
  ```
- 数值计算函数必须包含输入范围验证
- 装饰器标准模式：
  ```python
  def decorator(func):
      def wrapper(*args, **kwargs):
          # 前置逻辑
          result = func(*args, **kwargs)
          # 后置逻辑
          return result
      return wrapper
  ```
- 带参数装饰器需额外嵌套一层函数

## 实现细节（需验证）
- 斐波那契数列迭代实现模式：
  ```python
  a, b = 0, 1
  for _ in range(2, n + 1):
      a, b = b, a + b
  ```
- 基础案例处理位置：函数开始处的if-elif链
- 装饰器实现中需使用`*args, **kwargs`保证通用性
- 常用装饰器工具：`@functools.wraps`保留原函数元信息

## 用户偏好与项目特点
- Python代码规范偏好：
  - 函数命名：snake_case
  - 文档字符串：使用Google风格
  - 参数验证：前置条件检查+ValueError
- 装饰器常见应用场景：
  - 日志记录
  - 性能测试
  - 权限验证
  - 缓存
  - 事务管理
```