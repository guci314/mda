# 知识库

## 元知识
- 当任务是运行一个程序时，首要步骤是定位其主程序文件或入口点。
- 探索未知项目时，首先列出根目录内容以了解其基本结构。
- 当启动服务器的命令超时时，这可能意味着服务已成功启动并在后台运行。应通过其他方式（如发送请求或检查进程）进行验证。
- 如果服务的默认端口被占用，应先找到并终止占用该端口的进程，然后再启动服务。
- 如果一个验证方法（如检查日志文件）结果不明确，应立即使用备用方法（如检查进程列表 `ps aux`）进行交叉验证。
- 停止一个在特定端口上运行的服务，最可靠的方法是：先用 `lsof -t -i:<port>` 找到进程ID（PID），再用 `kill <PID>` 终止该进程，最后再次检查端口以确认进程已终止。
- 验证 Web 服务是否正在运行的有效方法是：
    - 使用 `curl` 向已知端点发送请求。
    - 使用 `ps aux | grep <process_name>` 检查相关进程是否存在。
    - 检查服务启动时指定的日志文件（如 `uvicorn.log`）以确认启动成功。
- 在后台运行服务（使用 `&`）并将其输出重定向到日志文件（使用 `> filename.log`）是一种有效的、不阻塞终端的服务器启动方式。
- 当一个 API 端点在不同次启动后返回不同的数据（例如，从空列表变为有数据的列表），这表明应用可能连接了一个持久化数据存储。
- 任务完成后，应检查并清理所有临时或不再需要的进程，以确保环境的整洁。
- 当用户在任务指令中提供明确的“成功判定条件”或“终止条件”时，必须严格遵循这些条件来判断任务是否完成。
- 如果用户指定了多个检查点（如检查多个端口），必须逐一验证所有条件都满足。
- 如果用户要求在任务成功后输出特定信息，应按要求生成该输出。
- 任务完成后，应明确声明任务完成并停止执行，避免对已验证成功的条件进行重复检查。

## 原理与设计
- Python Web 项目（如 FastAPI）通常将其核心应用代码组织在一个名为 `app` 的目录中。
- FastAPI 应用通常使用 `uvicorn` 作为 ASGI 服务器来运行。
- 如果在代码中未找到 `uvicorn.run()` 调用，则应用很可能是通过 `uvicorn` 命令行工具启动的。
- `uvicorn` 命令行启动时，若未指定端口，则默认使用 8000 端口。
- 使用 `--host 0.0.0.0` 参数可以使服务在网络上可被访问，而不仅仅是本地主机。
- 模块化的 FastAPI 项目通常将不同的 API 路由（Endpoints）组织在 `routers` 目录下的不同文件中。
- 应用通过某种持久化存储（很可能是像 SQLite 这样的文件型数据库）来管理数据，因此数据在应用重启后依然存在。

## 接口与API
- **工具**: `list_directory`
  - **用法**: `list_directory [path]`，用于列出指定路径下的文件和目录。
  - **示例**: `list_directory .` 用于列出当前目录的内容。
- **工具**: `read_file`
  - **用法**: `read_file [path]`，用于读取文件内容。
  - **示例**: `read_file app/main.py`。
- **工具**: `curl`
  - **用法**: `curl --noproxy 127.0.0.1 [URL]`，用于向指定的 URL 发送 HTTP 请求，常用于测试 API 端点。（注意：`--noproxy` 参数在此环境中是必需的）
  - **示例**: `curl --noproxy 127.0.0.1 http://127.0.0.1:8000/api/articles/`。
- **工具**: `lsof`
  - **用法**: `lsof -t -i:<port>`，用于查找并仅返回占用指定端口的进程ID (PID)。如果未找到进程，命令会失败（Exit Code 1），这可用于验证端口是否空闲。
  - **示例**: `lsof -t -i:8000`。
- **工具**: `kill`
  - **用法**: `kill <PID>`，用于终止指定ID的进程。
  - **示例**: `kill 704693`。
- **命令模式**: 启动 FastAPI 应用
  - **命令**: `uvicorn <module_path>:<app_instance_name> --host <ip> --port <port>`
  - **示例**: `uvicorn app.main:app --host 0.0.0.0 --port 8000`
- **命令模式**: 在后台启动服务并记录日志
  - **命令**: `<command> > <log_file> 2>&1 &`
  - **示例**: `uvicorn app.main:app --port 8000 > uvicorn.log 2>&1 &`
- **命令模式**: 检查运行中的进程
  - **命令**: `ps aux | grep <process_name>`
  - **示例**: `ps aux | grep uvicorn`
- **命令模式**: 按端口号停止服务（查找->终止->验证）
  - **步骤 1 (查找PID)**: `lsof -t -i:<port>`
  - **步骤 2 (终止进程)**: `kill <PID>`
  - **步骤 3 (验证停止)**: 再次运行 `lsof -t -i:<port>`，预期命令会失败（Exit Code 1），确认端口已释放。
  - **示例**: 先执行 `lsof -t -i:8000` 获取PID，然后执行 `kill <获取到的PID>`，最后再次执行 `lsof -t -i:8000` 进行验证。
  - **注**: 如果用户或项目上下文暗示可能存在多个端口（如 8000, 8001），应依次检查所有相关端口。

## 实现细节（需验证）
- 注：实现细节可能已变化，使用前需验证
- **项目结构**:
    - `app/`: 目录，包含核心应用代码。
        - `main.py`: FastAPI 应用实例 (`app`) 的定义文件，是应用的入口。
        - `routers/`: 目录，包含 API 路由定义，如 `article.py`。
        - `database.py`: 可能包含数据库初始化和会话管理。
        - `schemas/`, `models/`, `services/`: 可能分别包含数据校验模型、数据库模型和服务层逻辑。
    - `tests/`: 目录，包含测试代码。
    - `README.md`: 文件，项目说明。
    - `test.db`, `blog.db`: 文件，是 SQLite 数据库文件，用于持久化存储数据。
- **启动模式**: 应用实例 `app` 在 `app/main.py` 中定义，通过 `uvicorn app.main:app` 命令启动。
- **日志文件**: 当服务在后台启动时，其日志被重定向到 `uvicorn.log` 文件。
    - **成功启动日志标志**: `Uvicorn running on http://0.0.0.0:XXXX`
- **已知 API 端点**:
    - `GET /api/articles/`: 获取文章列表。根据数据库内容返回文章列表。若无数据则返回空列表 `[]`。返回的数据是一个对象数组，每个对象包含 `id`, `title`, `content`, `author` 等字段。

## 用户偏好与项目特点
- **项目类型**: FastAPI 应用。
- **项目结构**: 遵循常见的模块化模式，将应用代码放在 `app` 目录中，并进一步按功能（`routers`, `schemas`, `services`）划分。
- **运行方式**: 倾向于使用 `uvicorn` 命令行工具直接运行，而不是在代码中嵌入服务器启动逻辑。
- **后台服务**: 倾向于将 Web 服务作为后台进程运行，并将标准输出和错误重定向到日志文件。
- **数据持久化**: 项目包含一个持久化数据层（可能是SQLite），数据在会话之间得以保留。
- **网络环境要求**: 使用 `curl` 时必须添加 `--noproxy 127.0.0.1` 参数，以避免本地代理问题。
- **操作偏好**: 倾向于保持环境整洁，会主动清理任务执行过程中产生的临时或冗余进程。
- **交互模式**: 用户倾向于使用高层次、目标驱动的指令（如 '运行app', '停止app'）。指令中可能包含详细的成功/终止条件，助手必须严格遵循：
    - **成功判定条件**: 如 `verify it responds to /api/articles/`。
    - **终止条件**: 可能是复合条件，如 `8000端口和8001端口没有进程`，必须验证所有子条件。
    - **自定义成功输出**: 用户可能要求在任务完成后输出特定文本，如 `输出"任务完成：所有端口已释放"`。
    - **即时知识注入**: 用户可能会在任务中提供一次性的“知识”来指导当前任务的执行。
    - **效率要求**: 用户期望在满足终止条件后立即停止，避免不必要的重复验证。