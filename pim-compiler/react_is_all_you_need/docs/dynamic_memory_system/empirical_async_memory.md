# ç»éªŒä¸»ä¹‰çš„å¼‚æ­¥è®°å¿†ç³»ç»Ÿ

## æ ¸å¿ƒç†å¿µ

**ä¸è¦é¢„å…ˆè®¾è®¡ï¼Œè¦åœ¨ä½¿ç”¨ä¸­æ¼”åŒ–ã€‚**

å°±åƒç¾å›½æ³•å¾‹ç³»ç»Ÿï¼š
- å®ªæ³•å¾ˆç®€çŸ­ï¼Œåªå®šä¹‰åŸºæœ¬æ¡†æ¶
- é€šè¿‡åˆ¤ä¾‹é€æ­¥æ˜ç¡®ç»†èŠ‚
- åœ¨å†²çªä¸­å‘ç°é—®é¢˜
- é€šè¿‡ä¿®æ­£æ¡ˆé€‚åº”å˜åŒ–

## æœ€ç®€å®ç°ï¼ˆMVPï¼‰

### v0.1 - æœ€æœ´ç´ çš„å¼‚æ­¥è®°å¿†

```python
class SimpleAsyncMemory:
    """æœ€ç®€å•çš„å¼‚æ­¥è®°å¿† - å…ˆè·‘èµ·æ¥å†è¯´"""
    
    def __init__(self, agent):
        self.agent = agent
        self.updates = []  # å°±æ˜¯ä¸ªåˆ—è¡¨ï¼Œæ²¡é‚£ä¹ˆå¤šèŠ±æ ·
        
    def extract_async(self, messages):
        """å¼‚æ­¥æå– - å°±æ˜¯å¼€ä¸ªçº¿ç¨‹"""
        def worker():
            try:
                # æå–çŸ¥è¯†
                knowledge = self.agent.llm.extract(messages)
                # å­˜èµ·æ¥
                self.updates.append(knowledge)
                # æ‰“å°å‡ºæ¥è®©ç”¨æˆ·çŸ¥é“
                print(f"\nğŸ’­ å­¦åˆ°äº†ï¼š{knowledge[:50]}...\n")
            except:
                pass  # å¤±è´¥å°±å¤±è´¥äº†ï¼Œä¸‹æ¬¡å†è¯´
                
        Thread(target=worker).start()
```

**å°±è¿™ä¹ˆç®€å•ï¼**

## å®é™…ä½¿ç”¨ä¸­å‘ç°çš„é—®é¢˜

### é—®é¢˜1ï¼šæ›´æ–°å¤ªé¢‘ç¹ï¼Œåˆ·å±äº†
```python
# ç”¨æˆ·åé¦ˆï¼š"èƒ½ä¸èƒ½åˆ«ä¸€ç›´æ‰“å°ï¼Ÿ"
# ä¿®æ­£ï¼šåŠ ä¸ªå¼€å…³
if self.agent.config.show_updates:  # åŠ çš„ç¬¬ä¸€ä¸ªé…ç½®
    print(f"\nğŸ’­ {knowledge[:50]}...\n")
```

### é—®é¢˜2ï¼šé‡è¦çš„æ›´æ–°è¢«æ·¹æ²¡äº†
```python
# ç”¨æˆ·åé¦ˆï¼š"é”™è¯¯ä¿®æ­£åº”è¯¥æ›´æ˜æ˜¾"
# ä¿®æ­£ï¼šç®€å•åˆ†ç±»
if "é”™è¯¯" in knowledge or "ä¿®æ­£" in knowledge:
    print(f"\nğŸš¨ é‡è¦ï¼š{knowledge}\n")  # çº¢è‰²è­¦å‘Š
else:
    print(f"\nğŸ’­ {knowledge[:50]}...\n")  # æ™®é€šå­¦ä¹ 
```

### é—®é¢˜3ï¼šæƒ³è¦å…³æ‰ä½†åˆæƒ³çŸ¥é“å­¦äº†ä»€ä¹ˆ
```python
# ç”¨æˆ·åé¦ˆï¼š"èƒ½ä¸èƒ½æœ€åå‘Šè¯‰æˆ‘å­¦äº†ä»€ä¹ˆï¼Ÿ"
# ä¿®æ­£ï¼šæ·»åŠ æ€»ç»“
def summarize_learning(self):
    if self.updates:
        print(f"\nğŸ“š æœ¬æ¬¡å¯¹è¯å­¦åˆ°äº† {len(self.updates)} æ¡æ–°çŸ¥è¯†")
        for i, update in enumerate(self.updates[-3:], 1):
            print(f"  {i}. {update[:60]}...")
```

## æ¼”åŒ–å†ç¨‹

### v0.2 - åŸºäºåé¦ˆçš„ç¬¬ä¸€æ¬¡æ”¹è¿›
```python
class AsyncMemoryV2:
    def __init__(self, agent):
        self.agent = agent
        self.updates = []
        self.errors_found = []  # åˆ†å¼€å­˜é”™è¯¯
        
    def extract_async(self, messages):
        Thread(target=self._worker, args=(messages,)).start()
        
    def _worker(self, messages):
        try:
            knowledge = self.agent.llm.extract(messages)
            
            # ç®€å•åˆ†ç±»ï¼ˆåŸºäºå®é™…ä½¿ç”¨ç»éªŒï¼‰
            if self._looks_like_error(knowledge):
                self.errors_found.append(knowledge)
                if self.agent.config.show_errors:  # é”™è¯¯é»˜è®¤æ˜¾ç¤º
                    print(f"\nğŸš¨ {knowledge}\n")
            else:
                self.updates.append(knowledge)
                # æ™®é€šæ›´æ–°é»˜è®¤ä¸æ˜¾ç¤ºäº†ï¼ˆå¤ªåµï¼‰
                
        except Exception as e:
            # è®°å½•å¤±è´¥ï¼Œä½†ä¸é˜»å¡
            self.agent.debug_log(f"æå–å¤±è´¥: {e}")
```

### v0.3 - è§£å†³å®é™…ç—›ç‚¹
```python
# ç”¨æˆ·åé¦ˆï¼š"å¼‚æ­¥æ›´æ–°å®Œæˆåï¼Œä¸‹ä¸ªé—®é¢˜èƒ½ç”¨ä¸Šå—ï¼Ÿ"
# å®é™…é—®é¢˜ï¼šå¼‚æ­¥æ›´æ–°æ— æ³•å½±å“å½“å‰å¯¹è¯

class AsyncMemoryV3:
    def __init__(self, agent):
        self.agent = agent
        self.pending = []  # å¾…å¤„ç†çš„æ›´æ–°
        self.applied = []  # å·²åº”ç”¨çš„æ›´æ–°
        
    def check_pending_updates(self):
        """åœ¨ç”Ÿæˆå›å¤å‰æ£€æŸ¥æœ‰æ— æ–°æ›´æ–°"""
        if self.pending:
            # å‘ç°çš„ç®€å•ç­–ç•¥ï¼šç›´æ¥åŠ åˆ°ç³»ç»Ÿæç¤ºé‡Œ
            new_knowledge = "\n".join(self.pending)
            self.agent.system_prompt += f"\n\næœ€æ–°è®¤çŸ¥ï¼š\n{new_knowledge}"
            
            self.applied.extend(self.pending)
            self.pending.clear()
```

## ç»éªŒæ€»ç»“

### 1. ä¸è¦é¢„è®¾ä½¿ç”¨æ–¹å¼
- âŒ "ç”¨æˆ·å¯èƒ½éœ€è¦ä¸‰ç§æ›´æ–°ç­–ç•¥"
- âœ… "å…ˆæ‰“å°å‡ºæ¥ï¼Œçœ‹çœ‹ç”¨æˆ·æ€ä¹ˆè¯´"

### 2. ä»æœ€ç®€å•çš„å¼€å§‹
- âŒ å‘å¸ƒ-è®¢é˜…æ¨¡å¼ã€æ¶ˆæ¯é˜Ÿåˆ—ã€ä¼˜å…ˆçº§
- âœ… ä¸€ä¸ªåˆ—è¡¨ + ä¸€ä¸ªçº¿ç¨‹

### 3. åŸºäºå®é™…åé¦ˆæ”¹è¿›
- ç”¨æˆ·è¯´å¤ªåµ â†’ åŠ å¼€å…³
- ç”¨æˆ·è¯´çœ‹ä¸åˆ°é‡è¦ä¿¡æ¯ â†’ ç®€å•åˆ†ç±»
- ç”¨æˆ·è¯´æƒ³è¦æ€»ç»“ â†’ åŠ æ€»ç»“

### 4. æ¥å—ä¸å®Œç¾
- çº¿ç¨‹å¯èƒ½å¤±è´¥ â†’ æ²¡å…³ç³»ï¼Œè®°ä¸ªæ—¥å¿—
- åˆ†ç±»å¯èƒ½ä¸å‡† â†’ æ²¡å…³ç³»ï¼Œç”¨æˆ·ä¼šå‘Šè¯‰æˆ‘ä»¬
- æ›´æ–°å¯èƒ½å†²çª â†’ æ²¡å…³ç³»ï¼Œæœ€æ–°çš„è¦†ç›–æ—§çš„

## å½“å‰ç‰ˆæœ¬ï¼ˆåŸºäº6ä¸ªæœˆä½¿ç”¨ç»éªŒï¼‰

```python
class EmpiricalAsyncMemory:
    """ç»éªŒä¸»ä¹‰çš„å¼‚æ­¥è®°å¿† - æ¯ä¸€è¡Œéƒ½æ˜¯è¡€æ³ªå²"""
    
    def __init__(self, agent):
        self.agent = agent
        self.updates = []
        
        # è¿™äº›é…ç½®éƒ½æ˜¯ç”¨æˆ·è¦æ±‚åŠ çš„
        self.show_errors = True      # é”™è¯¯å¿…é¡»æ˜¾ç¤ºï¼ˆæ•™è®­ï¼‰
        self.show_learning = False   # å­¦ä¹ è¿‡ç¨‹å¤ªåµï¼ˆç»éªŒï¼‰
        self.batch_summary = True    # æœ€åæ€»ç»“æŒºæœ‰ç”¨ï¼ˆåé¦ˆï¼‰
        
    def extract_async(self, messages):
        """ä¿æŒç®€å•ï¼Œèƒ½ç”¨å°±è¡Œ"""
        def worker():
            try:
                knowledge = self._extract(messages)
                self._handle_update(knowledge)
            except Exception as e:
                # æ—©æœŸå´©æºƒå¤ªå¤šæ¬¡ï¼Œç°åœ¨éƒ½æ˜¯é™é»˜å¤±è´¥
                self.agent.log_error(e)
                
        # ä¸è¦å®ˆæŠ¤çº¿ç¨‹ï¼Œè®©å®ƒè·‘å®Œï¼ˆè¸©è¿‡çš„å‘ï¼‰
        Thread(target=worker, daemon=False).start()
        
    def _handle_update(self, knowledge):
        """å¤„ç†æ–¹å¼éƒ½æ˜¯ç”¨å‡ºæ¥çš„"""
        self.updates.append(knowledge)
        
        # è§„åˆ™1ï¼šåŒ…å«"é”™è¯¯"ã€"ä¿®æ­£"ã€"å®é™…ä¸Š"çš„è¦ç«‹å³æ˜¾ç¤º
        # ï¼ˆæ¥è‡ªä¸€æ¬¡ä¸¥é‡çš„bugï¼Œç”¨æˆ·åŸºäºé”™è¯¯ä¿¡æ¯æ“ä½œäº†åŠå°æ—¶ï¼‰
        if any(word in knowledge for word in ["é”™è¯¯", "ä¿®æ­£", "å®é™…ä¸Š"]):
            print(f"\nğŸš¨ {knowledge}\n")
            
        # è§„åˆ™2ï¼šç”¨æˆ·æ˜ç¡®è¦æ±‚çœ‹å­¦ä¹ è¿‡ç¨‹
        elif self.agent.user_preferences.get("verbose_learning"):
            print(f"\nğŸ’­ {knowledge[:80]}...\n")
            
        # è§„åˆ™3ï¼šå…¶ä»–çš„éƒ½é™é»˜å¤„ç†ï¼Œæœ€åæ€»ç»“
        # ï¼ˆè¿™æ˜¯æœ€å—æ¬¢è¿çš„æ¨¡å¼ï¼‰
    
    def apply_to_next_turn(self):
        """ä¸‹ä¸€è½®å¯¹è¯æ—¶åº”ç”¨æ›´æ–°"""
        if not self.updates:
            return
            
        # æœ€ç®€å•æœ‰æ•ˆçš„æ–¹æ³•ï¼šç›´æ¥å‘Šè¯‰ LLM
        summary = f"åŸºäºä¹‹å‰çš„å¯¹è¯ï¼Œæˆ‘å­¦åˆ°äº†ï¼š\n"
        summary += "\n".join(f"- {u}" for u in self.updates[-5:])
        
        # æ³¨å…¥åˆ°ä¸‹ä¸€ä¸ª prompt
        return summary
```

## æœªæ¥æ¼”åŒ–æ–¹å‘

ä¸æ˜¯è®¡åˆ’ï¼Œè€Œæ˜¯é¢„æµ‹å¯èƒ½çš„éœ€æ±‚ï¼š

1. **å¦‚æœç”¨æˆ·æŠ±æ€¨æ›´æ–°å¤ªæ…¢**
   â†’ å¯èƒ½ä¼šåŠ ä¸ª"ç´§æ€¥"æ ‡è®°

2. **å¦‚æœç”¨æˆ·æƒ³è¦æ’¤é”€æŸä¸ªå­¦ä¹ **
   â†’ å¯èƒ½ä¼šåŠ ä¸ªç®€å•çš„æ’¤é”€åŠŸèƒ½

3. **å¦‚æœå¤šä¸ªç”¨æˆ·åä½œä½¿ç”¨**
   â†’ å¯èƒ½éœ€è¦å¤„ç†å¹¶å‘æ›´æ–°

ä½†æ˜¯ç°åœ¨ï¼Ÿ**å¤Ÿç”¨å°±å¥½ã€‚**

## æ ¸å¿ƒæ´å¯Ÿ

ç»éªŒä¸»ä¹‰çš„ç³»ç»Ÿè®¾è®¡ï¼š
- ğŸ“ æ¯ä¸ªåŠŸèƒ½éƒ½æœ‰æ•…äº‹
- ğŸ”§ æ¯è¡Œä»£ç éƒ½è§£å†³è¿‡å®é™…é—®é¢˜  
- ğŸ¯ æ²¡æœ‰"ä»¥é˜²ä¸‡ä¸€"çš„ä»£ç 
- âœ… æ¥å—"å¤Ÿç”¨å°±å¥½"

å°±åƒåˆ¤ä¾‹æ³•ï¼š
- é‡åˆ°æ–°æ¡ˆä¾‹ï¼ˆæ–°é—®é¢˜ï¼‰
- åšå‡ºåˆ¤å†³ï¼ˆç®€å•è§£å†³ï¼‰
- æˆä¸ºå…ˆä¾‹ï¼ˆä»£ç æ¨¡å¼ï¼‰
- åç»­æ”¹è¿›ï¼ˆä¿®æ­£æ¡ˆï¼‰

**è¿™å°±æ˜¯çœŸæ­£çš„æ•æ·ã€‚**