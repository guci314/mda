# NLPL Language Specification v1.0
Natural Language Programming Language 语言规范

## 1. 概述

NLPL（Natural Language Programming Language）是自然语言的超集，任何合法的自然语言语句都是合法的NLPL程序。NLPL通过可选的结构化语法增强自然语言的精确性和可靠性，同时保留其完整的表达力。

### 1.1 核心理念
**NLPL = 自然语言 + 可选的结构化增强**

```
自然语言 ⊂ NLPL
```

这意味着：
- "创建博客系统" 是合法的NLPL程序
- "步骤1: 创建博客系统" 也是合法的NLPL程序  
- 结构化语法是渐进式的、可选的增强

### 1.2 设计原则
- **超集兼容**：任何自然语言都是合法的NLPL
- **渐进增强**：可以逐步添加结构提高精确性
- **语义保留**：不损失自然语言的丰富表达力
- **人机双向可读**：既能被人类理解，又能被LLM执行
- **知识驱动**：语言即程序，知识即数据

### 1.2 适用场景
- 工作流自动化
- 文档生成
- 数据处理流程
- Agent任务编排
- 知识驱动计算

## 2. 词法结构

### 2.1 基本元素

#### 2.1.1 标识符
```markdown
# 程序名
## 步骤名
**变量名**: 值
```

#### 2.1.2 结构标记
```markdown
# 程序 (Program)
## 目标 (Goal)
## 状态 (State)
## 主流程 (MainFlow)
### 步骤1 (Step)
- **动作**: 描述
- **工具**: 工具名
- **参数**: 
  - 参数1: 值1
  - 参数2: 值2
- **输出**: 结果变量
- **失败时**: 处理方式
```

#### 2.1.3 Markdown元素应用
```markdown
# 一级标题 - 程序名
## 二级标题 - 主要章节
### 三级标题 - 步骤
- 无序列表 - 并行任务
1. 有序列表 - 顺序步骤
**粗体** - 关键字/变量
*斜体* - 注释/说明
`代码` - 工具调用
> 引用 - 状态引用
```

### 2.2 层级规则
- 使用Markdown标题层级表示结构
- `#` 程序级别
- `##` 章节级别
- `###` 步骤级别
- 列表缩进表示子项

## 3. 程序结构

### 3.1 基本结构
```markdown
# 程序名称

## 目标
程序目标描述

## 状态

### 输入
- **变量1**: 初始值
- **变量2**: 初始值

### 内部状态
- **计数器**: 0
- **缓存**: ""

### 输出
- **结果**: null
- **完成**: false

## 主流程

### 步骤1: 步骤名称
- **动作**: 描述操作
- **工具**: `tool_name`
- **参数**: 参数值

### 步骤2: 步骤名称
- **动作**: 描述操作
```

### 3.2 状态定义
```markdown
## 状态

### 输入
- **文件路径**: "input.txt" *(字符串)*
- **处理模式**: "fast" *(字符串)*

### 内部状态
- **当前步骤**: 0 *(数字)*
- **数据缓存**: [] *(列表)*

### 输出
- **处理结果**: null
- **成功标志**: false *(布尔)*
```

### 3.3 数据类型
- `null` - 空值
- `布尔值/boolean` - true/false
- `数字/number` - 整数或浮点数
- `字符串/string` - 文本
- `列表/list` - 有序集合
- `字典/dict` - 键值对集合
- `对象/object` - 复杂结构

## 4. 流程控制

### 4.1 顺序执行
```markdown
## 主流程

### 步骤1: 读取文件
- **动作**: 读取输入文件内容

### 步骤2: 处理数据
- **动作**: 对数据进行转换

### 步骤3: 保存结果
- **动作**: 将结果写入文件
```

### 4.2 条件分支
```markdown
### 步骤: 条件判断

**如果** 条件成立:
- 执行操作A
- 更新状态X

**否则**:
- 执行操作B
- 更新状态Y
```

### 4.3 循环结构
```markdown
### 步骤: 处理列表

**对于每个** 文件 **在** 文件列表中:
1. 读取文件内容
2. 处理文件数据
3. 保存处理结果

### 步骤: 条件循环

**当** 计数器 < 10 **时**:
- 执行处理
- 计数器 += 1
```

### 4.4 并行执行
```markdown
### 步骤: 并行处理

**并行执行**:
- [ ] 任务1: 处理图片
- [ ] 任务2: 处理文本
- [ ] 任务3: 处理视频

*等待所有任务完成后继续*
```

## 5. 工具调用

### 5.1 基本调用
```markdown
### 步骤: 读取文件
- **工具**: `read_file`
- **参数**:
  - 路径: "input.txt"
  - 编码: "utf-8"
- **保存到**: > 文件内容
```

### 5.2 工具定义
```markdown
#### 工具: `read_file`
- **描述**: 读取文件内容
- **参数**:
  - `file_path` *(string)*: 文件路径
- **返回**: 文件内容 *(string)*

#### 工具: `write_file`
- **描述**: 写入文件
- **参数**:
  - `file_path` *(string)*: 文件路径
  - `content` *(string)*: 文件内容
- **返回**: 成功与否 *(boolean)*
```

## 6. 错误处理

### 6.1 错误捕获
```markdown
### 步骤: 尝试操作
- **动作**: 执行可能失败的操作
- **成功时**: 
  - 继续下一步
  - 更新成功状态
- **失败时**:
  - 记录错误日志
  - 回滚操作
  - 返回错误状态
```

### 6.2 重试机制
```markdown
### 步骤: 重试操作
- **动作**: 网络请求
- **重试策略**:
  - 最大次数: 3
  - 间隔时间: 1秒
  - 递增延迟: 2倍
- **最终失败**: 抛出异常
```

## 7. 状态管理

### 7.1 状态访问
```markdown
### 状态引用

**读取状态**:
> 当前值 = 状态.输入.文件路径
> 缓存数据 = 状态.内部.缓存

**更新状态**:
> 状态.输出.结果 = 处理后的数据
> 状态.内部.计数器++
```

### 7.2 状态转换
```markdown
### 步骤: 状态转换

**当** > 状态.内部.阶段 == "初始化" **时**:

**更新**:
- > 状态.内部.阶段 = "处理中"
- > 状态.内部.开始时间 = 现在
- > 状态.内部.步骤计数 = 0
```

## 8. 模板和复用

### 8.1 模板定义
```markdown
## 模板: CRUD操作

**参数**:
- 实体名: {entity}

### 创建{entity}
- **动作**: 创建新的{entity}实例
- **工具**: `create_{entity}`

### 读取{entity}
- **动作**: 查询{entity}数据
- **工具**: `read_{entity}`

### 更新{entity}
- **动作**: 修改{entity}属性
- **工具**: `update_{entity}`

### 删除{entity}
- **动作**: 删除{entity}记录
- **工具**: `delete_{entity}`
```

### 8.2 模板使用
```markdown
### 使用模板: CRUD操作

**应用参数**:
- 实体名 = "用户"

*此处将展开为用户的CRUD操作*
```

## 9. 注释和文档

### 9.1 注释方式
```markdown
### 步骤1: 处理数据
*这是一个斜体注释，说明步骤的目的*

- **动作**: 执行操作
  - *注释: 这里处理特殊情况*

<!-- HTML注释：这部分不会被渲染 -->

[链接注释]: # (这是隐藏的注释)
```

### 9.2 文档块
```markdown
# 程序名称

> **文档信息**
> - 功能: 演示NLPL基本语法
> - 作者: NLTM Engine
> - 版本: 1.0
> - 更新: 2024-01-01

## 目标
展示语言特性和基本用法
```

## 10. 标准库

NLPL的标准库是用NLPL自身编写的可复用程序集合。这些程序封装了常见的模式和流程，可以被其他NLPL程序引用和组合。

### 10.1 核心库程序

#### 数据转换库
```markdown
# 数据格式转换

## 目标
提供常见数据格式之间的转换

### CSV转JSON
- **输入**: CSV文本
- **输出**: JSON对象
- **步骤**: 解析CSV头部，逐行转换为对象

### JSON转Markdown表格
- **输入**: JSON数组
- **输出**: Markdown表格文本
- **步骤**: 提取字段，格式化为表格
```

#### 文件批处理库
```markdown
# 批量文件处理

## 目标
对目录中的文件进行批量操作

### 批量重命名
- **输入**: 文件模式，命名规则
- **输出**: 重命名结果
- **步骤**: 遍历匹配文件，应用命名规则

### 批量格式转换
- **输入**: 源格式，目标格式
- **输出**: 转换后的文件
- **步骤**: 识别文件类型，调用对应转换器
```

### 10.2 领域特定库

#### Web开发库
```markdown
# API测试套件

## 目标
自动化测试RESTful API

### 端点测试
- **输入**: API规范，测试数据
- **输出**: 测试报告
- **步骤**: 遍历端点，执行请求，验证响应
```

#### 数据分析库
```markdown
# 数据统计分析

## 目标
对数据集进行统计分析

### 基础统计
- **输入**: 数据集
- **输出**: 统计指标（均值、中位数、标准差）
- **步骤**: 计算各项统计指标，生成报告
```

### 10.3 包组织结构

NLPL使用文件系统的目录结构组织包，每个包通过README.md声明其接口。

```
stdlib/                          # 标准库根目录
├── README.md                    # 标准库总览
├── data/                        # 数据处理包
│   ├── README.md               # 包描述和接口
│   ├── conversion.nlpl         # 格式转换
│   └── validation.nlpl         # 数据验证
├── web/                         # Web开发包
│   ├── README.md              
│   ├── api_testing.nlpl       # API测试
│   └── scraping.nlpl          # 网页抓取
└── ml/                          # 机器学习包
    ├── README.md
    └── classification.nlpl     # 分类算法
```

### 10.4 依赖声明

```markdown
# 我的程序

## 依赖
- [标准库/数据处理](./stdlib/data/) - 数据转换和验证
- [标准库/Web开发](./stdlib/web/) v2.0+ - API测试工具
- [社区/机器学习](https://github.com/example/ml-nlpl) - ML算法
- [本地/业务逻辑](../business/) - 业务规则

## 主流程

### 步骤1: 转换数据
参考 [数据处理/转换流程](./stdlib/data/conversion.nlpl#csv-to-json)
- **输入**: "data.csv"
- **输出**: > 转换后的数据

### 步骤2: 调用API
使用 [Web开发/API测试](./stdlib/web/api_testing.nlpl) 中的端点测试
- **端点**: "/api/process"
- **数据**: > 转换后的数据
```

### 10.5 包的README规范

每个包的README.md应包含：

```markdown
# 包名称

## 概述
包的功能描述

## 提供的程序
- **程序1**: 功能描述
- **程序2**: 功能描述

## 依赖
- 依赖的其他包

## 版本
- v1.0: 初始版本
- v1.1: 添加新功能

## 使用示例
具体的使用案例
```

### 10.6 命名空间

- 使用目录路径作为命名空间
- 使用Markdown锚点引用具体步骤
- 使用链接别名简化引用

```markdown
[数据]: ./stdlib/data/
[转换]: ./stdlib/data/conversion.nlpl

使用 [转换] 中的CSV处理
```

## 11. 执行模型

### 11.1 执行顺序
```markdown
## 执行流程

1. **初始化阶段**
   - 初始化状态
   - 验证输入参数

2. **执行阶段**
   - 按顺序执行主流程
   - 实时更新状态

3. **完成阶段**
   - 验证输出
   - 返回结果
```

### 11.2 并发模型
- 并行任务共享只读状态
- 写操作需要同步
- 使用消息传递进行通信

### 11.3 错误传播
- 错误向上传播
- 可在任意层级捕获
- 未捕获错误导致程序终止

## 12. 最佳实践

### 12.1 命名规范
- 程序名：使用描述性名称
- 步骤名：使用"步骤N_动作描述"格式
- 变量名：使用下划线分隔的小写字母
- 常量名：使用大写字母

### 12.2 程序组织
- 相关步骤分组
- 复杂逻辑提取为子程序
- 重复代码使用模板
- 保持步骤简单明确

### 12.3 状态管理
- 最小化状态
- 明确状态转换
- 避免全局状态
- 使用不可变更新

## 13. 示例程序

### 13.1 Hello World
```markdown
# Hello World

## 目标
输出问候语

## 主流程

### 步骤1: 输出问候
- **动作**: 打印 "Hello, World!"
```

### 13.2 文件处理
```markdown
# 文件内容转换

## 目标
读取文件并转换格式

## 状态

### 输入
- **源文件**: "input.txt"
- **目标文件**: "output.json"

### 内部状态
- **文件内容**: ""
- **处理结果**: {}

### 输出
- **成功**: false

## 主流程

### 步骤1: 读取文件
- **工具**: `read_file`
- **参数**: > 状态.输入.源文件
- **保存到**: > 状态.内部.文件内容

### 步骤2: 处理内容
- **动作**: 解析并转换内容
- **输入**: > 状态.内部.文件内容
- **输出**: > 状态.内部.处理结果

### 步骤3: 写入结果
- **工具**: `write_file`
- **参数**:
  - path: > 状态.输入.目标文件
  - content: > 状态.内部.处理结果
- **更新**: > 状态.输出.成功 = true
```

## 14. 版本历史

- v1.0 (2024-01) - 初始版本
  - 基本语法定义
  - 核心流程控制
  - 工具调用机制
  - 状态管理系统

## 15. 附录

### 15.1 保留字列表
```
程序 目标 状态 主流程 步骤 动作 条件 循环 分支
工具 参数 输入 输出 保存到 更新 失败时 成功时
完成 并行 模板 使用模板 true false null
```

### 15.2 Markdown元素映射
```markdown
# 一级标题 → 程序名
## 二级标题 → 主要章节
### 三级标题 → 步骤

**粗体** → 关键字/变量名
*斜体* → 注释/说明
`代码` → 工具调用
> 引用 → 状态引用

- 无序列表 → 并行任务
1. 有序列表 → 顺序步骤
- [ ] 任务列表 → 待完成任务
- [x] 任务列表 → 已完成任务
```

### 15.3 扩展机制
- 自定义工具注册
- 插件系统
- 宏定义
- 类型扩展

---

本规范定义了NLPL的核心语法和语义，为实现NLTM（Natural Language Turing Machine）提供了标准化的编程接口。