# 模板重用机制决策文档

## 1. 决策：采用纯LLM语义匹配方案

经过实践验证，我们决定**放弃向量相似度匹配方案**，采用**纯LLM语义匹配**。

## 2. 向量匹配方案的致命缺陷

### 2.1 参数提取困难
```
用户输入: "列出大于100m的docker镜像"
模板: "列出大于{size}的docker镜像"

向量匹配能做到：
✓ 判断两者语义相似

向量匹配做不到：
✗ 识别"100m"是size参数
✗ 处理单位变化（100m vs 1GB）
✗ 处理同义词变化（列出 vs 显示）
```

### 2.2 实际代码的脆弱性
```python
# 向量匹配后的参数提取（极其脆弱）
def _extract_parameters_simple(self, task: str, template: TaskTemplate):
    # 只能用简单的正则表达式
    numbers = re.findall(r'\d+[a-zA-Z]*', task)
    if numbers and template.parameters:
        # 盲目地将第一个数字赋给第一个参数
        parameters[param_name] = numbers[0]
```

## 3. LLM方案的优势

### 3.1 一体化处理
```json
// 一次LLM调用完成所有工作
{
  "can_reuse": true,
  "template_id": "docker_size_filter",
  "extracted_parameters": {
    "size": "100m"  // 智能识别和提取
  },
  "confidence": 0.95,
  "reasoning": "任务要求筛选docker镜像大小，与模板功能完全匹配"
}
```

### 3.2 智能参数理解
- 理解"100m"、"100MB"、"100兆"都是同一个参数
- 知道"size"参数的语义角色
- 能处理多参数的复杂情况

## 4. 成本效益分析

虽然LLM调用有成本，但是：
1. 只在有模板库时才需要匹配（首次编译无需匹配）
2. 匹配成功后直接重用代码，节省了完整编译的成本
3. 准确性带来的用户体验提升远超成本

## 5. 结论

**向量匹配适合的场景**：完全相同的任务（无参数变化）

**实际场景**：几乎所有任务都有参数变化

因此，采用纯LLM方案是正确的选择。