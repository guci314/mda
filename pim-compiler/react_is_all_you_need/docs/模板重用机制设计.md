# 自然语言编译器模板重用机制设计

## 1. 背景与动机

### 1.1 问题描述

在自然语言编译器的使用中，经常出现结构相似但参数不同的任务：

```
任务1: 列出本机size大于50m的dockerimage
任务2: 列出本机size大于100m的dockerimage
任务3: 列出本机size大于200m的dockerimage
```

如果每次都重新编译，会导致：
- LLM调用次数过多，成本高
- 相同结构的代码重复生成
- 无法积累和复用已有知识

### 1.2 核心洞察

这些任务本质上是**同一个参数化函数的不同调用**：
```python
list_docker_images_by_size(size_threshold=50)
list_docker_images_by_size(size_threshold=100)
list_docker_images_by_size(size_threshold=200)
```

## 2. 设计原则

1. **语义理解优先**：利用LLM的语义理解能力，而不是依赖复杂的工程方案
2. **渐进式学习**：从具体任务中逐步提取通用模板
3. **可解释性**：系统应该能解释为什么可以重用某个模板
4. **简单性**：避免过度工程化，保持方案简洁

## 3. 技术方案

### 3.1 核心架构

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   用户任务      │────▶│  LLM模板匹配器   │────▶│   执行引擎      │
└─────────────────┘     └──────────────────┘     └─────────────────┘
                               │                           │
                               ▼                           ▼
                        ┌──────────────────┐      ┌─────────────────┐
                        │   模板库         │      │  参数化函数库   │
                        └──────────────────┘      └─────────────────┘
```

### 3.2 数据结构

#### 3.2.1 任务模板
```python
@dataclass
class TaskTemplate:
    id: str                          # 唯一标识
    pattern: str                     # 模板模式，如"列出{metric}大于{threshold}的{resource}"
    parameters: List[Parameter]      # 参数列表
    compiled_function: str           # 编译后的参数化Python代码
    examples: List[str]              # 使用示例
    metadata: Dict[str, Any]         # 元数据：创建时间、使用次数等
```

#### 3.2.2 参数定义
```python
@dataclass
class Parameter:
    name: str                        # 参数名
    type: str                        # 参数类型：number, string, enum等
    description: str                 # 参数说明
    extraction_hints: List[str]      # 提取提示，如单位转换规则
```

### 3.3 工作流程

#### 3.3.1 模板匹配流程

```python
def process_task(task: str) -> ExecutionResult:
    # 1. 获取所有模板的摘要
    templates_summary = template_manager.get_templates_summary()
    
    # 2. 让LLM判断是否可以重用模板
    match_result = llm_template_matcher.match(task, templates_summary)
    
    if match_result.can_reuse:
        # 3a. 重用已有模板
        template = template_manager.get_template(match_result.template_id)
        params = match_result.extracted_parameters
        return execute_template(template, params)
    else:
        # 3b. 编译新任务
        compilation_result = compile_new_task(task)
        
        # 4. 尝试提取模板供未来使用
        if compilation_result.is_parameterizable:
            template = extract_template(compilation_result)
            template_manager.add_template(template)
        
        return compilation_result
```

#### 3.3.2 LLM模板匹配

```python
class LLMTemplateMatcher:
    def match(self, task: str, templates: List[TemplateSummary]) -> MatchResult:
        prompt = f"""
        分析新任务是否可以使用已有模板。
        
        新任务：{task}
        
        已有模板：
        {self._format_templates(templates)}
        
        请判断：
        1. 是否可以使用某个已有模板？
        2. 如果可以，使用哪个模板？
        3. 参数值是什么？
        4. 如果不能重用，原因是什么？
        
        输出JSON格式：
        {{
            "can_reuse": boolean,
            "template_id": "模板ID（如果可以重用）",
            "extracted_parameters": {{"参数名": "参数值"}},
            "confidence": 0-1之间的置信度,
            "reasoning": "判断理由"
        }}
        
        注意：
        - 要理解语义相似性，不要被表面表达迷惑
        - 支持单位转换（如50m = 50MB = 50兆）
        - 考虑参数的合理范围
        """
        
        return self.llm.analyze(prompt)
```

### 3.4 模板提取机制

#### 3.4.1 参数化编译

当编译新任务时，提示LLM生成参数化代码：

```python
def compile_with_template_extraction(task: str):
    prompt = f"""
    编译任务：{task}
    
    要求：
    1. 生成Python代码实现该任务
    2. 识别任务中的可变参数（如数值、名称等）
    3. 将代码写成参数化函数而不是硬编码
    4. 提供模板模式描述
    
    输出格式：
    {{
        "code": "参数化的Python函数",
        "template_pattern": "任务模板（用{{}}表示参数）",
        "parameters": [
            {{"name": "参数名", "type": "类型", "value": "本次的值"}}
        ],
        "is_parameterizable": true/false
    }}
    """
    
    return llm.compile(prompt)
```

#### 3.4.2 模板演化

支持模板的渐进式泛化：

```python
class TemplateEvolution:
    def suggest_template_merge(self, template1: Template, template2: Template):
        """建议合并相似模板"""
        prompt = f"""
        分析两个模板是否可以合并为更通用的模板：
        
        模板1：{template1.pattern}
        示例：{template1.examples}
        
        模板2：{template2.pattern}
        示例：{template2.examples}
        
        如果可以合并，提供：
        1. 新的模板模式
        2. 参数映射关系
        3. 合并的好处
        """
        
        return llm.analyze(prompt)
```

### 3.5 优化策略

#### 3.5.1 模板索引优化

当模板数量增长时，避免每次发送所有模板：

```python
class TemplateIndex:
    def __init__(self):
        self.categories = {}  # 分类索引
        self.keywords = {}    # 关键词索引
    
    def find_relevant_templates(self, task: str, max_candidates=10):
        # 1. 提取任务关键词
        keywords = extract_keywords(task)
        
        # 2. 根据关键词查找候选模板
        candidates = []
        for keyword in keywords:
            if keyword in self.keywords:
                candidates.extend(self.keywords[keyword])
        
        # 3. 去重并限制数量
        return list(set(candidates))[:max_candidates]
```

#### 3.5.2 缓存机制

```python
class TemplateCache:
    def __init__(self, ttl=3600):
        self.cache = {}  # task_hash -> (template_id, parameters)
        self.ttl = ttl
    
    def get_cached_match(self, task: str):
        # 对任务进行规范化
        normalized = self.normalize_task(task)
        task_hash = hash(normalized)
        
        if task_hash in self.cache:
            entry = self.cache[task_hash]
            if not self.is_expired(entry):
                return entry
        
        return None
```

## 4. 使用示例

### 4.1 基本使用

```python
# 创建编译器
compiler = TemplateAwareCompiler()

# 第一次：创建新模板
result1 = compiler.compile("列出大于50m的docker镜像")
# 生成参数化函数并存储模板

# 第二次：重用模板
result2 = compiler.compile("列出大于100MB的docker images")
# LLM识别可以重用，提取参数100，调用已有函数

# 第三次：变体表达也能识别
result3 = compiler.compile("显示docker镜像中超过200兆的")
# LLM理解语义相似性，正确匹配模板
```

### 4.2 复杂场景

```python
# 组合条件
task = "列出大于50m且创建时间超过7天的docker镜像"
# 系统可以识别这是已有模板的扩展，建议创建新模板

# 否定条件
task = "列出除了alpine外大于50m的镜像"
# 系统理解这需要额外的过滤参数
```

## 5. 性能分析

### 5.1 效率提升

假设平均任务的编译需要：
- LLM完整编译：2-3秒，1000-2000 tokens
- 模板匹配+参数提取：0.5-1秒，200-400 tokens

重用率达到60%时，可以：
- 减少50%的LLM调用时间
- 节省60%的token消耗
- 提高结果的一致性

### 5.2 存储开销

- 每个模板：约1-2KB（包括代码和元数据）
- 1000个模板：约1-2MB
- 可以定期清理低频使用的模板

## 6. 未来扩展

### 6.1 模板组合
支持多个简单模板组合成复杂任务：
```python
# 基础模板1：列出docker镜像
# 基础模板2：按大小过滤
# 基础模板3：按时间过滤
# 组合：列出大于50m且7天前创建的镜像
```

### 6.2 模板学习
从执行历史中自动发现新模板：
```python
class TemplateDiscovery:
    def analyze_history(self, executions: List[Execution]):
        # 寻找相似任务
        # 提取共同模式
        # 建议新模板
        pass
```

### 6.3 跨语言模板
同一模板可以编译到不同目标语言：
```python
template.compile_to_python(params)
template.compile_to_javascript(params)
template.compile_to_bash(params)
```

## 7. 结论

模板重用机制通过LLM的语义理解能力，实现了自然语言任务的智能复用。这种方案：

1. **简单优雅**：利用LLM的理解能力，避免复杂工程
2. **灵活强大**：可以处理各种语义变体
3. **持续进化**：随使用不断积累和优化模板
4. **性能优越**：显著减少LLM调用和响应时间

这是向"自然语言函数库"迈出的重要一步，让自然语言编程真正具备了代码复用的能力。