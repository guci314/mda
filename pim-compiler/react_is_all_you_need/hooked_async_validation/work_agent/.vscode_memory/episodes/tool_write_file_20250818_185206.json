{
  "id": "tool_write_file_20250818_185206",
  "timestamp": "2025-08-18T18:52:06.680758",
  "event": "tool_write_file",
  "data": {
    "tool": "write_file",
    "arguments": {
      "file_path": "data_processor.py",
      "content": "import pandas as pd\nimport numpy as np\nfrom typing import List, Dict, Any, Optional\nimport logging\n\nclass DataProcessor:\n    \"\"\"\n    数据处理类，用于处理CSV数据和执行数据清洗操作\n    \"\"\"\n    \n    def __init__(self, file_path: Optional[str] = None):\n        \"\"\"\n        初始化数据处理器\n        \n        Args:\n            file_path (str, optional): CSV文件路径\n        \"\"\"\n        self.file_path = file_path\n        self.data = None\n        self.logger = logging.getLogger(__name__)\n        \n    def load_csv(self, file_path: Optional[str] = None) -> pd.DataFrame:\n        \"\"\"\n        读取CSV文件\n        \n        Args:\n            file_path (str, optional): CSV文件路径，如果未提供则使用初始化时的路径\n            \n        Returns:\n            pd.DataFrame: 读取的数据\n            \n        Raises:\n            FileNotFoundError: 文件未找到\n            pd.errors.EmptyDataError: 文件为空\n            pd.errors.ParserError: 解析错误\n        \"\"\"\n        path = file_path or self.file_path\n        \n        if not path:\n            raise ValueError(\"未提供文件路径\")\n            \n        try:\n            self.data = pd.read_csv(path)\n            self.logger.info(f\"成功读取文件: {path}\")\n            return self.data\n        except FileNotFoundError:\n            self.logger.error(f\"文件未找到: {path}\")\n            raise\n        except pd.errors.EmptyDataError:\n            self.logger.error(f\"文件为空: {path}\")\n            raise\n        except pd.errors.ParserError as e:\n            self.logger.error(f\"解析文件时出错: {path} - {str(e)}\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"读取文件时发生未知错误: {path} - {str(e)}\")\n            raise\n    \n    def clean_data(self, \n                   remove_duplicates: bool = True,\n                   handle_missing: str = 'drop',\n                   missing_value_replacement: Any = None,\n                   columns_to_clean: Optional[List[str]] = None) -> pd.DataFrame:\n        \"\"\"\n        清洗数据\n        \n        Args:\n            remove_duplicates (bool): 是否删除重复行\n            handle_missing (str): 处理缺失值的方式 ('drop', 'fill', 'ignore')\n            missing_value_replacement (Any): 缺失值替换的值，当handle_missing='fill'时使用\n            columns_to_clean (List[str], optional): 需要清洗的列，如果为None则清洗所有列\n            \n        Returns:\n            pd.DataFrame: 清洗后的数据\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"数据未加载，请先调用load_csv方法\")\n            \n        cleaned_data = self.data.copy()\n        \n        # 选择需要清洗的列\n        if columns_to_clean:\n            # 确保指定的列存在于数据中\n            existing_columns = [col for col in columns_to_clean if col in cleaned_data.columns]\n            if not existing_columns:\n                self.logger.warning(\"指定的列不存在于数据中\")\n                return cleaned_data\n            cleaning_data = cleaned_data[existing_columns]\n        else:\n            cleaning_data = cleaned_data\n            existing_columns = list(cleaned_data.columns)\n        \n        # 删除重复行\n        if remove_duplicates:\n            original_rows = len(cleaned_data)\n            cleaned_data = cleaned_data.drop_duplicates()\n            removed_rows = original_rows - len(cleaned_data)\n            if removed_rows > 0:\n                self.logger.info(f\"删除了 {removed_rows} 行重复数据\")\n        \n        # 处理缺失值\n        if handle_missing == 'drop':\n            original_rows = len(cleaned_data)\n            cleaned_data = cleaned_data.dropna(subset=existing_columns)\n            removed_rows = original_rows - len(cleaned_data)\n            if removed_rows > 0:\n                self.logger.info(f\"删除了 {removed_rows} 行包含缺失值的数据\")\n        elif handle_missing == 'fill':\n            if missing_value_replacement is not None:\n                cleaned_data[existing_columns] = cleaned_data[existing_columns].fillna(missing_value_replacement)\n                self.logger.info(f\"用 {missing_value_replacement} 填充了缺失值\")\n            else:\n                # 根据数据类型进行默认填充\n                for col in existing_columns:\n                    if cleaned_data[col].dtype in ['int64', 'float64']:\n                        cleaned_data[col] = cleaned_data[col].fillna(cleaned_data[col].mean())\n                    else:\n                        cleaned_data[col] = cleaned_data[col].fillna(cleaned_data[col].mode().iloc[0] if not cleaned_data[col].mode().empty else 'Unknown')\n                self.logger.info(\"使用默认值填充了缺失值\")\n        \n        self.data = cleaned_data\n        return self.data\n    \n    def get_data_info(self) -> Dict[str, Any]:\n        \"\"\"\n        获取数据信息\n        \n        Returns:\n            Dict: 包含数据信息的字典\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"数据未加载，请先调用load_csv方法\")\n            \n        info = {\n            'shape': self.data.shape,\n            'columns': list(self.data.columns),\n            'dtypes': self.data.dtypes.to_dict(),\n            'missing_values': self.data.isnull().sum().to_dict(),\n            'duplicates': self.data.duplicated().sum()\n        }\n        \n        return info\n    \n    def save_to_csv(self, file_path: str, index: bool = False) -> None:\n        \"\"\"\n        将数据保存为CSV文件\n        \n        Args:\n            file_path (str): 保存文件路径\n            index (bool): 是否保存索引\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"数据未加载，请先调用load_csv方法\")\n            \n        self.data.to_csv(file_path, index=index)\n        self.logger.info(f\"数据已保存到: {file_path}\")\n\nif __name__ == \"__main__\":\n    # 设置日志\n    logging.basicConfig(level=logging.INFO)\n    \n    # 示例用法\n    print(\"DataProcessor 类已定义，可用于数据处理任务\")"
    },
    "round": 1
  }
}