{
  "id": "tool_write_file_20250818_185501",
  "timestamp": "2025-08-18T18:55:01.160680",
  "event": "tool_write_file",
  "data": {
    "tool": "write_file",
    "arguments": {
      "file_path": "data_processor.py",
      "content": "import pandas as pd\nimport numpy as np\nfrom typing import List, Dict, Any, Optional\nimport logging\n\nclass DataProcessor:\n    \"\"\"\n    数据处理类，用于处理CSV文件和执行数据清洗操作\n    \"\"\"\n    \n    def __init__(self, file_path: Optional[str] = None):\n        \"\"\"\n        初始化数据处理器\n        \n        Args:\n            file_path (str, optional): CSV文件路径\n        \"\"\"\n        self.file_path = file_path\n        self.data = None\n        self.logger = logging.getLogger(__name__)\n        \n    def load_csv(self, file_path: Optional[str] = None) -> pd.DataFrame:\n        \"\"\"\n        读取CSV文件\n        \n        Args:\n            file_path (str, optional): CSV文件路径，如果未提供则使用初始化时的路径\n            \n        Returns:\n            pd.DataFrame: 读取的数据\n            \n        Raises:\n            FileNotFoundError: 文件未找到\n            pd.errors.EmptyDataError: 文件为空\n            pd.errors.ParserError: 解析错误\n        \"\"\"\n        path = file_path or self.file_path\n        \n        if not path:\n            raise ValueError(\"未提供文件路径\")\n            \n        try:\n            self.data = pd.read_csv(path)\n            self.logger.info(f\"成功加载文件: {path}\")\n            return self.data\n        except FileNotFoundError:\n            self.logger.error(f\"文件未找到: {path}\")\n            raise\n        except pd.errors.EmptyDataError:\n            self.logger.error(f\"文件为空: {path}\")\n            raise\n        except pd.errors.ParserError as e:\n            self.logger.error(f\"解析文件时出错: {path}, 错误: {str(e)}\")\n            raise\n        except Exception as e:\n            self.logger.error(f\"加载文件时出现未知错误: {path}, 错误: {str(e)}\")\n            raise\n    \n    def clean_data(self, \n                   remove_duplicates: bool = True,\n                   handle_missing: str = 'drop',\n                   missing_value_threshold: float = 0.5,\n                   columns_to_clean: Optional[List[str]] = None) -> pd.DataFrame:\n        \"\"\"\n        清洗数据\n        \n        Args:\n            remove_duplicates (bool): 是否移除重复行\n            handle_missing (str): 处理缺失值的方式 ('drop', 'fill', 'ignore')\n            missing_value_threshold (float): 删除列的缺失值阈值 (0-1)\n            columns_to_clean (List[str], optional): 指定要清洗的列\n            \n        Returns:\n            pd.DataFrame: 清洗后的数据\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"没有加载数据，请先调用load_csv方法\")\n            \n        cleaned_data = self.data.copy()\n        \n        # 如果指定了列，则只处理这些列\n        if columns_to_clean:\n            cleaned_data = cleaned_data[columns_to_clean]\n        \n        # 移除重复行\n        if remove_duplicates:\n            original_rows = len(cleaned_data)\n            cleaned_data = cleaned_data.drop_duplicates()\n            removed_duplicates = original_rows - len(cleaned_data)\n            if removed_duplicates > 0:\n                self.logger.info(f\"移除了 {removed_duplicates} 行重复数据\")\n        \n        # 处理缺失值\n        if handle_missing != 'ignore':\n            # 删除缺失值过多的列\n            threshold = len(cleaned_data) * missing_value_threshold\n            cleaned_data = cleaned_data.dropna(axis=1, thresh=threshold)\n            \n            # 处理剩余的缺失值\n            if handle_missing == 'drop':\n                cleaned_data = cleaned_data.dropna()\n            elif handle_missing == 'fill':\n                # 数值列用均值填充，非数值列用众数填充\n                for column in cleaned_data.columns:\n                    if cleaned_data[column].dtype in ['int64', 'float64']:\n                        cleaned_data[column].fillna(cleaned_data[column].mean(), inplace=True)\n                    else:\n                        mode_value = cleaned_data[column].mode()\n                        if not mode_value.empty:\n                            cleaned_data[column].fillna(mode_value[0], inplace=True)\n        \n        self.logger.info(f\"数据清洗完成，原始数据 {len(self.data)} 行，清洗后 {len(cleaned_data)} 行\")\n        self.data = cleaned_data\n        return cleaned_data\n    \n    def get_data_info(self) -> Dict[str, Any]:\n        \"\"\"\n        获取数据信息\n        \n        Returns:\n            Dict[str, Any]: 数据信息字典\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"没有加载数据，请先调用load_csv方法\")\n            \n        info = {\n            'shape': self.data.shape,\n            'columns': list(self.data.columns),\n            'missing_values': self.data.isnull().sum().to_dict(),\n            'data_types': self.data.dtypes.to_dict(),\n            'duplicate_rows': self.data.duplicated().sum()\n        }\n        \n        return info\n    \n    def save_to_csv(self, file_path: str, index: bool = False) -> None:\n        \"\"\"\n        保存数据到CSV文件\n        \n        Args:\n            file_path (str): 保存文件路径\n            index (bool): 是否保存索引\n        \"\"\"\n        if self.data is None:\n            raise ValueError(\"没有数据可保存\")\n            \n        self.data.to_csv(file_path, index=index)\n        self.logger.info(f\"数据已保存到: {file_path}\")"
    },
    "round": 1
  }
}