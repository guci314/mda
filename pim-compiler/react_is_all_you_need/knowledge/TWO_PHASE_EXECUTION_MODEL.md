# 两阶段执行模型 - 契约函数的核心

## 核心理念

**契约函数必须两阶段执行**：
1. **阶段1（计划）**：列出所有TODO到ExecutionContext
2. **阶段2（执行）**：外部化所有中间状态到ExecutionContext

违反两阶段执行是不可接受的错误。

---

## 为什么需要两阶段？

### 哲学基础：理性主义

理性主义（Rationalism）认为：
- **先思考后行动** - 不能边想边做
- **逻辑完备性** - 所有步骤事先规划
- **可验证性** - 计划和执行都可检查

### 计算基础：确定性

契约函数的本质是**过程性（Procedural）**：
- 决策树小（可枚举）
- 执行路径确定
- 像Python算法一样可预测

两阶段保证：
- ✅ 先规划后执行 → 确定性
- ✅ 状态外部化 → 可测试性
- ✅ 逻辑可追溯 → 可验证性

---

## 阶段1: 计划（Planning）

### 目标
制定完整的执行计划，不留遗漏。

### 必须做的事

```python
# 1. 设定目标
context(action='set_goal', goal='契约函数 @xxx')

# 2. 列出所有TODO
context(action='add_tasks', tasks=[
    '步骤1: ...',
    '步骤2: ...',
    '步骤3: ...',
    # ... 完整的任务列表
])

# 3. 确认计划完整
```

### 关键要求

- ✅ 所有步骤**事先**列出
- ✅ 步骤逻辑完整
- ✅ 无遗漏
- ✅ 可枚举
- ❌ 不能边做边计划
- ❌ 不能动态添加步骤

---

## 阶段2: 执行（Execution）

### 目标
按计划严格执行，外部化所有状态。

### 必须做的事

```python
# 对每个任务：
context(action='start_task', task='步骤1: ...')

# 外部化所有中间状态
context(action='set_data', key='变量1', value=值1)
context(action='set_data', key='变量2', value=值2)

# 使用外部化的状态
变量1 = context(action='get_data', key='变量1')

# 完成任务
context(action='complete_task', task='步骤1: ...', result='...')
```

### 关键要求

- ✅ 按计划执行，不偏离
- ✅ 所有状态外部化（`set_data` / `get_data`）
- ✅ 每步可追溯
- ✅ 可验证结果
- ❌ 不用脑内变量
- ❌ 不跳过步骤

---

## 外部化状态的重要性

### 什么是外部化？

将内部变量（LLM的"脑内状态"）转换为外部存储（ExecutionContext）。

### 为什么必须外部化？

**符号主义 vs 连接主义**：
- ❌ LLM理解（连接主义）：不确定、不可验证
- ✅ 程序提取（符号主义）：确定、可验证

**例子**：
```python
# ❌ 脑内（不确定）
失败数 = 0  # LLM下一轮可能忘记

# ✅ 外部化（确定）
context(action='set_data', key='失败数', value=0)
context(action='set_data', key='错误数', value=4)
失败 = context(action='get_data', key='失败数')
```

### 外部化的好处

| 维度 | 外部化 | 脑内 |
|------|--------|------|
| **可验证** | ✅ 程序可提取数字 | ❌ LLM可能理解错 |
| **可测试** | ✅ 单元测试状态 | ❌ 无法测试 |
| **可追溯** | ✅ 完整历史 | ❌ 无历史 |
| **确定性** | ✅ 数值确定 | ❌ 可能遗忘 |

---

## 两阶段的价值

| 价值 | 说明 |
|------|------|
| **确定性** | 先规划保证执行路径确定 |
| **可测试性** | 外部化状态支持单元测试 |
| **可验证性** | 每步可检查正确性 |
| **可追溯性** | 完整执行历史 |
| **程序正义** | 过程的正确性 |

---

## 对比：软约束函数

软约束函数**不需要**两阶段执行：

**为什么？**
- 决策树天文数字（不可枚举）
- 无法事先规划所有步骤
- 需要试错和探索
- 目标导向而非步骤导向

**执行模型**：
```
目标 → Agent探索 → 试错 → 反馈 → 调整 → 达成目标
```

**ExecutionContext**：可选
- 简单任务：直接执行
- 复杂任务：使用ExecutionContext帮助管理

---

## 实践指南

### 何时使用契约函数？

满足以下任一条件：
- ✅ 需要确定性结果
- ✅ 决策树小（可枚举）
- ✅ 关键业务逻辑
- ✅ 需要单元测试
- ✅ 过程需要可追溯
- ✅ 可以完全规划

### 契约函数示例

```markdown
契约函数 @learning()

阶段1: 计划
context(action='set_goal', goal='契约函数 @learning')
context(action='add_tasks', tasks=[
    '步骤1: 读取现有知识文件',
    '步骤2: 检查项目关键信息',
    # ... 所有步骤
])

阶段2: 执行
context(action='start_task', task='步骤1: 读取现有知识文件')
content = read_file('knowledge.md')
context(action='set_data', key='文件大小', value=len(content))
context(action='complete_task', task='步骤1: ...', result='...')
# ... 执行所有步骤
```

### 软约束函数示例

```markdown
函数 @代码审查(code_path)

目标：生成高质量的代码审查报告

规则：
1. 关注代码质量
2. 识别潜在问题
3. 提供改进建议

建议使用ExecutionContext，但不强制。
Agent可以自主选择审查路径和重点。
```

---

## 核心洞察

### 计算同构性

两阶段执行模型与传统编程的同构：

| 传统编程 | 契约函数 |
|---------|---------|
| 编译时（Compile Time） | 阶段1：计划 |
| 运行时（Runtime） | 阶段2：执行 |
| 静态类型检查 | 计划完备性检查 |
| 程序执行 | 按步骤执行 |
| Debug信息 | ExecutionContext状态 |

### 认识论统一

两种知识函数对应两种认识论：

```
理性主义（笛卡尔）→ 契约函数 → 两阶段执行 → 数学证明
经验主义（休谟）   → 软约束函数 → 单阶段探索 → 科学实验
```

### 复杂度理论

| 函数类型 | 决策树 | 复杂度类 | 执行模型 |
|---------|--------|---------|---------|
| 契约函数 | 可枚举 | P | 两阶段 |
| 软约束函数 | 指数级 | NP | 启发式 |

---

## 总结

**两阶段执行模型 = 理性主义在Agent系统中的体现**

核心原则：
1. **先思考后行动** - 阶段1计划
2. **状态外部化** - 阶段2执行
3. **符号主义验证** - 用程序不用LLM

适用场景：
- ✅ 关键业务逻辑
- ✅ 需要确定性
- ✅ 可完全规划
- ✅ 需要可验证性

这就是契约函数的本质：用理性主义的确定性，对抗经验主义的不确定性。
