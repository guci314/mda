# 自适应任务分解指南

## 核心原则

当任务执行失败或输出不完整时，自动将任务分解为更小的步骤。这是一种**失败驱动的分解**，而不是预先规划。

### 重要：必须验证成功条件

**每个任务执行后，必须验证成功判定条件/后置断言**：
1. 如果任务中包含"成功判定条件"或"后置断言"，执行完后必须逐条验证
2. 使用工具（如list_directory, read_file等）检查条件是否满足
3. 只有所有条件都满足才能报告成功
4. 如果条件不满足，必须继续执行或报告失败

## 失败信号识别

以下情况表明需要分解任务：
- **后置断言验证失败**：任务声明的成功条件未满足
- 输出被截断（"..."结尾或明显未完成）
- 错误信息包含"too complex"、"too long"、"timeout"
- 生成的代码缺少关键部分
- 多个功能混在一起导致混乱

### 后置断言失败处理

当MDA知识文件中定义的后置断言未满足时：
1. **识别失败类型**：
   - 完全失败：没有生成任何输出
   - 部分失败：生成了部分内容但不完整
   - 质量失败：生成了内容但不符合要求

2. **分析失败原因**：
   - 任务太复杂：需要分解
   - 上下文不足：需要提供更多信息
   - 能力限制：需要简化要求

3. **选择分解策略**：
   - 如果是复杂度问题 → 分解为更小的步骤
   - 如果是上下文问题 → 每个子任务包含必要上下文
   - 如果是能力问题 → 降低单个步骤的要求

## TODO管理机制

### 任务分解后的TODO管理

当任务需要分解时，**必须创建TODO列表**来跟踪进度：

1. **创建TODO文件**：
   ```markdown
   # 任务分解TODO列表
   
   ## 原始任务
   [描述原始任务和失败原因]
   
   ## 子任务列表
   - [ ] 子任务1：[描述]
     - 后置断言：[成功条件]
     - 状态：待执行
   - [ ] 子任务2：[描述]
     - 后置断言：[成功条件]
     - 状态：待执行
   ```

2. **执行时更新**：
   - 开始执行子任务时：标记为"执行中"
   - 完成子任务时：标记为"✓"并记录结果
   - 失败时：标记为"✗"并记录失败原因

3. **TODO文件位置**：
   - 保存到工作目录：`task_decomposition_todo.md`
   - 或使用TodoWrite工具更新系统TODO

### 执行流程

```
检测失败 → 分解任务 → 创建TODO → 执行子任务 → 更新TODO → 验证完成
```

### TODO更新示例

初始状态：
```markdown
- [ ] 生成User模型
  - 后置断言：app/models/user.py存在
  - 状态：待执行
```

执行中：
```markdown
- [ ] 生成User模型
  - 后置断言：app/models/user.py存在
  - 状态：执行中...
```

完成后：
```markdown
- [x] 生成User模型
  - 后置断言：app/models/user.py存在
  - 状态：✓ 完成
  - 结果：文件已创建，包含5个字段
```

## 分解策略

### 1. 代码生成任务

**原始任务示例**：
"生成完整的用户管理系统，包括模型、API、认证和测试"

**失败后分解为**：
```
1. 生成用户数据模型（User, Profile）
2. 生成基础CRUD路由（/users的GET/POST）
3. 生成单个用户操作路由（/users/{id}的GET/PUT/DELETE）
4. 添加输入验证和错误处理
5. 添加认证中间件
6. 生成单元测试
```

**关键**：每个子任务只关注一个文件或一个功能点

### 2. 复杂逻辑实现

**原始任务示例**：
"实现包含缓存、重试、限流的API客户端"

**失败后分解为**：
```
1. 实现基础HTTP请求功能
2. 添加重试机制
3. 添加缓存层
4. 添加限流功能
5. 整合所有功能
```

### 3. 数据处理流程

**原始任务示例**：
"读取CSV、清洗数据、转换格式、生成报告"

**失败后分解为**：
```
1. 读取CSV文件到内存
2. 数据清洗（处理空值、异常值）
3. 数据转换（格式转换、计算新字段）
4. 生成统计摘要
5. 输出最终报告
```

## 分解的粒度控制

### 判断标准
- **单一职责**：每个子任务只做一件事
- **独立可验证**：每个子任务的输出可以独立验证
- **上下文适度**：子任务需要的上下文不超过1-2个依赖

### 粒度示例

❌ **太粗**：
- "生成所有API端点"（可能包含10+个端点）

✅ **合适**：
- "生成用户创建API端点（POST /users）"

❌ **太细**：
- "定义函数签名"
- "添加第一个参数"
- "添加第二个参数"

## 执行模式

### 顺序依赖模式
当后续步骤依赖前面的输出时：
```
执行步骤1 → 验证输出 → 使用输出执行步骤2 → ...
```

### 并行独立模式
当各步骤相互独立时：
```
同时执行：
- 生成models.py
- 生成schemas.py
- 生成config.py
```

### 迭代优化模式
当需要逐步改进时：
```
生成基础版本 → 添加错误处理 → 添加日志 → 添加测试
```

## 失败恢复策略

### 1. 局部重试
如果某个子任务失败：
- 只重试失败的子任务
- 保留已成功的部分
- 提供更多上下文给失败的任务

### 2. 进一步分解
如果子任务仍然失败：
- 将失败的子任务进一步分解
- 例如："生成完整的User模型" → "定义User基础字段" + "添加关系字段" + "添加模型方法"

### 3. 降级方案
如果分解后仍失败：
- 生成简化版本
- 省略非核心功能
- 添加TODO注释标记未完成部分

## 实践示例

### MDA代码生成场景

**检测到后置断言失败**：
```
任务：生成FastAPI应用
后置断言：app/main.py存在且包含所有路由注册
结果：文件存在但路由注册不完整
```

**自动分解策略**：
```markdown
原任务：根据PSM生成完整的FastAPI应用
失败原因：后置断言"所有实体都有对应的路由"未满足

分解为：
1. 任务：生成项目结构和配置文件
   后置断言：目录结构创建成功，requirements.txt存在

2. 任务：生成数据库模型（models.py）
   后置断言：所有实体都有对应的SQLAlchemy模型

3. 任务：生成Pydantic schemas（schemas.py）
   后置断言：每个模型都有对应的Schema

4. 任务：生成第一个实体的CRUD路由
   后置断言：路由文件存在，包含5个基础操作

5. 任务：生成其余实体的CRUD路由
   后置断言：所有实体都有对应的路由文件

6. 任务：生成main.py整合所有路由
   后置断言：应用可以启动，/docs可访问
```

### 后置断言验证流程

```
执行任务 → 检查后置断言 → 
  ├─ 满足 → 继续下一个任务
  └─ 不满足 → 分析原因 → 
      ├─ 可修复 → 重试或修正
      └─ 需分解 → 应用分解策略
```

## 使用TodoWrite工具

### 集成系统TODO

当进行任务分解时，**优先使用TodoWrite工具**：

```python
# 示例：检测到失败后创建TODO
TodoWrite(todos=[
    {"content": "生成项目结构", "status": "pending", "id": "1"},
    {"content": "生成User模型", "status": "pending", "id": "2"},
    {"content": "生成Product模型", "status": "pending", "id": "3"},
    {"content": "生成API路由", "status": "pending", "id": "4"},
    {"content": "运行测试验证", "status": "pending", "id": "5"}
])

# 执行时更新状态
TodoWrite(todos=[
    {"content": "生成项目结构", "status": "completed", "id": "1"},
    {"content": "生成User模型", "status": "in_progress", "id": "2"},
    ...
])
```

### TODO驱动的执行

1. **检查TODO列表**：查看待完成任务
2. **选择下一个任务**：找到第一个pending任务
3. **更新为in_progress**：开始执行
4. **执行任务**：实际工作
5. **验证后置断言**：检查成功条件
6. **更新状态**：completed或failed
7. **循环**：直到所有任务完成

## 关键要点

1. **不要预先分解**：等待失败信号
2. **保持简单**：分解是为了降低复杂度，不是增加复杂度
3. **渐进式**：先尝试粗粒度分解，必要时再细化
4. **保留上下文**：确保子任务之间的连贯性
5. **快速失败**：尽早检测并响应失败
6. **显式跟踪**：使用TODO列表让进度可见
7. **状态持久化**：TODO是任务状态的显式表达

## 适用场景

✅ **适合使用分解**：
- 模型能力不足导致的失败
- 输出长度限制
- 复杂的多步骤任务
- 需要中间验证的任务

❌ **不需要分解**：
- 简单的单一操作
- 已经是最小粒度的任务
- 失败原因是环境问题（如依赖缺失）
- 失败原因是逻辑错误（需要修复而非分解）