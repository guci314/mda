# 调试原则与策略

## 🎯 核心理念
调试是理解系统的过程，不是随机尝试的过程。

## 🔍 通用调试策略

### 1. 分层诊断法
从外到内，逐层深入：
```
外层：命令能否执行？
中层：环境配置正确吗？
内层：代码逻辑有问题吗？
```

### 2. 二分查找法
问题空间二分：
- 前半部分工作吗？
- 后半部分工作吗？
- 缩小问题范围

### 3. 最小复现法
```python
# 原始问题：复杂系统测试失败
# 简化1：单独运行一个测试文件
python test_one.py
# 简化2：运行最简单的测试函数
python -c "from test_one import test_simple; test_simple()"
# 简化3：测试最基础的导入
python -c "import app"
```

## 🔧 常见问题诊断模式

### Python导入错误
```bash
# 诊断序列
python -c "import sys; print(sys.path)"  # 检查Python路径
ls -la                                    # 确认文件存在
python module.py                         # 直接运行看错误
PYTHONPATH=. python -c "import module"   # 设置路径重试
```

### 测试框架问题（pytest）
```bash
# 诊断序列
pytest --collect-only           # 只收集不运行
python test_file.py             # 直接运行看错误
pytest test_file.py::test_one  # 运行单个测试
pytest -xvs                     # 详细输出，首错即停
```

### 网络连接问题
```bash
# 诊断序列
ping host                  # 网络可达？
telnet host port          # 端口开放？
curl -I http://host:port  # HTTP响应？
netstat -an | grep port   # 服务监听？
```

### 权限问题
```bash
# 诊断序列
ls -la file               # 查看权限
whoami                    # 当前用户
sudo command              # 提权尝试
strace command 2>&1       # 系统调用追踪
```

## 📊 诊断决策树

```
命令失败
├── 输出为空？
│   ├── 是 → 检查输出重定向，添加-v参数
│   └── 否 → 分析错误信息
├── 重复失败3次？
│   ├── 是 → 切换策略
│   └── 否 → 调整参数重试
└── 错误信息明确？
    ├── 是 → 针对性修复
    └── 否 → 简化问题，最小复现
```

## 🚫 反模式（避免）

1. **随机尝试**：不理解就换参数
2. **无限重试**：同样方法试10+次
3. **忽视错误**：不读错误信息就重试
4. **跳跃思维**：不验证假设就实施
5. **过度复杂**：一次改太多东西

## ✅ 最佳实践

1. **读错误信息**：错误信息是最宝贵的线索
2. **验证假设**：每个假设都要验证
3. **记录过程**：什么有效，什么无效
4. **增量修复**：一次只改一个地方
5. **理解原理**：知其然知其所以然

## 🎓 调试智慧

> "调试的艺术不在于修复bug，而在于理解为什么会有bug。"

> "最快的调试是避免需要调试。"

> "如果你不理解为什么修好了，那就还没修好。"

记住：**每个bug都是学习系统的机会**。