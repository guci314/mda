# 声明式知识函数示例

## 对比：过程式 vs 声明式

### 1. @添加图书 - 过程式版本（现在的问题）
```markdown
### 函数：@添加图书(图书信息)
[过程式定义]

步骤：
1. 读取books.json文件
2. 解析JSON数据
3. 添加新图书到数组
4. 写回JSON文件
5. 创建Python脚本validate_book.py
6. 运行validate_book.py验证添加成功

要求：
- 必须创建Python验证脚本
- 必须运行验证脚本
- 每个步骤都要严格执行
```

**问题**：
- Agent被迫成为脚本执行器
- 扼杀了Reasoning能力
- Agent会"偷懒"跳过步骤
- 违背React = Reasoning + Action本质

### 2. @添加图书 - 声明式版本（推荐方案）
```markdown
### 函数：@添加图书(图书信息)
[声明式定义]

意图：使图书可被管理和查询

前置条件：
- 图书信息包含必要字段（标题、作者、ISBN）
- ISBN在系统中唯一

后置条件：
- 图书信息已持久化
- 可通过ISBN查询到该图书
- 可通过列表操作看到该图书
- 原有图书数据未被破坏

不变量：
- ISBN唯一性保持
- 数据格式一致性保持
- 系统中图书总数 = 原数量 + 1

质量属性：
- 操作响应时间 < 1秒
- 数据持久化成功率 = 100%
- 查询验证成功率 = 100%

验证建议（非强制）：
- 可通过读取文件验证持久化
- 可通过查询验证可访问性
- 可通过计数验证完整性
```

**优势**：
- Agent自由选择最佳实现路径
- 保留Reasoning能力
- 关注结果而非过程
- 允许创新和优化

### 3. @删除图书 - 声明式版本
```markdown
### 函数：@删除图书(ISBN)
[声明式定义]

意图：使指定图书不再被管理

前置条件：
- ISBN对应的图书存在

后置条件：
- ISBN对应的图书已移除
- 通过ISBN无法查询到该图书
- 其他图书数据未受影响

不变量：
- 其他图书的ISBN保持不变
- 数据结构完整性保持

异常处理：
- ISBN不存在时应给出明确反馈

质量属性：
- 删除操作幂等性
- 数据一致性保证
```

### 4. @查询图书 - 声明式版本
```markdown
### 函数：@查询图书(查询条件)
[声明式定义]

意图：找到满足条件的图书信息

输入约束：
- 查询条件可以是ISBN、标题、作者或其组合

输出保证：
- 返回所有满足条件的图书
- 无匹配时返回空列表或明确提示
- 结果包含完整图书信息

性能要求：
- 查询响应时间 < 100ms
- 支持模糊匹配

正确性：
- 查询结果准确无遗漏
- 不返回不匹配的图书
```

## 声明式定义规范

### 必须包含的元素
1. **意图声明（Intent）**
   - 用一句话说明函数要达到的目标
   - 关注What，不关注How

2. **后置条件（Postconditions）**
   - 函数执行后系统必须满足的条件
   - 可验证的具体状态

3. **不变量（Invariants）**
   - 函数执行过程中必须保持的性质
   - 系统一致性约束

### 可选包含的元素
1. **前置条件（Preconditions）**
   - 函数执行前必须满足的条件
   - 输入验证要求

2. **质量属性（Quality Attributes）**
   - 性能要求
   - 可靠性要求
   - 安全性要求

3. **验证建议（Validation Hints）**
   - 推荐的验证方法
   - 非强制性指导

4. **异常规约（Exception Specification）**
   - 异常情况的处理要求
   - 错误反馈规范

### 避免包含的元素
1. ❌ **具体步骤（Steps）**
   - 不要规定如何实现
   - 让Agent自己reasoning

2. ❌ **实现细节（Implementation）**
   - 不要指定具体技术
   - 不要限定具体文件格式

3. ❌ **工具限定（Tool Constraints）**
   - 不要强制使用特定工具
   - 让Agent选择最合适的工具

## 声明式的哲学基础

### React的本质
```
React = Reasoning + Action
     ≠ Action + Action
```

过程式知识函数把Agent变成了Action + Action的执行器，
声明式知识函数让Agent回归Reasoning + Action的本质。

### 类比：SQL的成功
SQL是声明式语言的典范：
```sql
-- 声明式：说明要什么
SELECT * FROM books WHERE author = 'Wang';

-- 而不是过程式：说明怎么做
for row in books:
    if row.author == 'Wang':
        result.append(row)
```

数据库优化器负责找到最佳执行路径，
就像Agent应该reasoning最佳实现方式。

### 认知科学视角
人类专家的知识是声明式的：
- 医生：「让病人康复」而非「先做A检查，再开B药」
- 厨师：「做出美味的菜」而非「先切葱，再放油」
- 程序员：「实现用户需求」而非「先写类，再写函数」

专家通过经验和推理选择最佳路径，
Agent也应该有这样的自由度。

## 实验设计

### 对比实验
1. 使用相同的Agent（如DeepSeek）
2. 执行相同的任务（图书管理）
3. 对比两种知识函数定义：
   - A组：过程式定义（现有）
   - B组：声明式定义（新）

### 评估维度
1. **遵从度**：是否达到预期结果
2. **效率**：执行轮数和时间
3. **创造性**：是否找到更优解
4. **鲁棒性**：处理异常的能力
5. **可解释性**：执行过程的合理性

### 预期结果
- 声明式定义下，Agent更容易达到目标
- 执行效率可能提高（不必执行冗余步骤）
- 可能出现创新的解决方案
- 异常处理更加灵活

## 迁移策略

### 第一阶段：试点
- 选择1-2个简单函数改为声明式
- 观察Agent行为变化
- 收集反馈和问题

### 第二阶段：扩展
- 将核心函数改为声明式
- 保留少量过程式函数作对比
- 建立最佳实践

### 第三阶段：全面迁移
- 所有知识函数采用声明式
- 形成标准化模板
- 编写迁移指南

## 风险与缓解

### 潜在风险
1. Agent可能找到"捷径"绕过要求
2. 结果的不确定性增加
3. 调试和追踪变困难

### 缓解措施
1. 强化后置条件的完整性
2. 添加更多不变量约束
3. 保留执行日志和推理过程

## 结论

声明式知识函数是解决"Agent不听话"问题的根本方案。
它不是让Agent更听话，而是改变我们下达指令的方式。
这符合React的本质，也符合智能体的天性。

正如作者所说：
> "Agent'不听话'是因为它在做Reasoning（这是好事）"

我们应该拥抱这种Reasoning能力，而不是压制它。
声明式知识函数就是实现这一目标的关键。