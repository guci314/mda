# 路由知识函数

## @route_to_expert(task)
```python
def route_to_expert(task):
    """
    强制路由规则 - 必须立即执行，不允许自由发挥
    """
    # 明确需要专家的模式（动词+对象组合）
    expert_patterns = [
        # 分析类
        ("分析", ["代码", "源代码", "实现", "逻辑", "函数", "类", "模块"]),
        ("理解", ["代码", "源代码", "实现", "逻辑", "算法"]),
        ("解释", ["代码", "源代码", "函数", "算法", "实现"]),

        # 调试类
        ("调试", None),  # 调试总是需要专家
        ("debug", None),
        ("修复", ["bug", "错误", "问题", "异常"]),
        ("为什么", ["报错", "失败", "不工作", "出错"]),

        # 优化类
        ("优化", ["性能", "代码", "算法", "内存", "速度"]),
        ("重构", None),  # 重构总是需要专家

        # 审查类
        ("审查", ["代码", "实现", "PR", "pull request"]),
        ("review", ["code", "implementation"]),
        ("检查", ["代码质量", "代码规范", "安全性"])
    ]

    # 检查是否匹配专家模式
    task_lower = task.lower()
    for verb, objects in expert_patterns:
        if verb in task_lower:
            if objects is None:  # 无条件路由
                return coder_expert.execute(task=task)
            elif any(obj in task_lower for obj in objects):  # 动词+对象匹配
                return coder_expert.execute(task=task)

    # 明确不需要专家的任务（即使包含"代码"等词）
    simple_patterns = [
        "写", "编写", "生成", "创建", "实现", "开发",  # 创建类任务
        "添加", "增加", "新建", "初始化",  # 添加类任务
        "示例", "例子", "demo", "测试"  # 示例类任务
    ]

    # 如果是简单任务，自己处理
    if any(pattern in task_lower for pattern in simple_patterns):
        return self.execute(task)

    # 特殊情况：如果明确要求"使用专家"或"调用专家"
    if any(phrase in task_lower for phrase in ["使用专家", "调用专家", "用专家", "call expert", "use expert"]):
        return coder_expert.execute(task=task)

    # 默认自己处理
    return self.execute(task)
```

## 使用方式

当接收到任务时，**第一步必须**调用 @route_to_expert：

```python
# 错误 ❌ - 给了LLM思考空间
思考: "让我先看看这个任务..."
思考: "我试试能不能自己解决..."

# 正确 ✅ - 强制执行路由函数
result = @route_to_expert(task)
```

## 为什么必须形式化？

1. **消除选择空间**：@函数是强制执行的，不是建议
2. **启动ExecutionContext**：形式化函数会创建执行上下文
3. **避免自由发挥**：LLM没有机会"试试看"
4. **确定性路由**：路由逻辑是确定的，不依赖LLM判断

## 与普通知识文件的区别

| 类型 | 执行方式 | LLM自由度 | 效果 |
|------|---------|-----------|------|
| 普通知识文件 | 建议性的 | 高（可以忽略） | 经常失败 |
| @知识函数 | 强制性的 | 无（必须执行） | 确定成功 |

## 实验证明

### 实验结果对比
| 方案 | 轮数 | 结果 | 原因 |
|------|------|------|------|
| 无路由 | 38轮 | 超时失败 | LLM自由发挥，陷入循环 |
| 普通知识文件路由 | 25轮 | 延迟路由 | LLM"思考"是否需要专家 |
| @route_to_expert | 2轮 | 成功完成 | 强制执行，无选择余地 |

### 关键发现
当DeepSeek看到 **@route_to_expert** 时：
1. 立即启动ExecutionContext
2. 执行context工具链
3. 强制路由检查
4. 无需元认知判断

## 设计原则

1. **路由优先**：任何任务都先过路由函数
2. **无条件执行**：@函数必须执行，不是建议
3. **快速失败**：如果需要专家，立即委托
4. **无需元认知**：路由逻辑是程序化的，不需要LLM判断

## 为什么这样有效？

- **形式化 = 确定性**：路由逻辑变成了程序，不是自然语言
- **@符号 = 强制执行**：明确告诉系统这是必须执行的函数
- **ExecutionContext = 无退路**：一旦进入执行上下文，必须完成
- **消除歧义**：不给LLM解释和变通的空间

## 局限性与反思

虽然形式化路由在技术上可行，但存在根本矛盾：

1. **元认知悖论**：判断任务复杂度本身就是复杂任务
2. **智力瓶颈**：弱模型即使有路由规则也可能判断错误
3. **实用性问题**：显式指定专家比自动路由更可靠

## 结论

形式化知识函数（@函数）是必要的，它证明了：
- 将自然语言规则形式化可以提高执行确定性
- ExecutionContext是形式化执行的关键基础设施
- 但路由问题的本质是智力问题，不是知识问题

**最佳实践**：
- 简单任务用DeepSeek
- 复杂任务显式调用Claude
- 不要让弱模型判断自己的能力边界