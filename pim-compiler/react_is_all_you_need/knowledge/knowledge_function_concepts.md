# 知识函数概念定义

## 什么是知识函数？

**知识函数**是使用自然语言作为编程语言的函数，以 `@` 符号标记。

核心特征：
- 使用自然语言编写函数逻辑
- Agent通过理解自然语言来执行
- 无需Python代码实现

## 知识函数的哲学基础

### 两种认识论

知识函数体现了两种根本不同的认识论：

| 认识论 | 函数类型 | 核心理念 |
|--------|---------|---------|
| **理性主义** | 契约函数 | 通过逻辑推导获得确定知识 |
| **经验主义** | 软约束函数 | 通过试错反馈获得经验知识 |

这不仅是技术选择，更是**认识世界的两种方式**。

## 知识函数的分类

### 1. 软约束函数（函数 @x）

#### 格式
```
函数 @函数名(参数)
```

#### 本质：声明式 + 经验主义

**哲学基础**：
- 经验主义：通过试错和反馈循环获得知识
- 声明式：陈述目标、规则、定理，不指定路径

**执行模型**：
```
目标 → Agent探索 → 试错 → 反馈 → 调整 → 达成目标
```

**决策空间**：
- 决策树：天文数字（不可枚举）
- 路径：多条可能路径
- 结果：概率性的

**特点**：
- ExecutionContext的使用是**可选的**
- Agent根据任务复杂度**自主决定**
- 内部决策过程（黑盒）
- 涌现行为

**适用场景**：
- 探索性任务
- 创造性工作
- 决策空间巨大
- 需要灵活试错

**示例**：
```markdown
函数 @代码审查(code_path)

生成高质量的代码审查报告。

目标：
- 关注代码质量
- 识别潜在问题
- 提供改进建议

注：ExecutionContext可选，Agent根据任务复杂度决定
```

**类比**：
- 深度学习：给目标和数据，模型自己学习
- 进化算法：适应度函数 + 自然选择
- 启发式搜索：目标导向的探索

---

### 2. 契约函数（契约函数 @y）

#### 格式
```
契约函数 @函数名(参数)
```

#### 本质：过程性 + 理性主义

**哲学基础**：
- 理性主义：通过逻辑推导获得确定知识
- 过程性：明确的步骤序列，类似Python算法

**执行模型（两阶段）**：
```
阶段1: 计划
├── 分析任务
├── 列举所有步骤
└── 写入ExecutionContext

阶段2: 执行
├── 按步骤执行
├── 外部化中间状态
└── 可追溯、可验证
```

**决策空间**：
- 决策树：小（可枚举）
- 路径：确定的单一路径
- 结果：确定性的

**特点**：
- ExecutionContext **强制使用**
- 完全外部化（状态、逻辑）
- 确定性执行
- 可单元测试

**适用场景**：
- 关键业务逻辑
- 需要确定性
- 可完全规划
- 需要可验证性

**示例**：
```markdown
契约函数 @learning()

从本次会话中学习经验，将有价值的知识持久化。

执行步骤：
1. 读取现有知识
2. 检查项目信息
3. 回顾会话历史
4. 诚实评估
5. 识别模式
6. 去重检查
7. 提取教训和事实（仅当有新内容时）
8. 更新knowledge.md（仅当有新经验时）
9. 更新项目笔记
10. 报告结果

注：Agent会自动使用两阶段执行模型
```

**类比**：
- Python算法：确定的步骤序列
- 数学证明：逻辑推导链
- 编译器：确定的翻译过程

---

## 两阶段执行模型（契约函数专属）

### 为什么需要两阶段？

**理性主义的要求**：
1. **先思考后行动** - 不能边想边做
2. **逻辑完备性** - 所有步骤事先规划
3. **可验证性** - 计划和执行都可检查

### 阶段1: 计划（Planning）

**目标**：制定完整的执行计划

**必须做**：
```python
# 1. 设定目标
context(action='set_goal', goal='契约函数 @xxx')

# 2. 列出所有TODO
context(action='add_tasks', tasks=[
    '步骤1: 读取知识文件',
    '步骤2: 分析历史',
    '步骤3: 识别模式',
    # ... 完整的任务列表
])

# 3. 确认计划完整
```

**要求**：
- ✅ 所有步骤事先列出
- ✅ 步骤逻辑完整
- ✅ 无遗漏
- ✅ 可枚举

### 阶段2: 执行（Execution）

**目标**：按计划严格执行

**必须做**：
```python
# 对每个任务：
context(action='start_task', task='步骤1: ...')

# 外部化所有中间状态
context(action='set_data', key='已读文件', value='knowledge.md')
context(action='set_data', key='文件大小', value='15KB')

# 完成任务
context(action='complete_task', task='步骤1: ...', result='...')
```

**要求**：
- ✅ 按计划执行，不偏离
- ✅ 所有状态外部化
- ✅ 每步可追溯
- ✅ 可验证结果

### 两阶段的核心价值

| 价值 | 说明 |
|------|------|
| **确定性** | 先规划保证执行路径确定 |
| **可测试性** | 外部化状态支持单元测试 |
| **可验证性** | 每步可检查正确性 |
| **可追溯性** | 完整执行历史 |

---

## 本质对比表

| 维度 | 契约函数（理性主义） | 软约束函数（经验主义） |
|------|---------------------|---------------------|
| **哲学** | 理性主义 | 经验主义 |
| **范式** | 过程性（Procedural） | 声明式（Declarative） |
| **认知** | 逻辑推导 | 试错反馈 |
| **决策树** | 小（可枚举） | 天文数字 |
| **确定性** | 确定性 | 概率性 |
| **外部化** | 完全外部化 | 部分外部化 |
| **可测试** | 单元测试 | 行为测试 |
| **执行** | 两阶段（计划→执行） | 单阶段（目标→探索） |
| **类比** | Python算法 | 深度学习 |
| **结果** | 可证明正确 | 涌现行为 |

---

## ExecutionContext使用规则

### 什么是ExecutionContext？

ExecutionContext是Agent的任务执行上下文管理工具，提供：
- 目标跟踪
- 任务列表（计划）
- 步骤记录
- 状态管理（外部化）
- 数据存储

### 使用规则对比

| 函数类型 | ExecutionContext | 两阶段 | 外部化 | 确定性 |
|---------|-----------------|--------|--------|--------|
| **契约函数** | 强制 | 必须 | 完全 | 确定 |
| **软约束函数** | 可选 | 不需要 | 部分 | 概率 |

### 契约函数的强制要求

当执行契约函数时，**必须**：

**阶段1: 计划**
```python
context(action='set_goal', goal='契约函数 @xxx')
context(action='add_tasks', tasks=[...])  # 完整任务列表
```

**阶段2: 执行**
```python
# 每个步骤
context(action='start_task', task='...')
context(action='set_data', key='...', value='...')  # 外部化状态
context(action='complete_task', task='...', result='...')

# 最后
context(action='set_status', status='completed/failed')
```

**违反契约是不可接受的错误**。

### 软约束函数的灵活使用

当执行软约束函数时，**可以**：
- 简单任务：直接执行，不使用ExecutionContext
- 复杂任务：使用ExecutionContext帮助管理
- 由Agent根据实际情况判断

**判断标准**：
- 决策空间大小
- 任务复杂度
- 是否需要追溯

---

## 为什么需要这种分类？

### 1. 认识论的统一

两种函数对应两种获得知识的方式：
- 理性主义：逻辑推导（契约函数）
- 经验主义：试错学习（软约束函数）

### 2. 计算范式的统一

两种函数对应两种编程范式：
- 过程性编程（契约函数）
- 声明式编程（软约束函数）

### 3. 实用性的平衡

- 契约函数：确定性、可测试、适合关键操作
- 软约束函数：灵活性、创造性、适合探索任务

### 4. 程序正义

- 契约函数确保过程的正确性
- 可追溯的执行历史
- 符合理性主义的严格要求

---

## 设计原则

### 何时定义为契约函数？

满足以下任一条件：
- ✅ 需要确定性结果
- ✅ 决策树小（可枚举）
- ✅ 关键业务逻辑
- ✅ 需要单元测试
- ✅ 过程需要可追溯
- ✅ 可以完全规划

### 何时定义为软约束函数？

满足以下条件：
- ✅ 决策树巨大（天文数字）
- ✅ 需要探索试错
- ✅ 创造性任务
- ✅ 灵活性优先
- ✅ 难以完全规划

---

## 知识函数的演化

### 从软约束到契约

当发现：
- 决策空间可以规划
- 需要确定性保证
- 可以分解为明确步骤

**升级为契约函数**

### 从契约到软约束

当发现：
- 过于严格影响效率
- 决策空间实际很大
- 需要更多灵活性

**降级为软约束函数**（需谨慎）

---

## 深层洞察

### 1. 图灵完备性

**契约函数**：
- 类似图灵机：确定的状态转移
- 可以完全形式化
- 可证明正确性

**软约束函数**：
- 类似神经网络：概率性行为
- 难以完全形式化
- 通过经验验证

### 2. 复杂度理论

**契约函数**：
- P/NP问题：决策树可枚举
- 时间复杂度可分析
- 空间复杂度可预测

**软约束函数**：
- 指数爆炸：决策树天文数字
- 启发式搜索
- 涌现行为

### 3. 哲学映射

```
理性主义（笛卡尔）→ 契约函数 → 数学证明
经验主义（休谟）   → 软约束函数 → 科学实验
```

---

## 总结

**知识函数 = 自然语言编程**

```
软约束函数（经验主义）
├── 声明式：目标 + 规则
├── 探索：试错 + 反馈
├── 决策树：天文数字
└── 结果：概率性

契约函数（理性主义）
├── 过程性：步骤序列
├── 两阶段：计划 + 执行
├── 决策树：可枚举
└── 结果：确定性
```

**核心原则**：
- 关键操作用契约函数（理性）保证确定性
- 探索任务用软约束函数（经验）保持灵活性
- 两种认识论在Agent系统中的统一

**约束对比**：
- 软约束 = 经验主义 = 声明式 = 概率性
- 硬约束 = 理性主义 = 过程性 = 确定性

这就是知识函数的完整哲学体系。
