# 学习与记忆知识函数

## 前置阅读

建议先阅读 `knowledge_function_concepts.md` 了解知识函数的基本概念。

## 核心理念：运行时知识积累

**设计时 vs 运行时**：
- **设计时知识**：知识文件（如本文件），定义Agent的学习能力
- **运行时知识**：`~/.agent/{agent_name}/knowledge.md`，Agent运行时积累的经验

学习函数帮助Agent将运行时经验持久化。

---

## 契约函数 @learning()

```python
'''
从本次会话中学习经验，将有价值的知识持久化。
'''
```

### 函数签名
```
契约函数 @learning()
```

### 执行步骤

1. **读取现有知识**
   - 读取 `~/.agent/{agent_name}/knowledge.md`
   - 特别关注"## 经验总结"章节，用于后续去重

2. **检查项目信息**
   - 读取README.md（如果当前目录没有，向上查找）
   - 记录项目根目录、核心代码目录、配置文件位置

3. **回顾情景记忆**（从三个来源，完整的演绎-归纳闭环）

   **步骤3.1：回顾长期情景记忆（decisions/）**⭐
   ```bash
   # 列出docs目录的所有决策文档，按修改时间排序
   ls -lt ~/.agent/{agent_name}/decisions/*.md | head -10

   # 或使用find命令
   find ~/.agent/{agent_name}/docs -name "*.md" -type f -exec ls -lt {} + | head -10
   ```
   - 按修改时间排序（最新的优先）
   - 回顾最近的重要决策
   - 读取decision_*.md的内容
   - 提取"## 经验"章节中的可归纳知识

   **步骤3.2：回顾短期情景记忆（compact.md）**
   - 读取compact.md
   - 压缩的对话历史
   - 已提取的关键点

   **步骤3.3：回顾临时情景记忆（当前会话）**
   - 当前会话的LLM上下文
   - 最近的对话
   - 刚完成的任务

   **关注内容**：
   - 达成的目标
   - 学到的模式
   - 发现的事实
   - 重要决策及其推理

4. **诚实评估**
   - 如果没有值得学习的内容，诚实报告"本次会话没有特别的经验教训"
   - 不要为了完成任务而编造教训
   - 只记录真实发生并有价值的经验

5. **识别模式**（只有确实存在时才记录）
   - 成功模式：哪些策略或方法很有效？
   - 领域知识：学到了哪些领域特定知识？
   - 重要事实：发现了哪些客观事实？

6. **去重检查**
   - 对比新经验与现有经验
   - 判定规则：
     - 如果"类型"和"场景"都相同 → 重复
     - 如果"内容"相似度 > 80% → 重复
     - 如果关键词重复 → 重复
   - 如果所有经验都是重复的，跳过步骤7-8

7. **提取教训和事实**（仅当有新内容时）
   - 格式化经验：
     - 类型：[错误处理/工具偏好/任务策略/性能优化/事实发现/代码位置/项目结构]
     - 场景：[具体场景]
     - 内容：[教训或事实，包含具体位置]
     - 位置：[完整文件路径:行号]
     - 相关：[相关文件列表]
     - 置信度：[0.6-1.0]

8. **更新knowledge.md**（仅当有新经验时）
   - 判断是否跨项目通用
   - 更新 `~/.agent/{agent_name}/knowledge.md` 的"## 经验总结"章节
   - 使用时间戳和[@learning]标记
   - 大小建议：10K-20K字（超过30K应考虑重组）
   - 知识精炼：合并相似经验、删除低置信度内容

9. **更新knowledge.md**（统一的知识存储）
   - 所有知识都写入 `~/.agent/{agent_name}/knowledge.md`
   - 包括：
     - 通用知识（跨项目的经验）
     - 项目知识（当前项目的理解）
   - **项目知识的本质**：
     - 以self.description为注意力机制
     - 对项目的个性化投影
     - 不同智能体对同一项目有不同投影
       - 架构师：关注设计决策、架构模式
       - 前端开发者：关注UI组件、交互逻辑
       - 每个智能体根据自己的description关注不同方面

10. **清空compact.md**（重置工作记忆）⭐
    - 删除 `~/.agent/{agent_name}/compact.md`
    - 原因：
      - 知识已归纳到knowledge.md（语义记忆）
      - 重要决策已在decisions/（长期情景记忆）
      - 工作记忆可以清空（类比：人类忘记琐碎细节）
    - 效果：
      - 释放空间
      - 下次从干净状态开始积累
      - 保持compact.md精简高效

11. **报告结果**
    - 如果有新经验：报告具体记录了什么，并确认compact.md已清空
    - 如果全部重复：诚实报告"本次会话的经验已在之前记录过"

### 知识统一存储原则

#### 所有知识都写入knowledge.md

**通用知识**（跨项目）：
- 工具偏好：使用某个工具的最佳实践
- 错误模式：普遍性的错误和解决方案
- 算法知识：学到的新算法或方法

**项目知识**（特定项目）：
- 项目结构：这个项目的文件组织
- 代码位置：具体函数、类的位置
- 配置信息：项目特定的API、数据库
- 设计决策：架构选择、技术选型

**项目知识的本质**（注意力投影）：
```
项目知识 ≠ 客观的项目文档
项目知识 = self.description引导的注意力对项目的主观投影

例如，同一个图书管理项目：

架构师智能体（description="设计系统架构"）：
- 关注：模块划分、微服务边界、数据流
- 学到：如何分解单体到微服务
- 投影：架构视角的项目知识

前端开发者智能体（description="开发用户界面"）：
- 关注：组件结构、用户交互、页面布局
- 学到：React组件的组织方式
- 投影：前端视角的项目知识

→ 每个智能体根据自己的description理解项目
→ 不同的注意力焦点 → 不同的知识投影
→ 都写在各自的knowledge.md中
```

**为什么不需要project_notes.md**：
- 项目知识不是独立的、客观的
- 是智能体基于自己的角色（description）的主观理解
- 应该在个体的knowledge.md中，不是共享的project_notes中

---

## 契约函数 @memory()

```python
'''
记住用户直接教育的内容。
'''
```

### 函数签名
```
契约函数 @memory()
```

### 执行步骤

1. **读取现有知识**
   - 读取 `~/.agent/{agent_name}/knowledge.md`
   - 了解已有的内容，避免重复

2. **解析用户指令**
   - 识别关键词："记住："、"记住这个："、"重要："、"注意："
   - 提取核心教育内容

3. **结构化教育内容**
   - 格式：
     ```
     ## 用户教育记录

     ### [日期时间] [@memory]
     - [具体的教育内容]
     ```

4. **更新knowledge.md**
   - 更新 `~/.agent/{agent_name}/knowledge.md` 的"## 核心能力"章节
   - 追加用户教育内容

5. **确认记录**
   - 向用户确认已记录

### 格式示例
```markdown
## 用户教育记录

### 2025-09-21 22:00 [@memory]
- 访问localhost时必须使用--noproxy参数
- 使用Gemini API需要配置httpx client with proxy
```

### 触发时机
- 用户说"记住：..."
- 用户纠正你的错误
- 用户提供重要配置信息
- 用户分享最佳实践
- 用户教授新技能

### 如何选择更新章节？
- **用户教育** → 核心能力章节（显式传授的能力）
- **自我学习** → 经验总结章节（从实践中归纳）
- **决策规则** → 决策逻辑章节（操作流程）

---

## knowledge.md 的组织管理

### 章节组织
- **## 核心能力**：用户教育和显式传授的能力
- **## 决策逻辑**：决策规则和工作流程
- **## 经验总结**：从实践中学到的经验

### 智能整合
当knowledge.md过大时，执行智能整合：

1. **合并相似教训**
   - 相同类型、相似内容的教训合并为一条
   - 保留最高置信度

2. **删除低价值条目**
   - 置信度 < 0.6 的旧条目
   - 超过30天未被引用的条目
   - 重复或冗余的内容

3. **归档历史**
   - 将旧教训移到 `agent_archive.md`
   - 只保留最近和最重要的教训

---

## 函数 @快速记忆(key_point)

```python
'''
当用户提供简短的关键信息时，可以使用这个软约束函数快速记录。
'''
```

### 函数签名
```
函数 @快速记忆(key_point)
```

### 建议流程
⚡ **ExecutionContext可选**：Agent根据内容复杂度决定是否使用

1. 评估内容复杂度
   - 简单事实（1-2句话）→ 直接记录，不使用ExecutionContext
   - 复杂内容（多条信息）→ 使用ExecutionContext管理

2. 记录到knowledge.md
   - 追加到相应章节
   - 使用简洁的格式

3. 确认记录
   - 向用户确认已记录

### 使用场景
```
用户：记住：Gemini API需要代理
助手：✅ 已记录到核心能力章节
```

---

## 设计哲学

**"知识即程序"** - 这些知识函数证明了：
- 复杂的行为可以通过知识描述实现
- Agent的智能足以理解和执行知识指令
- 代码只提供基础能力，知识定义高级行为

**契约 vs 建议**：
- 关键学习流程用契约函数保证质量（@learning、@memory）
- 简单记忆操作用软约束函数保持效率（@快速记忆）

这就是"大道至简"的体现：用最少的代码，通过知识实现最强的功能。
