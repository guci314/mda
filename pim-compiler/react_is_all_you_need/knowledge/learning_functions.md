# 学习与记忆知识函数

## 前置阅读

建议先阅读 `knowledge_function_concepts.md` 了解知识函数的基本概念。

## 核心理念：运行时知识积累

**设计时 vs 运行时**：
- **设计时知识**：知识文件（如本文件），定义Agent的学习能力
- **运行时知识**：`~/.agent/{agent_name}/knowledge.md`，Agent运行时积累的经验

学习函数帮助Agent将运行时经验持久化。

---

## 契约函数 @learning()

```python
'''
从本次会话中学习经验，将有价值的知识持久化。
'''
```

### 函数签名
```
契约函数 @learning()
```

### 执行步骤

1. **读取现有知识**
   - 读取 `~/.agent/{agent_name}/knowledge.md`
   - 特别关注"## 经验总结"章节，用于后续去重

2. **检查项目信息**
   - 读取README.md（如果当前目录没有，向上查找）
   - 记录项目根目录、核心代码目录、配置文件位置

3. **回顾会话历史**
   - 从compact.md和当前会话提取知识点
   - 关注：达成的目标、学到的模式、发现的事实
   - 记录探索的文件路径和行号

4. **诚实评估**
   - 如果没有值得学习的内容，诚实报告"本次会话没有特别的经验教训"
   - 不要为了完成任务而编造教训
   - 只记录真实发生并有价值的经验

5. **识别模式**（只有确实存在时才记录）
   - 成功模式：哪些策略或方法很有效？
   - 领域知识：学到了哪些领域特定知识？
   - 重要事实：发现了哪些客观事实？

6. **去重检查**
   - 对比新经验与现有经验
   - 判定规则：
     - 如果"类型"和"场景"都相同 → 重复
     - 如果"内容"相似度 > 80% → 重复
     - 如果关键词重复 → 重复
   - 如果所有经验都是重复的，跳过步骤7-8

7. **提取教训和事实**（仅当有新内容时）
   - 格式化经验：
     - 类型：[错误处理/工具偏好/任务策略/性能优化/事实发现/代码位置/项目结构]
     - 场景：[具体场景]
     - 内容：[教训或事实，包含具体位置]
     - 位置：[完整文件路径:行号]
     - 相关：[相关文件列表]
     - 置信度：[0.6-1.0]

8. **更新knowledge.md**（仅当有新经验时）
   - 判断是否跨项目通用
   - 更新 `~/.agent/{agent_name}/knowledge.md` 的"## 经验总结"章节
   - 使用时间戳和[@learning]标记
   - 大小建议：10K-20K字（超过30K应考虑重组）
   - 知识精炼：合并相似经验、删除低置信度内容

9. **更新项目笔记**
   - 主笔记：`{work_dir}/.notes/project_notes.md`
   - 记录项目特定的知识
   - 保持简洁：主笔记控制在2-3K字

10. **清空compact.md**（重置工作记忆）⭐
    - 删除 `~/.agent/{agent_name}/compact.md`
    - 原因：
      - 知识已归纳到knowledge.md（语义记忆）
      - 重要决策已在docs/（长期情景记忆）
      - 工作记忆可以清空（类比：人类忘记琐碎细节）
    - 效果：
      - 释放空间
      - 下次从干净状态开始积累
      - 保持compact.md精简高效

11. **报告结果**
    - 如果有新经验：报告具体记录了什么，并确认compact.md已清空
    - 如果全部重复：诚实报告"本次会话的经验已在之前记录过"

### 知识分层策略

#### 什么写入knowledge.md？
- **跨项目通用**：在任何项目都可能用到的经验
- **工具偏好**：使用某个工具的最佳实践
- **错误模式**：普遍性的错误和解决方案
- **算法知识**：学到的新算法或方法

#### 什么写入project_notes.md？
- **项目结构**：这个特定项目的文件组织
- **代码位置**：具体函数、类的位置和行号
- **配置信息**：项目特定的API、数据库等
- **本地约定**：这个项目的编码风格和规范
- **已解决bug**：项目中遇到的具体问题

---

## 契约函数 @memory()

```python
'''
记住用户直接教育的内容。
'''
```

### 函数签名
```
契约函数 @memory()
```

### 执行步骤

1. **读取现有知识**
   - 读取 `~/.agent/{agent_name}/knowledge.md`
   - 了解已有的内容，避免重复

2. **解析用户指令**
   - 识别关键词："记住："、"记住这个："、"重要："、"注意："
   - 提取核心教育内容

3. **结构化教育内容**
   - 格式：
     ```
     ## 用户教育记录

     ### [日期时间] [@memory]
     - [具体的教育内容]
     ```

4. **更新knowledge.md**
   - 更新 `~/.agent/{agent_name}/knowledge.md` 的"## 核心能力"章节
   - 追加用户教育内容

5. **确认记录**
   - 向用户确认已记录

### 格式示例
```markdown
## 用户教育记录

### 2025-09-21 22:00 [@memory]
- 访问localhost时必须使用--noproxy参数
- 使用Gemini API需要配置httpx client with proxy
```

### 触发时机
- 用户说"记住：..."
- 用户纠正你的错误
- 用户提供重要配置信息
- 用户分享最佳实践
- 用户教授新技能

### 如何选择更新章节？
- **用户教育** → 核心能力章节（显式传授的能力）
- **自我学习** → 经验总结章节（从实践中归纳）
- **决策规则** → 决策逻辑章节（操作流程）

---

## knowledge.md 的组织管理

### 章节组织
- **## 核心能力**：用户教育和显式传授的能力
- **## 决策逻辑**：决策规则和工作流程
- **## 经验总结**：从实践中学到的经验

### 智能整合
当knowledge.md过大时，执行智能整合：

1. **合并相似教训**
   - 相同类型、相似内容的教训合并为一条
   - 保留最高置信度

2. **删除低价值条目**
   - 置信度 < 0.6 的旧条目
   - 超过30天未被引用的条目
   - 重复或冗余的内容

3. **归档历史**
   - 将旧教训移到 `agent_archive.md`
   - 只保留最近和最重要的教训

---

## 函数 @快速记忆(key_point)

```python
'''
当用户提供简短的关键信息时，可以使用这个软约束函数快速记录。
'''
```

### 函数签名
```
函数 @快速记忆(key_point)
```

### 建议流程
⚡ **ExecutionContext可选**：Agent根据内容复杂度决定是否使用

1. 评估内容复杂度
   - 简单事实（1-2句话）→ 直接记录，不使用ExecutionContext
   - 复杂内容（多条信息）→ 使用ExecutionContext管理

2. 记录到knowledge.md
   - 追加到相应章节
   - 使用简洁的格式

3. 确认记录
   - 向用户确认已记录

### 使用场景
```
用户：记住：Gemini API需要代理
助手：✅ 已记录到核心能力章节
```

---

## 设计哲学

**"知识即程序"** - 这些知识函数证明了：
- 复杂的行为可以通过知识描述实现
- Agent的智能足以理解和执行知识指令
- 代码只提供基础能力，知识定义高级行为

**契约 vs 建议**：
- 关键学习流程用契约函数保证质量（@learning、@memory）
- 简单记忆操作用软约束函数保持效率（@快速记忆）

这就是"大道至简"的体现：用最少的代码，通过知识实现最强的功能。
