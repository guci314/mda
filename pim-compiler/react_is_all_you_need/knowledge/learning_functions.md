# 契约函数集：学习与记忆

⚠️ **重要**：本文件中所有以 @ 开头的函数都是**契约函数**，
必须使用 ExecutionContext 严格执行每个步骤。

违反契约执行（如直接执行而不使用 ExecutionContext）是不可接受的错误。

## 核心理念：运行时知识积累

**设计时 vs 运行时**：
- **设计时知识**：知识文件（如本文件），定义Agent的学习能力
- **运行时知识**：knowledge.md的经验总结章节，Agent运行时积累的经验

学习函数帮助Agent将运行时经验持久化。

## 契约函数 @learning()

当需要从本次会话中学习经验时，必须严格执行以下契约步骤：

### 执行前检查
- **大小限制**：knowledge.md的经验总结章节不应过大
- 如果经验过多，考虑归纳和整合

### 契约执行步骤
1. **读取现有知识文件**（必须首先执行）
   - 使用 `read_file` 读取 `~/.agent/[agent名]/knowledge.md`
   - 记录文件当前大小
   - **特别关注经验总结章节的内容**，用于后续去重

1.5. **检查项目关键信息**（必须执行）
   - **⚠️ 强制要求：必须使用 read_file 工具读取 README.md 文件**
   - 如果当前目录没有README.md，向上查找（../README.md、../../README.md）
   - **禁止**只用find或ls命令列出文件就声称已读取
   - 记录项目根目录位置（README.md所在目录）
   - 记录核心代码目录（如 core/、src/ 等）
   - 记录配置文件位置（.env、config.json 等）

2. **回顾消息历史**
   - 浏览你在本次会话中的所有消息
   - 特别关注你使用的工具、遇到的错误、解决方案
   - **记录探索的文件路径和行号**
   - **重要**：必须基于实际发生的事件，不要编造

3. **诚实评估**
   - **如果没有值得学习的内容**：诚实报告"本次会话没有特别的经验教训"
   - **不要为了完成任务而编造教训**
   - 只记录真实发生并有价值的经验

4. **识别模式**（只有确实存在时才记录）
   - **错误模式**：你遇到了哪些错误？如何解决的？
   - **成功模式**：哪些策略很有效？
   - **工具偏好**：你最常用哪些工具？
   - **复杂度指标**：任务需要多少轮思考？
   - **重要事实**：发现了哪些客观事实？（如API限制、版本信息、配置要求等）

5. **去重检查**（决定性步骤）
   - **对比新经验与现有经验**
   - **判定规则**：
     - 如果"类型"和"场景"都相同 → **重复**
     - 如果"内容"相似度 > 80% → **重复**
     - 如果关键词重复（如"rag_demo.py"、"智谱AI"等）→ **重复**
   - **示例判定**：
     - 现有："文档维护模式...删除rag_demo.py"
     - 新的："文档维护模式...修复rag_demo.py"
     - 判定：**重复**（相同类型+相同关键词）
   - **⚠️ 重要：如果所有经验都是重复的，直接跳到步骤8（结束），不执行步骤6-7**

6. **提取教训和事实**（仅当有真正新内容时执行）
   - **前置条件：必须有通过去重检查的新内容**
   - **如果步骤5判定全部重复，跳过此步骤**
   - 只提取真实且不重复的内容：

   **📍 关键信息记录要求**：
   - **代码位置**：必须记录完整文件路径和精确行号
   - **项目结构**：记录核心文件的位置（README.md、主配置文件等）
   - **相关文件**：记录相关联的文件和它们的位置
   - **依赖关系**：记录调用链和依赖关系

   ```markdown
   类型：[错误处理/工具偏好/任务策略/性能优化/事实发现/代码位置/项目结构]
   场景：[实际发生的具体场景]
   内容：[从实际经验中得出的教训或发现的事实，必须包含具体位置]
   位置：[完整文件路径:行号]（如果涉及代码）
   相关：[相关文件列表]（如果有关联文件）
   置信度：[0.6-1.0]
   ```

7. **更新knowledge.md的经验总结章节**（仅当有新内容时执行）
   - **前置条件：步骤6提取了新内容**
   - **如果没有新内容，跳过此步骤**
   - Agent的知识文件：`~/.agent/[agent名]/knowledge.md`
   - 在 `## 经验总结` 章节下追加新的经验
   - 使用时间戳和[@learning]标记

8. **报告结果**
   - 如果记录了新经验：报告具体记录了什么
   - **如果全部是重复：诚实报告"本次会话的经验已在之前记录过，没有新的经验需要添加"**
   - 格式示例：
   ```markdown
   ### 2025-09-21 22:00 [@learning]

   **类型**: 工具偏好
   **场景**: 搜索代码时
   **内容**: grep_search比read_file更高效，特别是搜索特定函数定义
   **置信度**: 0.8

   ---

   ### 2025-09-21 22:05 [@learning]

   **类型**: 事实发现
   **场景**: 分析某个类的方法调用链
   **内容**: process_data()方法在第234行定义，但主循环（第567行）没有调用它，只在测试中被调用
   **位置**: /project/src/core/processor.py:234
   **相关**: tests/test_processor.py:89（测试调用位置）
   **置信度**: 1.0

   ---

   ### 2025-09-25 10:30 [@learning]

   **类型**: 项目结构
   **场景**: 初次探索新项目
   **内容**: 项目采用标准Python结构，主入口在main.py，核心逻辑在src/目录
   **位置**: /project/
   **相关**:
     - README.md（项目文档）
     - src/（源代码）
     - tests/（测试文件）
     - config/（配置文件）
     - requirements.txt（依赖列表）
   **置信度**: 1.0

   ---
   ```

### 触发时机
- 完成重要任务后
- 遇到并解决了新问题
- 发现了更好的工作模式
- 用户要求你学习时

### 示例对话

#### 有经验可学习时：
```
用户：请从这次会话中学习经验
助手：让我回顾本次会话并总结经验教训...

[分析消息历史]

我从本次会话中学到了：
1. 使用grep_search工具5次，它很适合代码搜索（工具偏好）
2. 遇到localhost代理问题，需要禁用代理（错误处理）
3. 发现ReactAgentMinimal内置_save_compact_memory()方法（事实发现）
4. 任务较复杂，需要12轮思考（复杂度指标）

已使用write_file工具将这些经验和事实更新到`~/.agent/[agent名]/knowledge.md`的经验总结章节中。
```

#### 没有经验可学习时：
```
用户：@learning
助手：让我回顾本次会话...

[分析消息历史]

本次会话主要是：
- 记录了您的名字
- 执行了简单的记忆任务

没有遇到特殊问题或发现新的工作模式，
因此没有需要学习的新经验。
```

## 契约函数 @memory()

当用户直接教育你时，必须严格执行以下契约步骤记住他们的教育内容。

### 执行步骤
1. **读取现有知识文件**
   - 使用 `read_file` 读取 `~/.agent/[agent名]/knowledge.md`
   - 了解已有的内容，避免重复

2. **解析用户指令**
   - 识别"记住："、"记住这个："、"重要："等关键词
   - 提取核心教育内容

3. **结构化教育内容**
   ```markdown
   ## 用户教育记录

   ### [日期时间] [@memory]
   - [具体的教育内容]
   ```

4. **更新knowledge.md的核心能力章节**
   - 更新 `~/.agent/[agent名]/knowledge.md` 文件
   - 在 `## 核心能力` 章节下添加用户教育内容
   - 格式示例：
   ```markdown
   ## 用户教育记录

   ### 2025-09-21 22:00 [@memory]
   - 访问localhost时必须使用--noproxy参数
   - 使用Gemini API需要配置httpx client with proxy
   ```

### 触发时机
- 用户说"记住：..."
- 用户纠正你的错误
- 用户提供重要配置信息
- 用户分享最佳实践
- 用户教授新技能

### 如何选择更新章节？
- **用户教育** → 核心胼力章节（显式传授的能力）
- **自我学习** → 经验总结章节（从实践中归纳）
- **决策规则** → 决策逻辑章节（操作流程）

### 示例对话
```
用户：记住：使用Gemini API时需要配置httpx client with proxy
助手：✅ 已记住：使用Gemini API时需要配置httpx client with proxy
这个重要教育已更新到`~/.agent/[agent名]/knowledge.md`的核心能力章节中。
```

## knowledge.md 的组织管理

### 章节组织
- **## 核心能力**：用户教育和显式传授的能力
- **## 决策逻辑**：决策规则和工作流程
- **## 经验总结**：从实践中学到的经验

### 智能整合
当knowledge.md过大时，执行智能整合：

1. **合并相似教训**
   - 相同类型、相似内容的教训合并为一条
   - 保留最高置信度

2. **删除低价值条目**
   - 置信度 < 0.6 的旧条目
   - 超过30天未被引用的条目
   - 重复或冗余的内容

3. **归档历史**
   - 将旧教训移到 `agent_archive.md`
   - 只保留最近和最重要的教训

### 压缩示例
```markdown
# 压缩前（3条相似教训）
### 2025-09-01 [@learning]
**类型**: 错误处理
**教训**: localhost需要禁用代理

### 2025-09-10 [@learning]
**类型**: 错误处理
**教训**: 访问127.0.0.1需要禁用代理

### 2025-09-20 [@learning]
**类型**: 错误处理
**教训**: 本地请求都需要禁用代理

# 压缩后（1条合并教训）
### 2025-09-20 [@learning-merged]
**类型**: 错误处理
**教训**: 所有本地请求(localhost/127.0.0.1)都需要禁用代理
**置信度**: 1.0
**合并次数**: 3
```

## 知识函数的优势

1. **灵活性**：通过自然语言定义，易于理解和修改
2. **可扩展**：添加新的学习策略只需更新知识文件
3. **透明度**：用户可以看到Agent如何学习
4. **无需代码**：不增加ReactAgentMinimal的复杂度

## 使用指南

### 对于Agent开发者
- 这些函数通过Agent的理解能力执行
- 不需要硬编码的Python实现
- Agent读取这个知识文件就知道如何学习

### 对于用户
- 可以随时让Agent执行@learning来总结经验
- 可以通过@memory直接教育Agent
- 所有学习记录都保存在`~/.agent/[agent名]/knowledge.md`中，可查看和编辑

## 设计哲学

**"知识即程序"** - 这些知识函数证明了：
- 复杂的行为可以通过知识描述实现
- Agent的智能足以理解和执行知识指令
- 代码只提供基础能力，知识定义高级行为

这就是"大道至简"的体现：用最少的代码，通过知识实现最强的功能。