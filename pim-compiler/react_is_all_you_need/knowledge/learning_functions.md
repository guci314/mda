# 契约函数集：学习与记忆

⚠️ **重要**：本文件中所有以 @ 开头的函数都是**契约函数**，
必须使用 ExecutionContext 严格执行每个步骤。

违反契约执行（如直接执行而不使用 ExecutionContext）是不可接受的错误。

## 核心理念：运行时知识积累

**设计时 vs 运行时**：
- **设计时知识**：知识文件（如本文件），定义Agent的学习能力
- **运行时知识**：knowledge.md的经验总结章节，Agent运行时积累的经验

学习函数帮助Agent将运行时经验持久化。

## 契约函数 @learning()

当需要从本次会话中学习经验时，必须严格执行以下契约步骤：

### 执行前检查
- **大小限制**：knowledge.md的经验总结章节不应过大
- 如果经验过多，考虑归纳和整合

### 契约执行步骤
1. **读取现有知识文件**（必须首先执行）
   - 使用 `read_file` 读取 `~/.agent/[agent名]/knowledge.md`
   - 记录文件当前大小
   - **特别关注经验总结章节的内容**，用于后续去重

1.5. **检查项目关键信息**（必须执行）
   - **⚠️ 强制要求：必须使用 read_file 工具读取 README.md 文件**
   - 如果当前目录没有README.md，向上查找（../README.md、../../README.md）
   - **禁止**只用find或ls命令列出文件就声称已读取
   - 记录项目根目录位置（README.md所在目录）
   - 记录核心代码目录（如 core/、src/ 等）
   - 记录配置文件位置（.env、config.json 等）

2. **回顾消息历史**
   - 从compact.md和当前会话提取知识点
   - 关注：达成的目标、学到的模式、发现的事实
   - **记录探索的文件路径和行号**
   - **重要**：专注于知识而非执行细节

3. **诚实评估**
   - **如果没有值得学习的内容**：诚实报告"本次会话没有特别的经验教训"
   - **不要为了完成任务而编造教训**
   - 只记录真实发生并有价值的经验

4. **识别模式**（只有确实存在时才记录）
   - **成功模式**：哪些策略或方法很有效？
   - **领域知识**：学到了哪些领域特定知识？
   - **重要事实**：发现了哪些客观事实？（如API限制、版本信息、配置要求等）
   - **注意**：不记录执行细节（如工具调用、错误处理），只记录知识

5. **去重检查**（决定性步骤）
   - **对比新经验与现有经验**
   - **判定规则**：
     - 如果"类型"和"场景"都相同 → **重复**
     - 如果"内容"相似度 > 80% → **重复**
     - 如果关键词重复（如"rag_demo.py"、"智谱AI"等）→ **重复**
   - **示例判定**：
     - 现有："文档维护模式...删除rag_demo.py"
     - 新的："文档维护模式...修复rag_demo.py"
     - 判定：**重复**（相同类型+相同关键词）
   - **⚠️ 重要：如果所有经验都是重复的，直接跳到步骤8（结束），不执行步骤6-7**

6. **提取教训和事实**（仅当有真正新内容时执行）
   - **前置条件：必须有通过去重检查的新内容**
   - **如果步骤5判定全部重复，跳过此步骤**
   - 只提取真实且不重复的内容：

   **📍 关键信息记录要求**：
   - **代码位置**：必须记录完整文件路径和精确行号
   - **项目结构**：记录核心文件的位置（README.md、主配置文件等）
   - **相关文件**：记录相关联的文件和它们的位置
   - **依赖关系**：记录调用链和依赖关系

   ```markdown
   类型：[错误处理/工具偏好/任务策略/性能优化/事实发现/代码位置/项目结构]
   场景：[实际发生的具体场景]
   内容：[从实际经验中得出的教训或发现的事实，必须包含具体位置]
   位置：[完整文件路径:行号]（如果涉及代码）
   相关：[相关文件列表]（如果有关联文件）
   置信度：[0.6-1.0]
   ```

7. **更新knowledge.md**（保持精炼）
   - **大小建议**：10K-20K字（超过30K应考虑重组）
   - **更新经验总结章节**（仅当有通用经验时执行）
     - **前置条件：有跨项目通用的经验**
     - Agent的知识文件：`~/.agent/[agent名]/knowledge.md`
     - 在 `## 经验总结` 章节下追加新的经验
     - 使用时间戳和[@learning]标记
     - **判断标准**：这个经验在其他项目也有用吗？
   - **知识精炼原则**：
     - 合并相似经验
     - 删除低置信度内容（< 0.6）
     - 保持知识的高密度和实用性

8. **更新项目笔记**（简洁实用）
   - **主笔记**：`{work_dir}/.notes/project_notes.md`（项目笔记）
   - **详细内容**：如果某个主题超过500字，创建独立文件`{work_dir}/.notes/[主题].md`

   **project_notes.md格式**：
   ```markdown
   # 项目笔记 - [项目名]

   项目：{work_dir}
   创建：[日期]

   ## 核心信息
   - 技术栈：[列表]
   - 主要服务：[列表]
   - README：{work_dir}/README.md

   ## 问题解决记录
   ### [日期] [问题简述]
   - 问题：[描述]
   - 解决：[方案]
   - 文件：[相关文件路径]

   ## 配置要点
   - [配置1]
   - [配置2]
   ```

   **保持简洁**：
   - 主笔记控制在2-3K字
   - 详细内容独立文件
   - 文件名描述主题

9. **报告结果**
   - 如果记录了新经验：报告具体记录了什么
   - **如果全部是重复：诚实报告"本次会话的经验已在之前记录过，没有新的经验需要添加"**
   - 格式示例：
   ```markdown
   ### 2025-09-21 22:00 [@learning]

   **类型**: 工具偏好
   **场景**: 搜索代码时
   **内容**: grep_search比read_file更高效，特别是搜索特定函数定义
   **置信度**: 0.8

   ---

   ### 2025-09-21 22:05 [@learning]

   **类型**: 事实发现
   **场景**: 分析某个类的方法调用链
   **内容**: process_data()方法在第234行定义，但主循环（第567行）没有调用它，只在测试中被调用
   **位置**: /project/src/core/processor.py:234
   **相关**: tests/test_processor.py:89（测试调用位置）
   **置信度**: 1.0

   ---

   ### 2025-09-25 10:30 [@learning]

   **类型**: 项目结构
   **场景**: 初次探索新项目
   **内容**: 项目采用标准Python结构，主入口在main.py，核心逻辑在src/目录
   **位置**: /project/
   **相关**:
     - README.md（项目文档）
     - src/（源代码）
     - tests/（测试文件）
     - config/（配置文件）
     - requirements.txt（依赖列表）
   **置信度**: 1.0

   ---
   ```

### 知识分层策略

#### 什么写入knowledge.md？
- **跨项目通用**：在任何项目都可能用到的经验
- **工具偏好**：使用某个工具的最佳实践
- **错误模式**：普遍性的错误和解决方案
- **算法知识**：学到的新算法或方法

#### 什么写入project_notes.md？
- **项目结构**：这个特定项目的文件组织
- **代码位置**：具体函数、类的位置和行号
- **配置信息**：项目特定的API、数据库等
- **本地约定**：这个项目的编码风格和规范
- **已解决bug**：项目中遇到的具体问题

### 示例对话

#### 有经验可学习时：
```
用户：@learning
助手：让我回顾本次会话并总结经验教训...

[分析compact.md和当前会话]

我从本次会话中学到了：
1. Docker网络配置必须一致才能服务间通信（领域知识）
2. 使用docker compose而非docker run确保网络一致性（最佳实践）
3. Spring Cloud微服务调试的系统化流程（成功模式）

已更新：
- 通用经验 → `~/.agent/[agent名]/knowledge.md`
- 项目笔记 → `.notes/project_notes.md`（添加问题解决记录）
- 详细内容 → `.notes/DockerNetworking.md`（超过500字独立）
```

#### 没有经验可学习时：
```
用户：@learning
助手：让我回顾本次会话...

[分析消息历史]

本次会话主要是：
- 记录了您的名字
- 执行了简单的记忆任务

没有遇到特殊问题或发现新的工作模式，
因此没有需要学习的新经验。
```

## 契约函数 @memory()

当用户直接教育你时，必须严格执行以下契约步骤记住他们的教育内容。

### 执行步骤
1. **读取现有知识文件**
   - 使用 `read_file` 读取 `~/.agent/[agent名]/knowledge.md`
   - 了解已有的内容，避免重复

2. **解析用户指令**
   - 识别"记住："、"记住这个："、"重要："等关键词
   - 提取核心教育内容

3. **结构化教育内容**
   ```markdown
   ## 用户教育记录

   ### [日期时间] [@memory]
   - [具体的教育内容]
   ```

4. **更新knowledge.md的核心能力章节**
   - 更新 `~/.agent/[agent名]/knowledge.md` 文件
   - 在 `## 核心能力` 章节下添加用户教育内容
   - 格式示例：
   ```markdown
   ## 用户教育记录

   ### 2025-09-21 22:00 [@memory]
   - 访问localhost时必须使用--noproxy参数
   - 使用Gemini API需要配置httpx client with proxy
   ```

### 触发时机
- 用户说"记住：..."
- 用户纠正你的错误
- 用户提供重要配置信息
- 用户分享最佳实践
- 用户教授新技能

### 如何选择更新章节？
- **用户教育** → 核心胼力章节（显式传授的能力）
- **自我学习** → 经验总结章节（从实践中归纳）
- **决策规则** → 决策逻辑章节（操作流程）

### 示例对话
```
用户：记住：使用Gemini API时需要配置httpx client with proxy
助手：✅ 已记住：使用Gemini API时需要配置httpx client with proxy
这个重要教育已更新到`~/.agent/[agent名]/knowledge.md`的核心能力章节中。
```

## knowledge.md 的组织管理

### 章节组织
- **## 核心能力**：用户教育和显式传授的能力
- **## 决策逻辑**：决策规则和工作流程
- **## 经验总结**：从实践中学到的经验

### 智能整合
当knowledge.md过大时，执行智能整合：

1. **合并相似教训**
   - 相同类型、相似内容的教训合并为一条
   - 保留最高置信度

2. **删除低价值条目**
   - 置信度 < 0.6 的旧条目
   - 超过30天未被引用的条目
   - 重复或冗余的内容

3. **归档历史**
   - 将旧教训移到 `agent_archive.md`
   - 只保留最近和最重要的教训

### 压缩示例
```markdown
# 压缩前（3条相似教训）
### 2025-09-01 [@learning]
**类型**: 错误处理
**教训**: localhost需要禁用代理

### 2025-09-10 [@learning]
**类型**: 错误处理
**教训**: 访问127.0.0.1需要禁用代理

### 2025-09-20 [@learning]
**类型**: 错误处理
**教训**: 本地请求都需要禁用代理

# 压缩后（1条合并教训）
### 2025-09-20 [@learning-merged]
**类型**: 错误处理
**教训**: 所有本地请求(localhost/127.0.0.1)都需要禁用代理
**置信度**: 1.0
**合并次数**: 3
```

## 知识函数的优势

1. **灵活性**：通过自然语言定义，易于理解和修改
2. **可扩展**：添加新的学习策略只需更新知识文件
3. **透明度**：用户可以看到Agent如何学习
4. **无需代码**：不增加ReactAgentMinimal的复杂度

## 使用指南

### 对于Agent开发者
- 这些函数通过Agent的理解能力执行
- 不需要硬编码的Python实现
- Agent读取这个知识文件就知道如何学习

### 对于用户
- 可以随时让Agent执行@learning来总结经验
- 可以通过@memory直接教育Agent
- 所有学习记录都保存在`~/.agent/[agent名]/knowledge.md`中，可查看和编辑

## 设计哲学

**"知识即程序"** - 这些知识函数证明了：
- 复杂的行为可以通过知识描述实现
- Agent的智能足以理解和执行知识指令
- 代码只提供基础能力，知识定义高级行为

这就是"大道至简"的体现：用最少的代码，通过知识实现最强的功能。# 向专家学习知识函数

## 契约函数 @learning_from_expert(expert_model)

当你遇到困难或陷入重复模式时，向更强的模型请教。

### 参数
- `expert_model`: 专家模型（可选，默认claude）
  - `claude` - anthropic/claude-sonnet-4.5（最强，唯一真正的专家）⚠️
  - 其他模型智力与DeepSeek相当，不适合做导师

### 适用场景（基于结果，不是轮数）

⚠️ 满足以下任一条件，必须立即执行@learning_from_expert：

1. **任务结果触发**：
   - 任务未完成（测试还有失败、编译失败等）
   - 已通过契约函数的"元认知检查"任务验证

2. **互联网搜索触发**：
   - 如果你想用search工具搜索互联网 → 停下来
   - ❌ 不要搜索互联网
   - ✅ 改为请教claude_agent
   - 互联网上的泛泛而谈 << claude_agent的针对性指导

3. **任务明确要求**：
   - 如果任务说"遇到困难执行@learning_from_expert"
   - 通过元认知检查发现任务未完成
   - 立即执行

---

## 契约执行步骤

### 1. 自我反思
```
回顾当前状态：
- 任务是否完成？（基于客观结果）
- 我在重复什么操作？
- 为什么还没解决问题？
- 我可能遗漏了什么？
```

### 2. 准备上下文
```
收集关键信息：
- output.log最后200行（完整上下文）
- 当前执行的任务目标
- 已尝试的方法和结果
- 遇到的困难和疑惑
```

### 3. 请求Claude大师分析（直接调用）
```
⚠️ claude_agent已由用户创建，直接调用即可

调用工具：claude_agent
方法：execute
参数：
  task: "
    我在{任务类型}遇到困难。

    任务：{当前任务}
    当前状态：任务未完成（基于客观验证）
    问题：{当前遇到的具体问题}
    已尝试：{已尝试的方法}

    请分析：
    1. 我的思路哪里错了？
    2. 正确的方法是什么？
    3. 需要避免什么陷阱？
  "
```

### 4. 理解Claude的指导
```
读取专家的回复，关注：
- 根本原因是什么？（不是表象）
- 建议的策略是什么？（不是具体代码）
- 思维方式哪里出错了？（元认知层面）
```

### 5. 内化为knowledge.md（强制执行）
```
⚠️ 必须执行！不内化=浪费了Claude的指导

步骤1：提取通用原则（不是具体解法）
  从Claude的回复中提取：
  ✅ 思维方式："先读测试理解意图，再修改实现"
  ✅ 决策原则："API不匹配要同时检查Controller和测试"
  ❌ 不要记录："把这行代码改成XX"

步骤2：格式化为知识条目
  ### 2025-10-08 [@learning_from_expert:claude]
  **场景**: 修复Spring Boot单元测试
  **Claude指导的核心洞察**:
  - API接口不匹配是Controller测试失败的常见原因
  - 先检查测试期望的API签名，再看实现
  - Mockito UnnecessaryStubbing说明测试分支没走到
  **内化原则**:
  - 测试失败先看API签名是否匹配
  - 读测试代码理解mock期望
  - 一个一个修，立即验证
  **置信度**: 1.0（Claude指导）

步骤3：写入knowledge.md
  ⚠️ 必须调用工具！

  调用工具：append_file
  参数：
    file_path: ~/.agent/book_agent/knowledge.md
    content: [上面格式化的知识条目]

步骤4：验证已写入
  调用工具：read_file
  参数：
    file_path: ~/.agent/book_agent/knowledge.md
    offset: -20  # 读最后20行验证

  确认新条目已添加
```

### 6. 应用新知识
```
根据专家的指导：
- 调整当前策略
- 使用新的方法
- 避免已识别的陷阱

不是复制专家的具体建议，
而是理解背后的原则并灵活应用
```

### 7. 报告结果（需要证据）
```
⚠️ 必须提供知识更新的证据

格式：
✅ 已向Claude专家请教
📚 核心学习：[从Claude学到的核心洞察]
📝 知识更新：已写入~/.agent/book_agent/knowledge.md
   具体内容：[显示新增的知识条目]
🔄 策略调整：[具体会如何改变做法]

验证：
读取knowledge.md最后20行，展示新增内容
```

---

## 师徒关系原则

### 专家是导师，不是代理人
- ❌ 不要让专家直接解决问题
- ✅ 让专家指导你如何思考
- ❌ 不要复制专家的代码
- ✅ 理解专家的思路并内化

### 何时请教Claude

通过契约函数的"元认知检查"任务判断：
- ✅ 任务未完成（基于客观验证结果）
- ✅ 想搜索互联网时（改为请教专家）
- ✅ 任务明确要求时

### 知识传承
- Claude的每次指导都要内化为永久知识
- 下次遇到类似问题，先查自己的knowledge.md
- 逐步减少对Claude的依赖（通过学习成长）

---

## 实际示例

### 场景：修复测试陷入困境

**你的状态**：
- 一直在修改验证逻辑
- 测试还是15个失败
- 元认知检查发现任务未完成

**执行@learning_from_expert**：

省略（已在前面详细说明）

---

## 现实约束

### 模型能力对比
- **Claude**: 最强，真正的专家
- **DeepSeek/Qwen/Grok-Code-Fast**: 智力相当，都不够聪明

### 地缘政治限制
- Claude不向中国用户提供服务
- 中国政府限制企业使用Claude
- **唯一可行方案**：通过OpenRouter间接访问（有政策风险）

### 务实选择
虽然有限制，但：
- 弱模型独自解决困难任务成本更高
- 向同级模型请教没有意义
- Claude是唯一能真正指导的专家

**结论**：接受风险，使用OpenRouter访问Claude
- 只在真正卡住时用（任务未完成且不知道怎么修）
- 一次学透，减少调用次数
- 内化知识，降低依赖

---

## 成本与效率

### 现实计算（示例）
```
弱模型独自解决困难任务：
- 成本：可能很高（反复尝试）
- 时间：可能很长
- 结果：可能失败

强模型指导后解决：
- 成本：更低（少量指导+快速解决）
- 时间：更短
- 结果：成功率更高
```

### 结论
- Claude更便宜且更快（总成本）
- LLM成本远小于程序员工资
- **但是**：Claude有地缘政治限制

### 务实策略
- DeepSeek/Grok执行日常任务（便宜大量使用）
- 任务未完成时（通过元认知检查判断）请教Claude
- 承担政策风险换取效率
- 一次学透，内化知识，减少依赖

---

## 终极目标

通过多次向专家学习，Agent积累足够知识，
最终能独立解决大部分问题，只在真正复杂的场景才请教专家。

**从依赖专家 → 成为专家**

这就是Agent的成长路径。
