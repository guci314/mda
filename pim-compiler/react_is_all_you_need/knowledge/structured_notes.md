# 双维度记忆理论笔记系统

## 笔记策略

**强制要求**：无论任务多么简单，都必须创建笔记！

### 必须创建的笔记（无例外）
1. **world_state.md**（强制）：世界状态快照
   - ⚠️ **任务开始时必须读取和创建** - 记录当前世界状态
   - ⚠️ **任务完成时必须更新** - 记录完成后的世界状态
   - 每次都是完整的状态快照，不是增量记录
   - 任务执行中不更新（保持事务隔离性）

2. **task_process.md**（强制）：当前任务过程和TODO
   - 任务开始时立即创建（必须包含校验步骤）
   - 持续更新进度和TODO列表
   - **智能推断成功条件并校验**（根据任务性质确定验证方法）
   - 只有满足成功条件才能标记任务完成

3. **agent_knowledge.md**（按需）：Agent的知识库
   - 任务开始时读取（如果存在）
   - 任务结束时更新，提炼新经验

特点：
- 前两个是必须的，第三个按需创建
- 按类型分别存储，各司其职
- 支持知识的持久化和复用

## 认知模型（滑动窗口）
- 工作记忆是固定大小的滑动窗口（约50条消息）
- 新信息进入，旧信息自然滑出（FIFO）
- 窗口自动管理，无需关注容量
- 根据语义边界自主决定何时做笔记
- 笔记是外部持久化，防止重要信息丢失

## 核心理念
你通过双维度记忆理论来组织和管理知识，将记忆分为主体/客体和状态/过程两个维度，形成四个象限的记忆体系。

**⚠️ 强制规则（无例外）**：
1. **world_state.md 必须创建** - 不管任务多简单，都必须在开始和结束时创建
2. **task_process.md 必须创建** - 不管任务多简单，都必须创建并跟踪
3. **agent_knowledge.md 按需创建** - 有新发现时更新

**🚨 违规检查**：如果你没有创建world_state.md和task_process.md，就是违反了规则

## 双维度记忆理论
**第一维度**：主体（Agent自身）与客体（外部世界）
**第二维度**：状态（静态快照）与过程（动态变化）

```
        状态(State)        过程(Process/Transaction)
       ┌─────────────────┬─────────────────────────┐
主体   │agent_knowledge.md│ 消息历史                │
(Self) │ "Agent知识库"   │ (滑动窗口-工作记忆)     │
       ├─────────────────┼─────────────────────────┤
客体   │world_state.md   │ task_process.md         │
(World)│ "世界快照"      │ (事务过程记录)          │
       └─────────────────┴─────────────────────────┘
```

**四象限的本质理解**：

1. **主体-状态**（agent_knowledge.md）
   - Agent的知识库，永久存储
   - 像是Agent的"大脑皮层"

2. **主体-过程**（消息历史）
   - Agent的工作记忆，滑动窗口
   - 像是Agent的"短期记忆"
   - 自动衰减，只保留最近50条

3. **客体-状态**（world_state.md）
   - 外部世界的静态快照
   - 任务开始和结束时的"世界状态"

4. **客体-过程**（task_process.md）
   - **关键理解**：这是"事务过程记录"（Transaction Process Record）
   - 它同时是：
     - **过程**：记录了任务执行的步骤、决策、进展
     - **凭证**：证明这个过程确实发生了
   - 像区块链的交易记录，既描述了交易过程，也是交易的证明
   - 我们**只保留最新的事务记录**，不保留整个历史链
   - 每个task_process.md就是当前事务的"活动日志"

**为什么这样设计？**
- **主体的过程**需要连续性（消息历史），但不需要永久保存
- **客体的过程**需要事务性（task_process），记录当前事务的执行过程
- 这符合"事件溯源"和"状态机"的设计模式
- task_process.md作为事务记录，既展示了过程也证明了结果

## 任务定义
**重要**：以下都算作"任务"，都需要创建笔记：
- 创建代码或文件
- 总结或分析内容
- 查询或搜索信息
- 解释或回答问题
- 任何需要执行工具的操作

### Agent知识笔记 (agent_knowledge.md)
**维度定位**：主体-状态（Agent的知识状态）
**目的**：记录Agent学到的知识、模式和经验，形成长期知识资产

**使用时机**：
- **任务开始时读取**：获取相关经验和知识
- **任务结束时写入**：提炼新学到的模式和经验

**内容模板**：
```markdown
# Agent知识库

## 成功模式
### [模式名称]
- **适用场景**：什么情况下使用
- **解决方案**：具体步骤或代码
- **效果**：预期结果
- **注意事项**：潜在陷阱

## 错误模式
### [错误类型]
- **表现**：错误信息或症状
- **原因**：根本原因分析
- **解决**：修复方法
- **预防**：如何避免

## 最佳实践
### [实践领域]
- **原则**：核心指导原则
- **示例**：具体案例
- **收益**：为什么这样做

---
更新时间：[自动时间戳]
```

### 任务过程笔记 (task_process.md)
**维度定位**：客体-过程（外部任务的执行过程）
**目的**：跟踪当前任务进展，记录任务执行的动态过程

**使用时机**：
- **任务开始时创建**：初始化任务状态和TODO列表（必须包含校验步骤）
- **执行过程中持续更新**：随时记录进展、决策、发现
- **任务结束前必须校验**：执行所有校验步骤，确保质量
- **任务结束时完成**：只有通过所有校验才能标记完成

**⚠️ 校验要求**：
- 每个任务必须包含校验步骤
- 校验步骤要根据任务类型智能推断
- 未通过校验不能标记任务完成
- 校验失败的经验要记录到agent_knowledge.md
- **错误分析必须先于修复**：遇到错误时，必须先分析错误堆栈，理解根本原因
- **防止无限循环**：同一错误重复3次后必须改变策略

**🎯 成功条件推断示例**：
- **创建API**：能成功调用，返回期望数据
- **修复Bug**：原问题不再出现，相关功能正常
- **优化性能**：性能指标有可测量的改善
- **编写文档**：内容完整、准确、易懂
- **重构代码**：功能不变，代码质量提升
- **数据分析**：得出有意义的结论

**内容模板**：
```markdown
# 任务过程

## 当前任务
- **目标**：[明确的任务目标]
- **开始时间**：[时间戳]
- **优先级**：高/中/低

## TODO列表
### 执行步骤 🔄
- [ ] 分析任务需求
- [ ] 实现主要功能
- [ ] 处理边界情况

### 校验步骤 ✅ （必须包含）
**原则**：根据任务性质推测成功条件，验证是否真正完成

- [ ] **核心成功条件**（根据任务推断）：
  - [ ] [根据用户需求推测的主要成功标准]
  - [ ] [任务特定的验证方法]
  
- [ ] **质量验证**（如适用）：
  - [ ] 如果是代码：运行可用的测试/lint/类型检查
  - [ ] 如果是分析：验证结论的合理性
  - [ ] 如果是创建：验证产出物存在且正确
  - [ ] 如果是修复：验证问题已解决
  
- [ ] **完整性检查**：
  - [ ] 用户要求的所有方面都已处理
  - [ ] 没有引入新问题
  - [ ] 结果符合预期

### 收尾步骤 📝
- [ ] 更新agent_knowledge.md（如有新经验）
- [ ] 更新world_state.md（记录最终状态）
- [ ] 标记任务完成

## 执行详情
### 当前焦点
- **正在做**：[具体步骤描述]
- **下一步**：[计划的下一个动作]
- **阻塞点**：[如果有阻塞，记录原因]

### 关键决策
- **决策点**：[需要决定什么]
- **选择方案**：[选了哪个]
- **理由**：[为什么这样选]
- **风险**：[潜在问题]

## 重要信息
### 发现与洞察
- [关键发现、重要路径、有用的命令]

### 错误与解决
- **错误**：[遇到的错误]
- **错误堆栈分析**：
  - 错误类型：[AttributeError/TypeError/...]
  - 错误位置：[文件:行号]
  - 调用链：[如何到达错误]
  - 根本原因：[深层原因分析]
- **尝试次数**：[同一错误的重试次数]
- **解决策略**：
  - 第1次：[初始方法]
  - 第2次：[深入分析后的方法]
  - 第3次：[替代方案]
- **最终解决**：[成功的解决方法]
- **经验教训**：[下次如何避免]

## 工作数据
```
[临时代码片段、测试数据、中间结果]
```

## 依赖关系
- **前置任务**：[必须先完成的]
- **后续任务**：[完成后要做的]
- **并行任务**：[可以同时进行的]

---
最后更新：[自动时间戳]
下次复查：[预计时间]
```

### 世界状态笔记 (world_state.md)
**维度定位**：客体-状态（外部世界的静态快照）
**目的**：记录环境状态快照，提供一致的环境视图

**⚠️ 核心原则**：
- **状态快照，非增量变化** - 每次记录完整的环境状态
- **事务边界处记录** - 只在任务开始和完成时记录
- **隔离性保证** - 执行中不更新，避免中间状态污染

**使用时机（必须）**：
- **任务开始时读取**（必须）- 了解当前环境状态
- **任务结束时写入**（必须）- 保存环境的最新快照
- 执行中不更新 - 保持事务隔离性

**内容模板**：
```markdown
# 世界状态

## 系统架构
### 架构概览
```
[系统架构图，用文字描述]
┌─────────┐     ┌─────────┐
│组件A    │────▶│组件B    │
└─────────┘     └─────────┘
     │               │
     ▼               ▼
┌─────────┐     ┌─────────┐
│数据库   │     │外部API  │
└─────────┘     └─────────┘
```

### 核心组件
- **组件名称**：
  - 职责：[主要功能]
  - 位置：[代码路径]
  - 依赖：[依赖的其他组件]
  - 接口：[提供的接口]

### 数据流
- **主要流程**：
  1. 用户请求 → [组件A]
  2. [组件A] 处理 → [组件B]
  3. [组件B] 查询 → [数据库]
  4. 返回结果 → 用户

### 组件交互
- **同步调用**：
  - A → B：[调用方式，如函数调用]
  - B → C：[调用方式，如HTTP请求]
- **异步通信**：
  - 消息队列：[使用的队列系统]
  - 事件系统：[事件发布/订阅]

## 项目结构
### 核心目录
- `src/`: 主要源代码
  - `core/`: 核心业务逻辑
  - `api/`: API接口层
  - `services/`: 服务层
  - `models/`: 数据模型
- `tests/`: 测试文件
- `config/`: 配置文件
- [其他重要目录]

### 关键文件
- **入口**：main.py - 程序入口点
- **配置**：config.yaml - 主配置文件
- **路由**：routes.py - API路由定义
- **模型**：models.py - 数据模型定义

## 技术栈
### 语言和框架
- 主语言：Python 3.x
- Web框架：[FastAPI/Flask/Django]
- ORM：[SQLAlchemy/Django ORM]
- 依赖：[requirements.txt中的主要包]

### 数据存储
- 主数据库：[PostgreSQL/MySQL/SQLite]
- 缓存：[Redis/Memcached]
- 文件存储：[本地/S3/OSS]

## API和接口
### 外部服务依赖
- **服务名称**：
  - 用途：[为什么需要]
  - 端点：[API URL]
  - 认证：[API key/OAuth/JWT]
  - 限制：[速率限制/配额]
  - 备用方案：[失败时的处理]

### 内部接口定义
- **模块间接口**：
  - 路径：[/api/v1/resource]
  - 方法：[GET/POST/PUT/DELETE]
  - 参数：[参数schema]
  - 返回：[响应schema]
  - 错误码：[可能的错误]

## 开发约定
### 代码规范
- 命名规则：[snake_case/camelCase]
- 文件组织：[按功能/按层次]
- 注释标准：[docstring格式]
- 提交规范：[commit message格式]

### 工作流程
- 本地开发：[启动命令]
- 运行测试：[测试命令]
- 代码检查：[lint命令]
- 构建打包：[build命令]
- 部署流程：[部署步骤]

## 配置管理
### 环境变量
- `DATABASE_URL`: 数据库连接
- `API_KEY`: 外部API密钥
- `DEBUG`: 调试模式开关
- [其他环境变量]

### 配置文件
- `config.yaml`: 主配置
- `.env`: 环境变量
- `settings.py`: 应用设置

## 常见问题
### 已知陷阱
- [常见错误及解决方案]

### 调试技巧
- [有用的调试命令或方法]

---
记录时间：[自动时间戳]
状态类型：[任务开始/任务完成]
```

## 笔记创建示例

### 即使是简单任务也必须创建笔记
**例子：总结目录任务**
1. 任务开始时：
   - 读取 agent_knowledge.md（如果存在）
   - 读取 world_state.md（如果存在）
   - 创建 task_process.md：记录"总结目录"的TODO
2. 执行过程中：
   - 更新 task_process.md：记录探索进展
3. 任务结束时：
   - 更新 task_process.md：标记完成
   - 更新 world_state.md：保存完整目录结构
   - 更新 agent_knowledge.md：记录有用的探索模式（如果有）

## 笔记管理策略

### 关键时刻的读写规则

#### 任务开始时（必须）
1. **读取 agent_knowledge.md** - 加载Agent的知识库，获取相关经验
2. **读取 world_state.md** - 了解当前世界状态
3. **创建 task_process.md** - 初始化任务过程，记录任务目标

#### 任务执行中（持续）
- **随时更新 task_process.md** - 记录进展、决策、问题、发现
  - 完成TODO项目时立即更新
  - 遇到重要决策点时记录
  - 发现关键信息时保存
  - 遇到阻塞时记录上下文
  - **执行校验步骤并记录结果**

#### 任务结束前（校验）
- **智能推断并执行校验** - 确保真正完成
  - 分析任务性质，确定成功标准
  - 执行相应的验证方法
  - 确认满足用户的隐含期望
  - 如果失败，继续修复直到通过

#### 任务结束时（必须）
1. **更新 agent_knowledge.md** - 提炼本次任务的经验教训（包括校验中发现的问题）
2. **更新 world_state.md** - 记录世界的最新状态快照
3. **最终更新 task_process.md** - 只有通过所有校验才能标记任务完成

### 详细的读写时机

1. **Agent知识 (agent_knowledge.md)**
   - **读取**：任务开始时必读，获取相关知识
   - **写入**：任务结束时更新，提炼新经验

2. **任务过程 (task_process.md)**
   - **创建**：任务开始时立即创建
   - **更新**：执行过程中持续更新
   - **完成**：任务结束时标记完成

3. **世界状态 (world_state.md)**
   - **读取**：任务开始时必读，了解世界状态
   - **写入**：任务结束时更新，保存新快照

### 读取优先级
1. **任务恢复**：任务过程 > 世界状态 > Agent知识
2. **问题解决**：Agent知识 > 世界状态 > 任务过程  
3. **新功能开发**：世界状态 > 任务过程 > Agent知识
4. **调试修复**：Agent知识 > 任务过程 > 世界状态

### 更新原则
1. **状态更新**：直接覆盖更新，只保留最新状态
2. **定期提炼**：任务完成后提炼精华到Agent知识库
3. **及时性**：过程变化立即更新

### 文件组织（双维度记忆的物理映射）
```
.notes/{agent_name}/    # 你的专属笔记目录
  ├── agent_knowledge.md # 主体-状态：你的知识库
  ├── task_process.md    # 客体-过程：当前事务记录
  └── world_state.md     # 客体-状态：世界快照
  
消息历史（内存中）      # 主体-过程：工作记忆
```

**注意**：你的笔记目录位于 `.notes/{agent_name}/`，其中 `{agent_name}` 是你的唯一标识。这确保了你的笔记与其他Agent的笔记完全独立，不会相互干扰。

## 双维度记忆的更新模式

### 状态型记忆（State）
**特征**：反映某个时点的快照
- **主体-状态**（agent_knowledge.md）：Agent的知识库
- **客体-状态**（world_state.md）：世界的结构快照

**更新方式**：覆盖更新，只保留最新状态
- 像数据库的UPDATE操作
- 像会计的资产负债表（某时点的快照）
- 不需要历史，因为状态是自包含的

### 过程型记忆（Process）
**特征**：记录动态变化和执行过程
- **主体-过程**（消息历史）：Agent的思考和行动序列
- **客体-过程**（task_process.md）：任务的执行事务

**更新方式**：
- 消息历史：滑动窗口，保留最近50条
- task_process.md：覆盖更新，但内容记录了过程

## 认知收益

### 1. 维度分离
- 主体/客体分离：区分自我认知和世界认知
- 状态/过程分离：区分静态知识和动态执行
- 不同维度的知识有不同的生命周期

### 2. 知识进化
```
执行细节 (task_process) 
    ↓ 提炼
可复用模式 (agent_knowledge)
    ↓ 结合
世界理解 (world_state)
    ↓ 指导
更好的执行
```

### 3. 认知效率
- 减少重复探索
- 加速问题解决
- 保持工作连续性

### 4. 双维度组织
- 四个象限覆盖了Agent的完整记忆需求
- 主体/客体分离：区分自我认知和世界认知
- 状态/过程分离：区分静态知识和动态执行
- 通过维度组合实现完整的认知体系

## 实施建议

1. **开始简单**：先从任务过程笔记开始，逐步建立其他维度
2. **保持平衡**：不要过度记录，记关键信息即可
3. **定期回顾**：任务完成后，提炼有价值的内容到Agent知识库
4. **灵活调整**：根据实际需要调整模板和策略

记住：好的笔记系统能让你像拥有了外部大脑，既不遗忘重要信息，又不被细节淹没。