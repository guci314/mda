{
  "id": "036681c261e373f0",
  "timestamp": "2025-08-19T22:00:46.322957",
  "metadata": {
    "role": "tool",
    "round": 38,
    "importance": null
  },
  "views": {
    "FULL": {
      "content": {
        "role": "tool",
        "tool_call_id": "call_ba37f4ed0ca140a387af3aed",
        "name": "read_file",
        "content": "# QwenReactAgent 记忆系统完整文档\n\n## 1. 系统概述\n\nQwenReactAgent集成了一个高性能的双记忆系统，模仿人类的记忆机制，支持超长上下文（262k tokens）的智能管理。\n\n### 核心特性\n- ✅ **双记忆架构**：状态记忆（空间）+ 过程记忆（时间）\n- ✅ **预计算优化**：50-250倍性能提升\n- ✅ **自动模式选择**：根据资源智能配置\n- ✅ **完全集成**：记忆系统是Agent的核心功能\n\n## 2. 架构设计\n\n### 2.1 双记忆系统\n\n```\n┌─────────────────────────────────────────────┐\n│            QwenReactAgent                   │\n│                                             │\n│  ┌─────────────────────────────────────┐   │\n│  │       Memory Manager                 │   │\n│  │                                      │   │\n│  │  ┌──────────────┐  ┌──────────────┐ │   │\n│  │  │State Memory  │  │Process Memory│ │   │\n│  │  │  (VSCode)    │  │  (Messages)  │ │   │\n│  │  │              │  │              │ │   │\n│  │  │ 潜意识───────┼──┼──显意识      │ │   │\n│  │  │ (文件系统)   │  │ (工作记忆)   │ │   │\n│  │  └──────────────┘  └──────────────┘ │   │\n│  └─────────────────────────────────────┘   │\n└─────────────────────────────────────────────┘\n```\n\n### 2.2 状态记忆（VSCode模式）\n\n**潜意识层（文件系统）**\n- 持久化存储在 `.memory/` 目录\n- JSON格式保存状态快照\n- 支持会话恢复\n\n**显意识层（工作记忆）**\n```python\nconsciousness = {\n    \"resource_outline\": [],  # 资源大纲(文件树)\n    \"overview\": [],         # 全局概览\n    \"working_set\": [],      # 工作集(打开的文件)\n    \"focus_item\": None,     # 当前焦点\n    \"detail_view\": None,    # 详细视图\n    \"action_history\": [],   # 操作历史\n    \"issues\": [],           # 待解决问题\n    \"findings\": []          # 发现和洞察\n}\n```\n\n### 2.3 过程记忆（消息历史）\n\n**时间衰减模型**\n```python\n距离现在 → 清晰度\n< 10轮   → FULL (100%)\n< 50轮   → HIGH (70%)\n< 100轮  → MEDIUM (50%)\n< 200轮  → LOW (30%)\n≥ 200轮  → MINIMAL (10%)\n```\n\n## 3. 理论基础：VSCode界面与人类记忆系统的映射\n\n### 3.1 认知科学视角\n\nVSCode的界面设计实际上是对人类认知架构的工程化实现。我们的记忆系统设计建立在这种映射关系之上：\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     人类记忆系统                              │\n├─────────────────────────────────────────────────────────────┤\n│  感觉记忆 (Sensory Memory)                                   │\n│    ↓ 注意力筛选                                              │\n│  工作记忆 (Working Memory)                                   │\n│    ├─ 视觉空间画板 (Visuospatial Sketchpad)                  │\n│    ├─ 语音回路 (Phonological Loop)                           │\n│    ├─ 中央执行系统 (Central Executive)                       │\n│    └─ 情景缓冲区 (Episodic Buffer)                          │\n│    ↓ 编码/巩固                                              │\n│  长期记忆 (Long-term Memory)                                 │\n│    ├─ 陈述性记忆 (Declarative)                              │\n│    └─ 程序性记忆 (Procedural)                               │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### 3.2 VSCode界面布局的认知映射\n\n#### 空间认知映射（视觉空间画板）\n\n```\nVSCode界面                     →  认知功能              →  记忆组件\n─────────────────────────────────────────────────────────────────\nExplorer (文件树)              →  空间导航/心理地图      →  resource_outline\nOpened Editors (打开的编辑器)  →  活跃工作集            →  working_set\nEditor Tabs (编辑器标签)       →  注意力切换点          →  focus_item\nMinimap (代码缩略图)           →  全局空间感知          →  overview\n```\n\n#### 内容认知映射（语音回路 + 情景缓冲）\n\n```\nVSCode界面                     →  认知功能              →  记忆组件\n─────────────────────────────────────────────────────────────────\nEditor Content (编辑器内容)    →  当前处理内容          →  detail_view\nOutline View (大纲视图)        →  结构化理解            →  overview\nIntelliSense (智能提示)        →  语义记忆激活          →  findings\nBreadcrumbs (面包屑导航)       →  层次化定位            →  focus_item\n```\n\n#### 任务管理映射（中央执行系统）\n\n```\nVSCode界面                     →  认知功能              →  记忆组件\n─────────────────────────────────────────────────────────────────\nProblems Panel (问题面板)      →  任务队列/注意力分配   →  issues\nSearch Results (搜索结果)      →  信息检索/模式识别     →  findings\nTerminal/Output (终端输出)     →  操作反馈/过程监控     →  action_history\nSource Control (源代码管理)    →  变更追踪/版本意识     →  action_history\n```\n\n### 3.3 双记忆系统的生物学基础\n\n#### 状态记忆 ↔ 海马体-皮层系统\n\n```python\n# 模拟海马体的快速编码和皮层的持久存储\nclass StateMemory:\n    def __init__(self):\n        self.hippocampus = {}  # 快速编码的工作记忆（consciousness）\n        self.cortex = {}       # 持久化的长期记忆（.memory/文件）\n    \n    def encode(self, experience):\n        # 海马体快速编码\n        self.hippocampus[experience.id] = experience\n        # 异步巩固到皮层\n        self.consolidate_to_cortex(experience)\n```\n\n**生物学对应**：\n- **海马体**：快速形成新记忆，对应 `consciousness` 字典\n- **皮层**：长期存储，对应 `.memory/` 持久化文件\n- **巩固过程**：睡眠时的记忆巩固，对应异步预计算\n\n#### 过程记忆 ↔ 工作记忆的时间衰减\n\n```python\n# 模拟工作记忆的容量限制和时间衰减\nclass ProcessMemory:\n    def __init__(self):\n        self.phonological_loop = []     # 语音回路（7±2容量）\n        self.decay_function = lambda t: exp(-t/tau)  # 时间衰减\n```\n\n**认知心理学依据**：\n- **Miller's Law (7±2)**: 工作记忆容量限制\n- **Recency Effect**: 最近的信息记忆最清晰\n- **Primacy Effect**: 最早的重要信息也会保留\n\n### 3.4 为什么这种映射是必要的\n\n#### 1. 认知负荷管理\n\n人类程序员使用IDE时的认知负荷分布：\n```\n总认知负荷 = 内在负荷 + 外在负荷 + 相关负荷\n           ↓         ↓          ↓\n      代码复杂性  界面导航   问题解决\n```\n\n我们的记忆系统通过模拟这种分布来优化Agent的认知资源：\n- `working_set` 限制同时处理的文件数（降低内在负荷）\n- `resource_outline` 提供导航地图（降低外在负荷）\n- `issues` + `findings` 聚焦问题解决（优化相关负荷）\n\n#### 2. 注意力机制模拟\n\n```python\nattention_hierarchy = {\n    \"focus\": 1.0,      # 中央凹视觉 - detail_view\n    \"peripheral\": 0.5,  # 周边视觉 - working_set\n    \"ambient\": 0.1     # 环境感知 - resource_outline\n}\n```\n\n这种层次化注意力确保Agent像人类一样：\n- 专注于当前任务（focus_item）\n- 保持对相关文件的感知（working_set）\n- 维持全局认知地图（resource_outline）\n\n#### 3. 情境认知（Situated Cognition）\n\nIDE不仅是工具，更是认知环境的延伸：\n\n```\n物理环境 + 工具 + 内部表征 = 分布式认知系统\n    ↓        ↓        ↓\n 屏幕布局  VSCode   工作记忆\n```\n\n我们的设计承认认知是分布式的：\n- 不是所有信息都在\"大脑\"（LLM）中\n- 环境（文件系统）是认知的一部分\n- 工具（VSCode隐喻）塑造思维方式\n\n### 3.5 设计原则总结\n\n基于以上理论分析，我们的记忆系统设计遵循以下原则：\n\n1. **生态有效性**：模拟真实的编程认知过程\n2. **认知经济性**：优化认知资源的分配\n3. **情境嵌入性**：认知与环境紧密耦合\n4. **层次化处理**：从感知到认知的多层次处理\n5. **动态适应性**：根据任务调整记忆策略\n\n这不是对VSCode的简单模仿，而是基于认知科学的工程化实现，让AI能够以类人的方式理解和操作代码。\n\n## 4. 预计算机制\n\n### 4.1 状态记忆预计算（4级分辨率）\n\n| 分辨率 | FULL | PREVIEW | OUTLINE | TITLE |\n|--------|------|---------|---------|-------|\n| **内容量** | 100% | ~200 tokens | ~50 tokens | ~10 tokens |\n| **用途** | 当前焦点 | 快速浏览 | 结构概览 | 标题摘要 |\n\n### 4.2 过程记忆预计算（5级清晰度）\n\n| 清晰度 | FULL | HIGH | MEDIUM | LOW | MINIMAL |\n|--------|------|------|--------|-----|---------|\n| **保留信息** | 100% | 70% | 50% | 30% | 10% |\n| **内容类型** | 原始 | 详细摘要 | 标准摘要 | 简短摘要 | 标记 |\n\n### 4.3 性能提升\n\n```\n传统压缩：每次需要 O(n) 时间实时计算\n预计算：  直接获取 O(1) 时间查找\n\n性能提升：50-250倍\n```\n\n## 5. 记忆模式\n\n### 5.1 自动选择逻辑\n\n```python\ndef auto_select_mode():\n    if context_size >= 200000 and cpu_cores >= 4:\n        return FULL_ASYNC    # 完整异步\n    elif context_size >= 200000:\n        return HYBRID        # 混合模式\n    elif context_size >= 50000:\n        return HYBRID        # 混合模式\n    else:\n        return BASIC         # 基础模式\n```\n\n### 5.2 可用模式\n\n| 模式 | 说明 | 适用场景 |\n|------|------|----------|\n| **DISABLED** | 禁用记忆 | 简单任务 |\n| **BASIC** | 传统压缩 | 小上下文 |\n| **HYBRID** | 部分预计算 | 中等规模 |\n| **FULL_ASYNC** | 完整预计算 | 大规模任务 |\n| **AUTO** | 自动选择 | 推荐默认 |\n\n## 6. 核心组件\n\n### 6.1 文件结构\n\n```\ncore/\n├── qwen_react_agent.py          # 主Agent（集成记忆）\n├── memory_manager.py            # 统一记忆管理器\n├── vscode_memory.py            # VSCode状态记忆\n├── vscode_memory_async.py      # 异步VSCode记忆\n├── process_memory.py           # 过程记忆\n├── async_memory_processor.py   # 异步消息处理器\n├── llm_memory_compressor.py    # LLM压缩器（可选）\n└── neural_memory_processor.py  # 神经网络处理器（可选）\n```\n\n### 6.2 核心类\n\n**MemoryManager**\n- 统一管理状态和过程记忆\n- 自动选择最佳配置\n- 提供统一接口\n\n**VSCodeMemory/AsyncVSCodeMemory**\n- 管理工作空间状态\n- 文件操作自动记录\n- 支持搜索和导航\n\n**AsyncMemoryProcessor**\n- 异步预计算消息视图\n- 管理多级清晰度\n- 缓存到磁盘\n\n## 7. 使用方法\n\n### 7.1 基础使用\n\n```python\nfrom core.qwen_react_agent import QwenReactAgent\n\n# 最简单 - 自动配置\nagent = QwenReactAgent(work_dir=\"./workspace\")\n\n# 指定模式\nfrom core.memory_manager import MemoryMode\nagent = QwenReactAgent(\n    work_dir=\"./workspace\",\n    memory_mode=MemoryMode.FULL_ASYNC  # 最高性能\n)\n```\n\n### 7.2 执行任务\n\n```python\n# 记忆系统自动工作\nresult = agent.execute_task(\"创建一个Web应用\")\n\n# 查看状态\nstatus = agent.get_status()\nprint(f\"工作集: {status['memory']['state_memory']['working_set']}个文件\")\nprint(f\"记忆模式: {status['memory']['mode']}\")\n```\n\n### 7.3 记忆搜索\n\n```python\n# 搜索历史记忆（内置工具）\ntask = \"使用search_memory工具搜索'error'相关内容\"\nresult = agent.execute_task(task)\n```\n\n## 8. 工作流程\n\n### 8.1 文件操作记录\n\n```\n用户: \"创建app.py\"\n  ↓\nAgent执行write_file\n  ↓\n自动记录到状态记忆\n  ↓\n异步预计算4个分辨率视图\n  ↓\n更新工作集\n```\n\n### 8.2 消息优化流程\n\n```\n对话进行中...\n  ↓\n检查轮数和消息数\n  ↓\n如需优化（每50轮）\n  ↓\n根据时间距离选择清晰度\n  ↓\n直接获取预计算视图\n  ↓\n重组消息历史\n```\n\n### 8.3 记忆搜索流程\n\n```\nsearch_memory(\"错误\")\n  ↓\n搜索状态记忆（文件、事件）\n  ↓\n搜索过程记忆（消息历史）\n  ↓\n返回相关结果\n```\n\n## 9. 高级特性\n\n### 9.1 记忆持久化\n\n- 自动保存到 `.memory/` 目录\n- 支持会话恢复\n- 增量更新\n\n### 9.2 垃圾回收\n\n- 自动清理过期记忆\n- 保留重要状态\n- 可配置保留策略\n\n### 9.3 连接主义扩展（可选）\n\n使用LLM进行智能压缩：\n```python\n# llm_memory_compressor.py\n- 语义理解压缩\n- 智能摘要生成\n- 语义搜索支持\n```\n\n## 10. 性能优化\n\n### 10.1 缓存策略\n\n- 预计算视图缓存到磁盘\n- 热数据保持在内存\n- LRU淘汰策略\n\n### 10.2 异步处理\n\n- 不阻塞主流程\n- 后台预计算\n- 并发处理多个视图\n\n### 10.3 批处理\n\n- 批量压缩消息\n- 减少API调用（LLM模式）\n- 提高吞吐量\n\n## 11. 配置示例\n\n### 11.1 小任务配置\n\n```python\nagent = QwenReactAgent(\n    work_dir=\"./simple\",\n    memory_mode=MemoryMode.BASIC,\n    max_rounds=10\n)\n```\n\n### 11.2 复杂项目配置\n\n```python\nagent = QwenReactAgent(\n    work_dir=\"./complex_project\",\n    memory_mode=MemoryMode.FULL_ASYNC,\n    max_rounds=300,\n    max_context_tokens=262144\n)\n```\n\n### 11.3 资源受限配置\n\n```python\nagent = QwenReactAgent(\n    work_dir=\"./limited\",\n    memory_mode=MemoryMode.HYBRID,  # 平衡性能\n    max_rounds=50\n)\n```\n\n## 12. 注意事项\n\n### 12.1 内存使用\n\n- 预计算增加内存使用（约2.5倍）\n- 通过磁盘缓存缓解\n- 可配置缓存大小限制\n\n### 12.2 API限制\n\n- OpenRouter有速率限制\n- 合理设置max_rounds\n- 使用缓存减少重复\n\n### 12.3 兼容性\n\n- 需要Python 3.8+\n- 需要足够的磁盘空间（缓存）\n- 建议4核以上CPU（异步模式）\n\n## 13. 故障排除\n\n### 问题：记忆系统未生效\n```python\n# 检查是否启用\nstatus = agent.get_status()\nprint(status['memory']['enabled'])  # 应该为True\n```\n\n### 问题：上下文溢出\n```python\n# 使用更激进的压缩\nagent = QwenReactAgent(\n    memory_mode=MemoryMode.FULL_ASYNC,  # 最优压缩\n    max_context_tokens=100000  # 降低限制\n)\n```\n\n### 问题：性能问题\n```python\n# 检查缓存\ncache_dir = Path(\"./workspace/.message_views\")\ncache_size = sum(f.stat().st_size for f in cache_dir.glob(\"*.json\"))\nprint(f\"缓存大小: {cache_size/1024/1024:.1f} MB\")\n\n# 清理缓存\nimport shutil\nshutil.rmtree(cache_dir)\n```\n\n## 14. 最佳实践\n\n1. **默认使用AUTO模式** - 让系统自动选择\n2. **定期清理缓存** - 避免磁盘占用过大\n3. **合理设置轮数** - 避免无限循环\n4. **利用搜索功能** - search_memory工具很有用\n5. **监控内存使用** - 大项目注意资源\n\n## 15. 总结\n\nQwenReactAgent的记忆系统通过双记忆架构、预计算优化和智能管理，实现了：\n\n- **高性能**：50-250倍压缩速度提升\n- **智能化**：自动管理和优化\n- **可扩展**：支持超长对话\n- **易使用**：完全集成，开箱即用\n\n这使得Agent能够处理复杂的长期任务，同时保持高效的资源利用。"
      },
      "tokens": 6637,
      "generated_at": "2025-08-19T22:00:46.323147"
    },
    "MINIMAL": {
      "content": {
        "marker": "[tool:result]"
      },
      "tokens": 5,
      "generated_at": "2025-08-19T22:00:46.323157"
    },
    "HIGH": {
      "content": {
        "role": "tool",
        "content": "# QwenReactAgent 记忆系统完整文档\n\n## 1. 系统概述\n\nQwenReactAgent集成了一个高性能的双记忆系统，模仿人类的记忆机制，支持超长上下文（262k tokens）的智能管理。\n\n### 核心特性\n- ✅ **双记忆架构**：状态记忆（空间）+ 过程记忆（时间）\n- ✅ **预计算优化**：50-250倍性能提升\n- ✅ **自动模式选择**：根据资源智能配置\n- ✅ **完全集成**：记忆系统是Agent的核心功能\n\n## 2. 架构设计\n\n### 2.1 双记忆系统\n\n```\n┌─────────────────────────────────────────────┐\n│            QwenReactAgent                   │\n│                                             │\n│  ┌─────────────────────────────────────┐   │\n│  │       Memory Manager                 │   │\n│  │                                      │   │\n│  │  ┌──────────────┐  ┌──────────────┐ │   │\n│  │  │\n...[部分内容省略]...\nry工具很有用\n5. **监控内存使用** - 大项目注意资源\n\n## 15. 总结\n\nQwenReactAgent的记忆系统通过双记忆架构、预计算优化和智能管理，实现了：\n\n- **高性能**：50-250倍压缩速度提升\n- **智能化**：自动管理和优化\n- **可扩展**：支持超长对话\n- **易使用**：完全集成，开箱即用\n\n这使得Agent能够处理复杂的长期任务，同时保持高效的资源利用。"
      },
      "tokens": 717,
      "generated_at": "2025-08-19T22:00:46.330050"
    },
    "MEDIUM": {
      "content": {
        "role": "tool",
        "content_preview": "# QwenReactAgent 记忆系统完整文档\n\n## 1. 系统概述\n\nQwenReactAgent集成了一个高性能的双记忆系统，模仿人类的记忆机制，支持超长上下文（262k tokens）的智能管理。\n\n### 核心特性\n- ✅ **双记忆架构**：状态记忆（空间）+ 过程记忆（时间）\n- ✅ **预计算优化**：50-250倍性能提升\n- ✅ **自动模式选择**：根据资源智能配置\n- ✅ **完全集成**：记忆系统是Agent的核心功能\n\n## 2. 架构设计\n\n### 2.1 双记忆系统\n\n```\n┌────────────────────────────────────────..."
      },
      "tokens": 306,
      "generated_at": "2025-08-19T22:00:46.330091"
    },
    "LOW": {
      "content": {
        "role": "tool",
        "summary": "工具执行出错"
      },
      "tokens": 16,
      "generated_at": "2025-08-19T22:00:46.330207"
    }
  }
}