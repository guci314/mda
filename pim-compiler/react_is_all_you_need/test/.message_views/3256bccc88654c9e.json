{
  "id": "3256bccc88654c9e",
  "timestamp": "2025-08-19T21:56:55.161327",
  "metadata": {
    "role": "tool",
    "round": 62,
    "importance": null
  },
  "views": {
    "FULL": {
      "content": {
        "role": "tool",
        "tool_call_id": "call_fbc116456b8146c1beb46884",
        "name": "read_file",
        "content": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - å®Œå…¨é›†æˆè®°å¿†ç³»ç»Ÿç‰ˆæœ¬\né€šç”¨çš„ReAct (Reasoning + Acting) Agentæ¡†æ¶\næ”¯æŒä»»ä½•OpenRouterå…¼å®¹çš„LLMæ¨¡å‹\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, MemoryMode\n\nclass ReactAgent:\n    \"\"\"å¸¦å®Œæ•´è®°å¿†ç³»ç»Ÿçš„é€šç”¨React Agent\"\"\"\n    \n    def __init__(self, \n                 work_dir: str,\n                 model: str = \"qwen/qwen3-coder\",\n                 api_key: Optional[str] = None,\n                 knowledge_files: Optional[List[str]] = None,\n                 interface: str = \"\",\n                 max_rounds: int = 300,\n                 memory_mode: MemoryMode = MemoryMode.AUTO,\n                 max_context_tokens: Optional[int] = None,\n                 message_hooks: Optional[List] = None):\n        \"\"\"\n        åˆå§‹åŒ–React Agent with Memory\n        \n        Args:\n            work_dir: å·¥ä½œç›®å½•\n            model: æ¨¡å‹åç§°\n            api_key: OpenRouter APIå¯†é’¥\n            knowledge_files: çŸ¥è¯†æ–‡ä»¶åˆ—è¡¨\n            interface: Agentæ¥å£æè¿°\n            max_rounds: æœ€å¤§æ‰§è¡Œè½®æ•°\n            memory_mode: è®°å¿†æ¨¡å¼ï¼ˆAUTOä¼šè‡ªåŠ¨é€‰æ‹©æœ€ä½³æ¨¡å¼ï¼‰\n            max_context_tokens: æœ€å¤§ä¸Šä¸‹æ–‡tokensï¼ˆNoneæ—¶è‡ªåŠ¨æ£€æµ‹ï¼‰\n            message_hooks: æ¶ˆæ¯é’©å­åˆ—è¡¨ï¼Œç”¨äºæ‹¦æˆªå’Œå¤„ç†æ¶ˆæ¯æµ\n        \"\"\"\n        self.work_dir = Path(work_dir)\n        self.work_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.model = model\n        self.api_key = api_key or os.getenv(\"OPENROUTER_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"OPENROUTER_API_KEY not set\")\n            \n        self.base_url = \"https://openrouter.ai/api/v1\"\n        self.knowledge_files = knowledge_files or []\n        self.interface = interface\n        self.max_rounds = max_rounds\n        \n        # è‡ªåŠ¨æ£€æµ‹æ¨¡å‹çš„ä¸Šä¸‹æ–‡å¤§å°\n        if max_context_tokens is None:\n            max_context_tokens = self._detect_context_size()\n        \n        # åˆå§‹åŒ–è®°å¿†ç®¡ç†å™¨ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰\n        self.memory = MemoryManager(\n            work_dir=str(self.work_dir),\n            mode=memory_mode,\n            max_context_tokens=max_context_tokens,\n            enable_cache=True\n        )\n        \n        # åŠ è½½çŸ¥è¯†æ–‡ä»¶\n        self.knowledge = self._load_knowledge()\n        \n        # å®šä¹‰å·¥å…·\n        self.tools = self._define_tools()\n        \n        # æ‰§è¡Œç»Ÿè®¡\n        self.stats = {\n            \"total_rounds\": 0,\n            \"tool_calls\": {},\n            \"files_created\": [],\n            \"files_read\": []\n        }\n        \n        # æ¶ˆæ¯é’©å­ç³»ç»Ÿ\n        self.message_hooks = message_hooks or []\n    \n    def _detect_context_size(self) -> int:\n        \"\"\"æ ¹æ®æ¨¡å‹è‡ªåŠ¨æ£€æµ‹ä¸Šä¸‹æ–‡å¤§å°\"\"\"\n        context_sizes = {\n            \"qwen/qwen3-coder\": 262144,           # 262k\n            \"qwen/qwen-2.5-coder-32b-instruct\": 131072,  # 131k\n            \"qwen/qwq-32b-preview\": 32768,        # 32k\n            \"qwen/qwen-2-72b-instruct\": 131072,   # 131k\n        }\n        return context_sizes.get(self.model, 32768)  # é»˜è®¤32k\n    \n    def _load_knowledge(self) -> str:\n        \"\"\"åŠ è½½çŸ¥è¯†æ–‡ä»¶\"\"\"\n        knowledge_content = []\n        \n        for file_path in self.knowledge_files:\n            if os.path.exists(file_path):\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    knowledge_content.append(f\"# çŸ¥è¯†æ–‡ä»¶: {file_path}\\n{content}\\n\")\n        \n        return \"\\n\".join(knowledge_content)\n    \n    def _define_tools(self) -> List[Dict]:\n        \"\"\"å®šä¹‰å·¥å…·åˆ—è¡¨ï¼ˆOpenAIæ ¼å¼ï¼‰\"\"\"\n        return [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"read_file\",\n                    \"description\": \"è¯»å–æ–‡ä»¶å†…å®¹\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                            }\n                        },\n                        \"required\": [\"file_path\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"write_file\",\n                    \"description\": \"å†™å…¥æ–‡ä»¶å†…å®¹ï¼ˆè¦†ç›–åŸæ–‡ä»¶ï¼‰ã€‚contentä¸èƒ½è¶…è¿‡8000å­—ç¬¦\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                            },\n                            \"content\": {\n                                \"type\": \"string\",\n                                \"description\": \"æ–‡ä»¶å†…å®¹\"\n                            }\n                        },\n                        \"required\": [\"file_path\", \"content\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"append_file\",\n                    \"description\": \"è¿½åŠ å†…å®¹åˆ°æ–‡ä»¶æœ«å°¾ã€‚contentä¸èƒ½è¶…è¿‡6000å­—ç¬¦\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"æ–‡ä»¶è·¯å¾„\"\n                            },\n                            \"content\": {\n                                \"type\": \"string\",\n                                \"description\": \"è¦è¿½åŠ çš„å†…å®¹\"\n                            }\n                        },\n                        \"required\": [\"file_path\", \"content\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"list_directory\",\n                    \"description\": \"åˆ—å‡ºç›®å½•å†…å®¹\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"directory_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"ç›®å½•è·¯å¾„\"\n                            }\n                        },\n                        \"required\": [\"directory_path\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"execute_command\",\n                    \"description\": \"æ‰§è¡ŒShellå‘½ä»¤\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"command\": {\n                                \"type\": \"string\",\n                                \"description\": \"è¦æ‰§è¡Œçš„å‘½ä»¤\"\n                            }\n                        },\n                        \"required\": [\"command\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"execute_python\",\n                    \"description\": \"æ‰§è¡ŒPythonä»£ç \",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"code\": {\n                                \"type\": \"string\",\n                                \"description\": \"è¦æ‰§è¡Œçš„Pythonä»£ç \"\n                            }\n                        },\n                        \"required\": [\"code\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"search_memory\",\n                    \"description\": \"æœç´¢è®°å¿†ç³»ç»Ÿ\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"query\": {\n                                \"type\": \"string\",\n                                \"description\": \"æœç´¢æŸ¥è¯¢\"\n                            }\n                        },\n                        \"required\": [\"query\"]\n                    }\n                }\n            }\n        ]\n    \n    def _execute_tool(self, tool_name: str, arguments: Dict) -> str:\n        \"\"\"æ‰§è¡Œå·¥å…·å¹¶è‡ªåŠ¨è®°å½•åˆ°è®°å¿†\"\"\"\n        \n        # æ›´æ–°ç»Ÿè®¡\n        self.stats[\"tool_calls\"][tool_name] = self.stats[\"tool_calls\"].get(tool_name, 0) + 1\n        \n        try:\n            if tool_name == \"read_file\":\n                file_path = arguments[\"file_path\"]\n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                if os.path.exists(abs_path):\n                    with open(abs_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                    \n                    # è‡ªåŠ¨è®°å½•åˆ°è®°å¿†\n                    self.memory.open_file(file_path, content)\n                    self.stats[\"files_read\"].append(file_path)\n                    \n                    return content\n                else:\n                    return f\"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}\"\n            \n            elif tool_name == \"write_file\":\n                file_path = arguments[\"file_path\"]\n                content = arguments[\"content\"]\n                \n                if len(content) > 8000:\n                    return f\"é”™è¯¯ï¼šå†…å®¹è¶…è¿‡8000å­—ç¬¦é™åˆ¶ï¼ˆ{len(content)}å­—ç¬¦ï¼‰\"\n                \n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n                with open(abs_path, 'w', encoding='utf-8') as f:\n                    f.write(content)\n                \n                # è‡ªåŠ¨è®°å½•åˆ°è®°å¿†\n                self.memory.open_file(file_path, content)\n                self.stats[\"files_created\"].append(file_path)\n                \n                return f\"æˆåŠŸå†™å…¥æ–‡ä»¶: {file_path}\"\n            \n            elif tool_name == \"append_file\":\n                file_path = arguments[\"file_path\"]\n                content = arguments[\"content\"]\n                \n                if len(content) > 6000:\n                    return f\"é”™è¯¯ï¼šå†…å®¹è¶…è¿‡6000å­—ç¬¦é™åˆ¶ï¼ˆ{len(content)}å­—ç¬¦ï¼‰\"\n                \n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                # è¯»å–ç°æœ‰å†…å®¹\n                existing_content = \"\"\n                if os.path.exists(abs_path):\n                    with open(abs_path, 'r', encoding='utf-8') as f:\n                        existing_content = f.read()\n                \n                # è¿½åŠ å†…å®¹\n                with open(abs_path, 'a', encoding='utf-8') as f:\n                    f.write(content)\n                \n                # æ›´æ–°è®°å¿†\n                full_content = existing_content + content\n                self.memory.open_file(file_path, full_content)\n                \n                return f\"æˆåŠŸè¿½åŠ åˆ°æ–‡ä»¶: {file_path}\"\n            \n            elif tool_name == \"list_directory\":\n                directory_path = arguments[\"directory_path\"]\n                abs_path = os.path.join(self.work_dir, directory_path) if not os.path.isabs(directory_path) else directory_path\n                \n                if os.path.exists(abs_path) and os.path.isdir(abs_path):\n                    items = os.listdir(abs_path)\n                    return \"\\n\".join(items) if items else \"ç›®å½•ä¸ºç©º\"\n                else:\n                    return f\"ç›®å½•ä¸å­˜åœ¨: {directory_path}\"\n            \n            elif tool_name == \"execute_command\":\n                import subprocess\n                command = arguments[\"command\"]\n                \n                result = subprocess.run(\n                    command,\n                    shell=True,\n                    capture_output=True,\n                    text=True,\n                    cwd=self.work_dir,\n                    timeout=30\n                )\n                \n                output = result.stdout\n                if result.stderr:\n                    output += f\"\\né”™è¯¯è¾“å‡º:\\n{result.stderr}\"\n                \n                return output if output else \"å‘½ä»¤æ‰§è¡ŒæˆåŠŸï¼ˆæ— è¾“å‡ºï¼‰\"\n            \n            elif tool_name == \"execute_python\":\n                import subprocess\n                code = arguments[\"code\"]\n                \n                result = subprocess.run(\n                    [\"python\", \"-c\", code],\n                    capture_output=True,\n                    text=True,\n                    cwd=self.work_dir,\n                    timeout=30\n                )\n                \n                output = result.stdout\n                if result.stderr:\n                    output += f\"\\né”™è¯¯è¾“å‡º:\\n{result.stderr}\"\n                \n                return output if output else \"ä»£ç æ‰§è¡ŒæˆåŠŸï¼ˆæ— è¾“å‡ºï¼‰\"\n            \n            elif tool_name == \"search_memory\":\n                query = arguments[\"query\"]\n                results = self.memory.search(query)\n                \n                if results:\n                    formatted = []\n                    for r in results[:5]:  # æœ€å¤šè¿”å›5ä¸ªç»“æœ\n                        formatted.append(f\"- {r.get('type', 'unknown')}: {r.get('path', r.get('id', ''))}\")\n                    return \"æœç´¢ç»“æœ:\\n\" + \"\\n\".join(formatted)\n                else:\n                    return \"æœªæ‰¾åˆ°ç›¸å…³å†…å®¹\"\n            \n            else:\n                return f\"æœªçŸ¥å·¥å…·: {tool_name}\"\n                \n        except Exception as e:\n            return f\"å·¥å…·æ‰§è¡Œé”™è¯¯: {str(e)}\"\n        \n        finally:\n            # è®°å½•å·¥å…·è°ƒç”¨äº‹ä»¶\n            self.memory.save_episode(\n                event=f\"tool_{tool_name}\",\n                data={\n                    \"tool\": tool_name,\n                    \"arguments\": arguments,\n                    \"round\": self.stats[\"total_rounds\"]\n                }\n            )\n    \n    def execute_task(self, task: str) -> str:\n        \"\"\"æ‰§è¡Œä»»åŠ¡\"\"\"\n        print(f\"\\n[ReactAgent] æ‰§è¡Œä»»åŠ¡...\")\n        print(f\"ğŸ“ ä»»åŠ¡: {task[:100]}...\" if len(task) > 100 else f\"ğŸ“ ä»»åŠ¡: {task}\")\n        \n        # è®°å½•ä»»åŠ¡å¼€å§‹\n        self.memory.save_episode(\n            event=\"task_start\",\n            data={\"task\": task[:500], \"timestamp\": datetime.now().isoformat()}\n        )\n        \n        # æ„å»ºåˆå§‹æ¶ˆæ¯\n        messages = [\n            {\"role\": \"system\", \"content\": self._build_system_prompt()},\n            {\"role\": \"user\", \"content\": task}\n        ]\n        \n        # æ‰§è¡Œè½®æ•°å¾ªç¯\n        for round_num in range(self.max_rounds):\n            self.stats[\"total_rounds\"] = round_num + 1\n            \n            print(f\"\\nğŸ¤” æ€è€ƒç¬¬{round_num + 1}è½®...\")\n            \n            # æ£€æŸ¥æ˜¯å¦éœ€è¦ä¼˜åŒ–æ¶ˆæ¯å†å²\n            if self.memory.should_optimize(round_num, len(messages)):\n                print(f\"ğŸ”„ ä¼˜åŒ–æ¶ˆæ¯å†å²...\")\n                messages = self.memory.optimize_message_history(messages)\n            \n            # æ·»åŠ æ¶ˆæ¯åˆ°è¿‡ç¨‹è®°å¿†\n            if round_num > 0:\n                for msg in messages[-2:]:  # æ·»åŠ æœ€æ–°çš„æ¶ˆæ¯\n                    self.memory.add_message(msg)\n            \n            # è°ƒç”¨API\n            response = self._call_api(messages)\n            \n            if response is None:\n                return \"APIè°ƒç”¨å¤±è´¥\"\n            \n            # å¤„ç†å“åº”\n            message = response[\"choices\"][0][\"message\"]\n            messages.append(message)\n            \n            # è°ƒç”¨æ¶ˆæ¯é’©å­\n            self._call_hooks(\"assistant\", message)\n            \n            # å¤„ç†å·¥å…·è°ƒç”¨\n            if \"tool_calls\" in message and message[\"tool_calls\"]:\n                for tool_call in message[\"tool_calls\"]:\n                    tool_name = tool_call[\"function\"][\"name\"]\n                    \n                    try:\n                        arguments = json.loads(tool_call[\"function\"][\"arguments\"])\n                    except json.JSONDecodeError:\n                        arguments = None\n                    \n                    if arguments is None:\n                        tool_result = f\"å‚æ•°è§£æå¤±è´¥\"\n                    else:\n                        print(f\"ğŸ”§ è°ƒç”¨å·¥å…·: {tool_name}\")\n                        tool_result = self._execute_tool(tool_name, arguments)\n                        \n                        # æ˜¾ç¤ºç»“æœé¢„è§ˆ\n                        preview = tool_result[:200] + \"...\" if len(tool_result) > 200 else tool_result\n                        print(f\"   â†’ {preview}\")\n                    \n                    # æ·»åŠ å·¥å…·ç»“æœ\n                    tool_message = {\n                        \"role\": \"tool\",\n                        \"tool_call_id\": tool_call[\"id\"],\n                        \"name\": tool_name,\n                        \"content\": tool_result\n                    }\n                    messages.append(tool_message)\n                    self.memory.add_message(tool_message)\n                    \n                    # è°ƒç”¨æ¶ˆæ¯é’©å­\n                    self._call_hooks(\"tool\", tool_message)\n            \n            # æ£€æŸ¥æ˜¯å¦å®Œæˆ\n            if response[\"choices\"][0].get(\"finish_reason\") == \"stop\" and not message.get(\"tool_calls\"):\n                print(f\"\\nâœ… ä»»åŠ¡å®Œæˆï¼ˆç¬¬{round_num + 1}è½®ï¼‰\")\n                \n                # è®°å½•ä»»åŠ¡å®Œæˆ\n                self.memory.save_episode(\n                    event=\"task_complete\",\n                    data={\n                        \"rounds\": round_num + 1,\n                        \"result_preview\": message[\"content\"][:500] if message.get(\"content\") else \"\",\n                        \"files_created\": self.stats[\"files_created\"],\n                        \"files_read\": self.stats[\"files_read\"]\n                    }\n                )\n                \n                # ä¿å­˜æœ€ç»ˆçŠ¶æ€\n                self.memory.save_state(\n                    state_name=\"task_completion\",\n                    state_data={\n                        \"task\": task[:500],\n                        \"rounds\": round_num + 1,\n                        \"stats\": self.stats\n                    }\n                )\n                \n                return message.get(\"content\", \"ä»»åŠ¡å®Œæˆ\")\n        \n        print(f\"\\nâš ï¸ è¾¾åˆ°æœ€å¤§æ‰§è¡Œè½®æ•° ({self.max_rounds}è½®)\")\n        \n        # è®°å½•è¶…æ—¶\n        self.memory.save_episode(\n            event=\"task_timeout\",\n            data={\"rounds\": self.max_rounds}\n        )\n        \n        return messages[-1].get(\"content\", \"è¾¾åˆ°æœ€å¤§æ‰§è¡Œè½®æ•°\") if messages else \"ä»»åŠ¡æœªå®Œæˆ\"\n    \n    def _build_system_prompt(self) -> str:\n        \"\"\"æ„å»ºç³»ç»Ÿæç¤ºè¯ï¼ˆåŒ…å«è®°å¿†çŠ¶æ€ï¼‰\"\"\"\n        \n        # è·å–è®°å¿†ä¸Šä¸‹æ–‡\n        memory_context = self.memory.get_memory_context(extra_tokens=5000)\n        \n        prompt = f\"\"\"ä½ æ˜¯Qwen Coderï¼Œä¸€ä¸ªä¸“ä¸šçš„ç¼–ç¨‹åŠ©æ‰‹ï¼Œé…å¤‡äº†é«˜æ€§èƒ½è®°å¿†ç³»ç»Ÿã€‚\n\n{self.interface}\n\n# çŸ¥è¯†åº“\n{self.knowledge}\n\n# å·¥ä½œç›®å½•\n{self.work_dir}\n\n# å½“å‰è®°å¿†çŠ¶æ€\n{memory_context if memory_context else \"ï¼ˆç©ºï¼‰\"}\n\n# æ‰§è¡Œçºªå¾‹\n1. æ‰€æœ‰æ–‡ä»¶æ“ä½œéƒ½ä¼šè‡ªåŠ¨è®°å½•åˆ°è®°å¿†ç³»ç»Ÿ\n2. å¯ä»¥ä½¿ç”¨search_memoryå·¥å…·æœç´¢å†å²\n3. å¤æ‚ä»»åŠ¡è¯·åˆ†æ­¥éª¤æ‰§è¡Œ\n4. é‡åˆ°é”™è¯¯æ—¶è®°å½•å¹¶å°è¯•ä¿®å¤\n\n# å†…å®¹é•¿åº¦é™åˆ¶\n- write_file: contentæœ€å¤š8000å­—ç¬¦\n- append_file: contentæœ€å¤š6000å­—ç¬¦\n- é•¿å†…å®¹å¿…é¡»åˆ†æ®µå¤„ç†\n\n# æ ¸å¿ƒä¼˜åŠ¿\n- ä»£ç ç”Ÿæˆèƒ½åŠ›æå¼º\n- æ·±åº¦æ¨ç†èƒ½åŠ›\n- é…å¤‡é«˜æ€§èƒ½è®°å¿†ç³»ç»Ÿ\n- æ”¯æŒè¶…é•¿ä¸Šä¸‹æ–‡ï¼ˆ{self.memory.max_context_tokens:,} tokensï¼‰\n\"\"\"\n        return prompt\n    \n    def _call_api(self, messages: List[Dict]) -> Optional[Dict]:\n        \"\"\"è°ƒç”¨OpenRouter API\"\"\"\n        try:\n            request_body = {\n                \"model\": self.model,\n                \"messages\": messages,\n                \"temperature\": 0.3,\n                \"max_tokens\": 8192\n            }\n            \n            if self.tools:\n                request_body[\"tools\"] = self.tools\n                request_body[\"tool_choice\"] = \"auto\"\n            \n            response = requests.post(\n                f\"{self.base_url}/chat/completions\",\n                headers={\n                    \"Authorization\": f\"Bearer {self.api_key}\",\n                    \"Content-Type\": \"application/json\",\n                    \"HTTP-Referer\": \"https://github.com/qwen-agent\",\n                    \"X-Title\": \"React Agent with Integrated Memory\"\n                },\n                json=request_body,\n                timeout=60\n            )\n            \n            if response.status_code != 200:\n                print(f\"âŒ APIé”™è¯¯: {response.text}\")\n                return None\n            \n            result = response.json()\n            \n            if \"error\" in result:\n                print(f\"âŒ APIè¿”å›é”™è¯¯: {result['error']}\")\n                return None\n            \n            return result\n            \n        except Exception as e:\n            print(f\"âŒ APIè°ƒç”¨å¼‚å¸¸: {e}\")\n            return None\n    \n    def get_status(self) -> Dict:\n        \"\"\"è·å–AgentçŠ¶æ€\"\"\"\n        return {\n            \"stats\": self.stats,\n            \"memory\": self.memory.get_status()\n        }\n    \n    def _call_hooks(self, message_type: str, message: Dict):\n        \"\"\"è°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„æ¶ˆæ¯é’©å­\"\"\"\n        for hook in self.message_hooks:\n            try:\n                hook(self, message_type, message)\n            except Exception as e:\n                print(f\"âš ï¸ é’©å­æ‰§è¡Œé”™è¯¯: {e}\")\n    \n    def add_hook(self, hook):\n        \"\"\"æ·»åŠ æ¶ˆæ¯é’©å­\"\"\"\n        if hook not in self.message_hooks:\n            self.message_hooks.append(hook)\n    \n    def remove_hook(self, hook):\n        \"\"\"ç§»é™¤æ¶ˆæ¯é’©å­\"\"\"\n        if hook in self.message_hooks:\n            self.message_hooks.remove(hook)\n    \n    def cleanup(self):\n        \"\"\"æ¸…ç†èµ„æº\"\"\"\n        print(\"ğŸ§¹ æ¸…ç†èµ„æº...\")\n        self.memory.cleanup()\n        print(\"âœ… æ¸…ç†å®Œæˆ\")"
      },
      "tokens": 6660,
      "generated_at": "2025-08-19T21:56:55.161732"
    },
    "MINIMAL": {
      "content": {
        "marker": "[tool:result]"
      },
      "tokens": 5,
      "generated_at": "2025-08-19T21:56:55.161748"
    },
    "HIGH": {
      "content": {
        "role": "tool",
        "content": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - å®Œå…¨é›†æˆè®°å¿†ç³»ç»Ÿç‰ˆæœ¬\né€šç”¨çš„ReAct (Reasoning + Acting) Agentæ¡†æ¶\næ”¯æŒä»»ä½•OpenRouterå…¼å®¹çš„LLMæ¨¡å‹\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, MemoryMode\n\nclass ReactAgent:\n    \"\"\"å¸¦å®Œæ•´è®°å¿†ç³»ç»Ÿçš„é€šç”¨React Agent\"\"\"\n    \n    def __init__(self, \n                 work_dir: str,\n                 model: str = \"qwen/qwen3-coder\",\n                 api_key: Optional[str] = None,\n                 knowledge_files: Optional[List[str]] = None,\n                 \n...[éƒ¨åˆ†å†…å®¹çœç•¥]...\n hook in self.message_hooks:\n            self.message_hooks.remove(hook)\n    \n    def cleanup(self):\n        \"\"\"æ¸…ç†èµ„æº\"\"\"\n        print(\"ğŸ§¹ æ¸…ç†èµ„æº...\")\n        self.memory.cleanup()\n        print(\"âœ… æ¸…ç†å®Œæˆ\")"
      },
      "tokens": 295,
      "generated_at": "2025-08-19T21:56:55.162217"
    },
    "MEDIUM": {
      "content": {
        "role": "tool",
        "content_preview": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - å®Œå…¨é›†æˆè®°å¿†ç³»ç»Ÿç‰ˆæœ¬\né€šç”¨çš„ReAct (Reasoning + Acting) Agentæ¡†æ¶\næ”¯æŒä»»ä½•OpenRouterå…¼å®¹çš„LLMæ¨¡å‹\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, ..."
      },
      "tokens": 120,
      "generated_at": "2025-08-19T21:56:55.162250"
    },
    "LOW": {
      "content": {
        "role": "tool",
        "summary": "å·¥å…·æ‰§è¡Œå‡ºé”™"
      },
      "tokens": 16,
      "generated_at": "2025-08-19T21:56:55.162553"
    }
  }
}