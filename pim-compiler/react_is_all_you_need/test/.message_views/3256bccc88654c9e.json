{
  "id": "3256bccc88654c9e",
  "timestamp": "2025-08-19T21:56:55.161327",
  "metadata": {
    "role": "tool",
    "round": 62,
    "importance": null
  },
  "views": {
    "FULL": {
      "content": {
        "role": "tool",
        "tool_call_id": "call_fbc116456b8146c1beb46884",
        "name": "read_file",
        "content": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - 完全集成记忆系统版本\n通用的ReAct (Reasoning + Acting) Agent框架\n支持任何OpenRouter兼容的LLM模型\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, MemoryMode\n\nclass ReactAgent:\n    \"\"\"带完整记忆系统的通用React Agent\"\"\"\n    \n    def __init__(self, \n                 work_dir: str,\n                 model: str = \"qwen/qwen3-coder\",\n                 api_key: Optional[str] = None,\n                 knowledge_files: Optional[List[str]] = None,\n                 interface: str = \"\",\n                 max_rounds: int = 300,\n                 memory_mode: MemoryMode = MemoryMode.AUTO,\n                 max_context_tokens: Optional[int] = None,\n                 message_hooks: Optional[List] = None):\n        \"\"\"\n        初始化React Agent with Memory\n        \n        Args:\n            work_dir: 工作目录\n            model: 模型名称\n            api_key: OpenRouter API密钥\n            knowledge_files: 知识文件列表\n            interface: Agent接口描述\n            max_rounds: 最大执行轮数\n            memory_mode: 记忆模式（AUTO会自动选择最佳模式）\n            max_context_tokens: 最大上下文tokens（None时自动检测）\n            message_hooks: 消息钩子列表，用于拦截和处理消息流\n        \"\"\"\n        self.work_dir = Path(work_dir)\n        self.work_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.model = model\n        self.api_key = api_key or os.getenv(\"OPENROUTER_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"OPENROUTER_API_KEY not set\")\n            \n        self.base_url = \"https://openrouter.ai/api/v1\"\n        self.knowledge_files = knowledge_files or []\n        self.interface = interface\n        self.max_rounds = max_rounds\n        \n        # 自动检测模型的上下文大小\n        if max_context_tokens is None:\n            max_context_tokens = self._detect_context_size()\n        \n        # 初始化记忆管理器（核心功能）\n        self.memory = MemoryManager(\n            work_dir=str(self.work_dir),\n            mode=memory_mode,\n            max_context_tokens=max_context_tokens,\n            enable_cache=True\n        )\n        \n        # 加载知识文件\n        self.knowledge = self._load_knowledge()\n        \n        # 定义工具\n        self.tools = self._define_tools()\n        \n        # 执行统计\n        self.stats = {\n            \"total_rounds\": 0,\n            \"tool_calls\": {},\n            \"files_created\": [],\n            \"files_read\": []\n        }\n        \n        # 消息钩子系统\n        self.message_hooks = message_hooks or []\n    \n    def _detect_context_size(self) -> int:\n        \"\"\"根据模型自动检测上下文大小\"\"\"\n        context_sizes = {\n            \"qwen/qwen3-coder\": 262144,           # 262k\n            \"qwen/qwen-2.5-coder-32b-instruct\": 131072,  # 131k\n            \"qwen/qwq-32b-preview\": 32768,        # 32k\n            \"qwen/qwen-2-72b-instruct\": 131072,   # 131k\n        }\n        return context_sizes.get(self.model, 32768)  # 默认32k\n    \n    def _load_knowledge(self) -> str:\n        \"\"\"加载知识文件\"\"\"\n        knowledge_content = []\n        \n        for file_path in self.knowledge_files:\n            if os.path.exists(file_path):\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                    knowledge_content.append(f\"# 知识文件: {file_path}\\n{content}\\n\")\n        \n        return \"\\n\".join(knowledge_content)\n    \n    def _define_tools(self) -> List[Dict]:\n        \"\"\"定义工具列表（OpenAI格式）\"\"\"\n        return [\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"read_file\",\n                    \"description\": \"读取文件内容\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"文件路径\"\n                            }\n                        },\n                        \"required\": [\"file_path\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"write_file\",\n                    \"description\": \"写入文件内容（覆盖原文件）。content不能超过8000字符\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"文件路径\"\n                            },\n                            \"content\": {\n                                \"type\": \"string\",\n                                \"description\": \"文件内容\"\n                            }\n                        },\n                        \"required\": [\"file_path\", \"content\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"append_file\",\n                    \"description\": \"追加内容到文件末尾。content不能超过6000字符\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"file_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"文件路径\"\n                            },\n                            \"content\": {\n                                \"type\": \"string\",\n                                \"description\": \"要追加的内容\"\n                            }\n                        },\n                        \"required\": [\"file_path\", \"content\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"list_directory\",\n                    \"description\": \"列出目录内容\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"directory_path\": {\n                                \"type\": \"string\",\n                                \"description\": \"目录路径\"\n                            }\n                        },\n                        \"required\": [\"directory_path\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"execute_command\",\n                    \"description\": \"执行Shell命令\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"command\": {\n                                \"type\": \"string\",\n                                \"description\": \"要执行的命令\"\n                            }\n                        },\n                        \"required\": [\"command\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"execute_python\",\n                    \"description\": \"执行Python代码\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"code\": {\n                                \"type\": \"string\",\n                                \"description\": \"要执行的Python代码\"\n                            }\n                        },\n                        \"required\": [\"code\"]\n                    }\n                }\n            },\n            {\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"search_memory\",\n                    \"description\": \"搜索记忆系统\",\n                    \"parameters\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"query\": {\n                                \"type\": \"string\",\n                                \"description\": \"搜索查询\"\n                            }\n                        },\n                        \"required\": [\"query\"]\n                    }\n                }\n            }\n        ]\n    \n    def _execute_tool(self, tool_name: str, arguments: Dict) -> str:\n        \"\"\"执行工具并自动记录到记忆\"\"\"\n        \n        # 更新统计\n        self.stats[\"tool_calls\"][tool_name] = self.stats[\"tool_calls\"].get(tool_name, 0) + 1\n        \n        try:\n            if tool_name == \"read_file\":\n                file_path = arguments[\"file_path\"]\n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                if os.path.exists(abs_path):\n                    with open(abs_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                    \n                    # 自动记录到记忆\n                    self.memory.open_file(file_path, content)\n                    self.stats[\"files_read\"].append(file_path)\n                    \n                    return content\n                else:\n                    return f\"文件不存在: {file_path}\"\n            \n            elif tool_name == \"write_file\":\n                file_path = arguments[\"file_path\"]\n                content = arguments[\"content\"]\n                \n                if len(content) > 8000:\n                    return f\"错误：内容超过8000字符限制（{len(content)}字符）\"\n                \n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                os.makedirs(os.path.dirname(abs_path), exist_ok=True)\n                with open(abs_path, 'w', encoding='utf-8') as f:\n                    f.write(content)\n                \n                # 自动记录到记忆\n                self.memory.open_file(file_path, content)\n                self.stats[\"files_created\"].append(file_path)\n                \n                return f\"成功写入文件: {file_path}\"\n            \n            elif tool_name == \"append_file\":\n                file_path = arguments[\"file_path\"]\n                content = arguments[\"content\"]\n                \n                if len(content) > 6000:\n                    return f\"错误：内容超过6000字符限制（{len(content)}字符）\"\n                \n                abs_path = os.path.join(self.work_dir, file_path) if not os.path.isabs(file_path) else file_path\n                \n                # 读取现有内容\n                existing_content = \"\"\n                if os.path.exists(abs_path):\n                    with open(abs_path, 'r', encoding='utf-8') as f:\n                        existing_content = f.read()\n                \n                # 追加内容\n                with open(abs_path, 'a', encoding='utf-8') as f:\n                    f.write(content)\n                \n                # 更新记忆\n                full_content = existing_content + content\n                self.memory.open_file(file_path, full_content)\n                \n                return f\"成功追加到文件: {file_path}\"\n            \n            elif tool_name == \"list_directory\":\n                directory_path = arguments[\"directory_path\"]\n                abs_path = os.path.join(self.work_dir, directory_path) if not os.path.isabs(directory_path) else directory_path\n                \n                if os.path.exists(abs_path) and os.path.isdir(abs_path):\n                    items = os.listdir(abs_path)\n                    return \"\\n\".join(items) if items else \"目录为空\"\n                else:\n                    return f\"目录不存在: {directory_path}\"\n            \n            elif tool_name == \"execute_command\":\n                import subprocess\n                command = arguments[\"command\"]\n                \n                result = subprocess.run(\n                    command,\n                    shell=True,\n                    capture_output=True,\n                    text=True,\n                    cwd=self.work_dir,\n                    timeout=30\n                )\n                \n                output = result.stdout\n                if result.stderr:\n                    output += f\"\\n错误输出:\\n{result.stderr}\"\n                \n                return output if output else \"命令执行成功（无输出）\"\n            \n            elif tool_name == \"execute_python\":\n                import subprocess\n                code = arguments[\"code\"]\n                \n                result = subprocess.run(\n                    [\"python\", \"-c\", code],\n                    capture_output=True,\n                    text=True,\n                    cwd=self.work_dir,\n                    timeout=30\n                )\n                \n                output = result.stdout\n                if result.stderr:\n                    output += f\"\\n错误输出:\\n{result.stderr}\"\n                \n                return output if output else \"代码执行成功（无输出）\"\n            \n            elif tool_name == \"search_memory\":\n                query = arguments[\"query\"]\n                results = self.memory.search(query)\n                \n                if results:\n                    formatted = []\n                    for r in results[:5]:  # 最多返回5个结果\n                        formatted.append(f\"- {r.get('type', 'unknown')}: {r.get('path', r.get('id', ''))}\")\n                    return \"搜索结果:\\n\" + \"\\n\".join(formatted)\n                else:\n                    return \"未找到相关内容\"\n            \n            else:\n                return f\"未知工具: {tool_name}\"\n                \n        except Exception as e:\n            return f\"工具执行错误: {str(e)}\"\n        \n        finally:\n            # 记录工具调用事件\n            self.memory.save_episode(\n                event=f\"tool_{tool_name}\",\n                data={\n                    \"tool\": tool_name,\n                    \"arguments\": arguments,\n                    \"round\": self.stats[\"total_rounds\"]\n                }\n            )\n    \n    def execute_task(self, task: str) -> str:\n        \"\"\"执行任务\"\"\"\n        print(f\"\\n[ReactAgent] 执行任务...\")\n        print(f\"📝 任务: {task[:100]}...\" if len(task) > 100 else f\"📝 任务: {task}\")\n        \n        # 记录任务开始\n        self.memory.save_episode(\n            event=\"task_start\",\n            data={\"task\": task[:500], \"timestamp\": datetime.now().isoformat()}\n        )\n        \n        # 构建初始消息\n        messages = [\n            {\"role\": \"system\", \"content\": self._build_system_prompt()},\n            {\"role\": \"user\", \"content\": task}\n        ]\n        \n        # 执行轮数循环\n        for round_num in range(self.max_rounds):\n            self.stats[\"total_rounds\"] = round_num + 1\n            \n            print(f\"\\n🤔 思考第{round_num + 1}轮...\")\n            \n            # 检查是否需要优化消息历史\n            if self.memory.should_optimize(round_num, len(messages)):\n                print(f\"🔄 优化消息历史...\")\n                messages = self.memory.optimize_message_history(messages)\n            \n            # 添加消息到过程记忆\n            if round_num > 0:\n                for msg in messages[-2:]:  # 添加最新的消息\n                    self.memory.add_message(msg)\n            \n            # 调用API\n            response = self._call_api(messages)\n            \n            if response is None:\n                return \"API调用失败\"\n            \n            # 处理响应\n            message = response[\"choices\"][0][\"message\"]\n            messages.append(message)\n            \n            # 调用消息钩子\n            self._call_hooks(\"assistant\", message)\n            \n            # 处理工具调用\n            if \"tool_calls\" in message and message[\"tool_calls\"]:\n                for tool_call in message[\"tool_calls\"]:\n                    tool_name = tool_call[\"function\"][\"name\"]\n                    \n                    try:\n                        arguments = json.loads(tool_call[\"function\"][\"arguments\"])\n                    except json.JSONDecodeError:\n                        arguments = None\n                    \n                    if arguments is None:\n                        tool_result = f\"参数解析失败\"\n                    else:\n                        print(f\"🔧 调用工具: {tool_name}\")\n                        tool_result = self._execute_tool(tool_name, arguments)\n                        \n                        # 显示结果预览\n                        preview = tool_result[:200] + \"...\" if len(tool_result) > 200 else tool_result\n                        print(f\"   → {preview}\")\n                    \n                    # 添加工具结果\n                    tool_message = {\n                        \"role\": \"tool\",\n                        \"tool_call_id\": tool_call[\"id\"],\n                        \"name\": tool_name,\n                        \"content\": tool_result\n                    }\n                    messages.append(tool_message)\n                    self.memory.add_message(tool_message)\n                    \n                    # 调用消息钩子\n                    self._call_hooks(\"tool\", tool_message)\n            \n            # 检查是否完成\n            if response[\"choices\"][0].get(\"finish_reason\") == \"stop\" and not message.get(\"tool_calls\"):\n                print(f\"\\n✅ 任务完成（第{round_num + 1}轮）\")\n                \n                # 记录任务完成\n                self.memory.save_episode(\n                    event=\"task_complete\",\n                    data={\n                        \"rounds\": round_num + 1,\n                        \"result_preview\": message[\"content\"][:500] if message.get(\"content\") else \"\",\n                        \"files_created\": self.stats[\"files_created\"],\n                        \"files_read\": self.stats[\"files_read\"]\n                    }\n                )\n                \n                # 保存最终状态\n                self.memory.save_state(\n                    state_name=\"task_completion\",\n                    state_data={\n                        \"task\": task[:500],\n                        \"rounds\": round_num + 1,\n                        \"stats\": self.stats\n                    }\n                )\n                \n                return message.get(\"content\", \"任务完成\")\n        \n        print(f\"\\n⚠️ 达到最大执行轮数 ({self.max_rounds}轮)\")\n        \n        # 记录超时\n        self.memory.save_episode(\n            event=\"task_timeout\",\n            data={\"rounds\": self.max_rounds}\n        )\n        \n        return messages[-1].get(\"content\", \"达到最大执行轮数\") if messages else \"任务未完成\"\n    \n    def _build_system_prompt(self) -> str:\n        \"\"\"构建系统提示词（包含记忆状态）\"\"\"\n        \n        # 获取记忆上下文\n        memory_context = self.memory.get_memory_context(extra_tokens=5000)\n        \n        prompt = f\"\"\"你是Qwen Coder，一个专业的编程助手，配备了高性能记忆系统。\n\n{self.interface}\n\n# 知识库\n{self.knowledge}\n\n# 工作目录\n{self.work_dir}\n\n# 当前记忆状态\n{memory_context if memory_context else \"（空）\"}\n\n# 执行纪律\n1. 所有文件操作都会自动记录到记忆系统\n2. 可以使用search_memory工具搜索历史\n3. 复杂任务请分步骤执行\n4. 遇到错误时记录并尝试修复\n\n# 内容长度限制\n- write_file: content最多8000字符\n- append_file: content最多6000字符\n- 长内容必须分段处理\n\n# 核心优势\n- 代码生成能力极强\n- 深度推理能力\n- 配备高性能记忆系统\n- 支持超长上下文（{self.memory.max_context_tokens:,} tokens）\n\"\"\"\n        return prompt\n    \n    def _call_api(self, messages: List[Dict]) -> Optional[Dict]:\n        \"\"\"调用OpenRouter API\"\"\"\n        try:\n            request_body = {\n                \"model\": self.model,\n                \"messages\": messages,\n                \"temperature\": 0.3,\n                \"max_tokens\": 8192\n            }\n            \n            if self.tools:\n                request_body[\"tools\"] = self.tools\n                request_body[\"tool_choice\"] = \"auto\"\n            \n            response = requests.post(\n                f\"{self.base_url}/chat/completions\",\n                headers={\n                    \"Authorization\": f\"Bearer {self.api_key}\",\n                    \"Content-Type\": \"application/json\",\n                    \"HTTP-Referer\": \"https://github.com/qwen-agent\",\n                    \"X-Title\": \"React Agent with Integrated Memory\"\n                },\n                json=request_body,\n                timeout=60\n            )\n            \n            if response.status_code != 200:\n                print(f\"❌ API错误: {response.text}\")\n                return None\n            \n            result = response.json()\n            \n            if \"error\" in result:\n                print(f\"❌ API返回错误: {result['error']}\")\n                return None\n            \n            return result\n            \n        except Exception as e:\n            print(f\"❌ API调用异常: {e}\")\n            return None\n    \n    def get_status(self) -> Dict:\n        \"\"\"获取Agent状态\"\"\"\n        return {\n            \"stats\": self.stats,\n            \"memory\": self.memory.get_status()\n        }\n    \n    def _call_hooks(self, message_type: str, message: Dict):\n        \"\"\"调用所有注册的消息钩子\"\"\"\n        for hook in self.message_hooks:\n            try:\n                hook(self, message_type, message)\n            except Exception as e:\n                print(f\"⚠️ 钩子执行错误: {e}\")\n    \n    def add_hook(self, hook):\n        \"\"\"添加消息钩子\"\"\"\n        if hook not in self.message_hooks:\n            self.message_hooks.append(hook)\n    \n    def remove_hook(self, hook):\n        \"\"\"移除消息钩子\"\"\"\n        if hook in self.message_hooks:\n            self.message_hooks.remove(hook)\n    \n    def cleanup(self):\n        \"\"\"清理资源\"\"\"\n        print(\"🧹 清理资源...\")\n        self.memory.cleanup()\n        print(\"✅ 清理完成\")"
      },
      "tokens": 6660,
      "generated_at": "2025-08-19T21:56:55.161732"
    },
    "MINIMAL": {
      "content": {
        "marker": "[tool:result]"
      },
      "tokens": 5,
      "generated_at": "2025-08-19T21:56:55.161748"
    },
    "HIGH": {
      "content": {
        "role": "tool",
        "content": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - 完全集成记忆系统版本\n通用的ReAct (Reasoning + Acting) Agent框架\n支持任何OpenRouter兼容的LLM模型\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, MemoryMode\n\nclass ReactAgent:\n    \"\"\"带完整记忆系统的通用React Agent\"\"\"\n    \n    def __init__(self, \n                 work_dir: str,\n                 model: str = \"qwen/qwen3-coder\",\n                 api_key: Optional[str] = None,\n                 knowledge_files: Optional[List[str]] = None,\n                 \n...[部分内容省略]...\n hook in self.message_hooks:\n            self.message_hooks.remove(hook)\n    \n    def cleanup(self):\n        \"\"\"清理资源\"\"\"\n        print(\"🧹 清理资源...\")\n        self.memory.cleanup()\n        print(\"✅ 清理完成\")"
      },
      "tokens": 295,
      "generated_at": "2025-08-19T21:56:55.162217"
    },
    "MEDIUM": {
      "content": {
        "role": "tool",
        "content_preview": "#!/usr/bin/env python3\n\"\"\"\nReact Agent - 完全集成记忆系统版本\n通用的ReAct (Reasoning + Acting) Agent框架\n支持任何OpenRouter兼容的LLM模型\n\"\"\"\n\nimport os\nimport json\nimport requests\nfrom typing import List, Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom .memory_manager import MemoryManager, ..."
      },
      "tokens": 120,
      "generated_at": "2025-08-19T21:56:55.162250"
    },
    "LOW": {
      "content": {
        "role": "tool",
        "summary": "工具执行出错"
      },
      "tokens": 16,
      "generated_at": "2025-08-19T21:56:55.162553"
    }
  }
}