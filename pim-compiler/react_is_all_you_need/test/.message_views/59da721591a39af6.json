{
  "id": "59da721591a39af6",
  "timestamp": "2025-08-19T21:57:04.084098",
  "metadata": {
    "role": "tool",
    "round": 68,
    "importance": null
  },
  "views": {
    "FULL": {
      "content": {
        "role": "tool",
        "tool_call_id": "call_2f68d2d557fa5843",
        "name": "read_file",
        "content": "#!/usr/bin/env python3\n\"\"\"\n异步记忆处理器 - 预计算多清晰度视图\n\n设计理念：\n- 每条消息预先生成多个清晰度级别的视图\n- 使用时直接选择合适的视图，无需实时压缩\n- 后台异步更新，不阻塞主流程\n\"\"\"\n\nimport json\nimport hashlib\nimport asyncio\nimport threading\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom datetime import datetime\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom concurrent.futures import ThreadPoolExecutor\nfrom pathlib import Path\n\nclass ClarityLevel(Enum):\n    \"\"\"预定义的清晰度级别\"\"\"\n    FULL = 1.0      # 完整视图\n    HIGH = 0.7      # 高清晰度视图\n    MEDIUM = 0.5    # 中等清晰度视图\n    LOW = 0.3       # 低清晰度视图\n    MINIMAL = 0.1   # 最小视图\n\n@dataclass\nclass MessageView:\n    \"\"\"消息的某个清晰度视图\"\"\"\n    clarity: ClarityLevel\n    content: Dict\n    tokens: int\n    generated_at: datetime\n    \nclass MultiViewMessage:\n    \"\"\"具有多个预计算视图的消息\"\"\"\n    \n    def __init__(self, original_message: Dict, message_id: str = None):\n        \"\"\"\n        初始化多视图消息\n        \n        Args:\n            original_message: 原始消息\n            message_id: 消息ID（可选）\n        \"\"\"\n        self.id = message_id or self._generate_id(original_message)\n        self.original = original_message\n        self.timestamp = datetime.now()\n        self.views: Dict[ClarityLevel, MessageView] = {}\n        self.metadata = {\n            \"role\": original_message.get(\"role\"),\n            \"round\": None,  # 将在添加到历史时设置\n            \"importance\": None  # 将在分析时设置\n        }\n    \n    def _generate_id(self, message: Dict) -> str:\n        \"\"\"生成消息ID\"\"\"\n        content = json.dumps(message, sort_keys=True)\n        return hashlib.md5(content.encode()).hexdigest()[:16]\n    \n    def get_view(self, clarity: ClarityLevel) -> Optional[MessageView]:\n        \"\"\"获取指定清晰度的视图\"\"\"\n        return self.views.get(clarity)\n    \n    def get_best_view(self, max_tokens: int) -> Optional[MessageView]:\n        \"\"\"获取不超过token限制的最佳视图\"\"\"\n        # 从高到低尝试\n        for clarity in [ClarityLevel.FULL, ClarityLevel.HIGH, \n                       ClarityLevel.MEDIUM, ClarityLevel.LOW, ClarityLevel.MINIMAL]:\n            view = self.views.get(clarity)\n            if view and view.tokens <= max_tokens:\n                return view\n        return self.views.get(ClarityLevel.MINIMAL)  # 返回最小视图\n\nclass AsyncMemoryProcessor:\n    \"\"\"异步记忆处理器\"\"\"\n    \n    def __init__(self, cache_dir: Optional[Path] = None, max_workers: int = 4):\n        \"\"\"\n        初始化异步处理器\n        \n        Args:\n            cache_dir: 缓存目录（用于持久化视图）\n            max_workers: 最大工作线程数\n        \"\"\"\n        self.cache_dir = cache_dir\n        if cache_dir:\n            cache_dir.mkdir(parents=True, exist_ok=True)\n            \n        # 线程池执行器\n        self.executor = ThreadPoolExecutor(max_workers=max_workers)\n        \n        # 消息存储\n        self.messages: List[MultiViewMessage] = []\n        self.message_index: Dict[str, MultiViewMessage] = {}\n        \n        # 预计算队列\n        self.precompute_queue = asyncio.Queue() if asyncio.get_event_loop().is_running() else None\n        \n        # 视图生成策略\n        self.view_generators = {\n            ClarityLevel.FULL: self._generate_full_view,\n            ClarityLevel.HIGH: self._generate_high_clarity_view,\n            ClarityLevel.MEDIUM: self._generate_medium_clarity_view,\n            ClarityLevel.LOW: self._generate_low_clarity_view,\n            ClarityLevel.MINIMAL: self._generate_minimal_view\n        }\n    \n    def add_message(self, message: Dict, importance: str = \"MEDIUM\") -> MultiViewMessage:\n        \"\"\"\n        添加消息并触发异步预计算\n        \n        Args:\n            message: 原始消息\n            importance: 重要性级别\n            \n        Returns:\n            多视图消息对象\n        \"\"\"\n        # 创建多视图消息\n        multi_view_msg = MultiViewMessage(message)\n        multi_view_msg.metadata[\"importance\"] = importance\n        multi_view_msg.metadata[\"round\"] = len(self.messages)\n        \n        # 添加到存储\n        self.messages.append(multi_view_msg)\n        self.message_index[multi_view_msg.id] = multi_view_msg\n        \n        # 立即生成FULL和MINIMAL视图（同步）\n        multi_view_msg.views[ClarityLevel.FULL] = self._generate_full_view(message)\n        multi_view_msg.views[ClarityLevel.MINIMAL] = self._generate_minimal_view(message)\n        \n        # 异步生成其他视图\n        self.executor.submit(self._precompute_views_async, multi_view_msg)\n        \n        return multi_view_msg\n    \n    def _precompute_views_async(self, multi_view_msg: MultiViewMessage):\n        \"\"\"异步预计算所有视图\"\"\"\n        try:\n            # 生成中间清晰度的视图\n            for clarity in [ClarityLevel.HIGH, ClarityLevel.MEDIUM, ClarityLevel.LOW]:\n                if clarity not in multi_view_msg.views:\n                    generator = self.view_generators[clarity]\n                    view = generator(multi_view_msg.original)\n                    multi_view_msg.views[clarity] = view\n            \n            # 如果有缓存目录，持久化视图\n            if self.cache_dir:\n                self._cache_views(multi_view_msg)\n                \n        except Exception as e:\n            print(f\"预计算视图失败: {e}\")\n    \n    def _generate_full_view(self, message: Dict) -> MessageView:\n        \"\"\"生成完整视图\"\"\"\n        return MessageView(\n            clarity=ClarityLevel.FULL,\n            content=message,\n            tokens=self._estimate_tokens(json.dumps(message)),\n            generated_at=datetime.now()\n        )\n    \n    def _generate_high_clarity_view(self, message: Dict) -> MessageView:\n        \"\"\"生成高清晰度视图（70%）\"\"\"\n        view_content = {\"role\": message.get(\"role\")}\n        \n        if message.get(\"content\"):\n            content = message[\"content\"]\n            if len(content) > 1000:\n                # 保留前600字符和后200字符\n                view_content[\"content\"] = content[:600] + \"\\n...[部分内容省略]...\\n\" + content[-200:]\n            else:\n                view_content[\"content\"] = content\n        \n        # 工具调用保留主要信息\n        if \"tool_calls\" in message:\n            view_content[\"tool_calls_summary\"] = [\n                {\"name\": call[\"function\"][\"name\"], \n                 \"args_preview\": str(call[\"function\"].get(\"arguments\", \"\"))[:50]}\n                for call in message[\"tool_calls\"]\n            ]\n        \n        return MessageView(\n            clarity=ClarityLevel.HIGH,\n            content=view_content,\n            tokens=self._estimate_tokens(json.dumps(view_content)),\n            generated_at=datetime.now()\n        )\n    \n    def _generate_medium_clarity_view(self, message: Dict) -> MessageView:\n        \"\"\"生成中等清晰度视图（50%）\"\"\"\n        view_content = {\"role\": message.get(\"role\")}\n        \n        if message.get(\"content\"):\n            content = message[\"content\"]\n            # 只保留前300字符\n            view_content[\"content_preview\"] = content[:300] + (\"...\" if len(content) > 300 else \"\")\n        \n        # 工具调用只保留名称\n        if \"tool_calls\" in message:\n            view_content[\"tools_used\"] = [\n                call[\"function\"][\"name\"] for call in message[\"tool_calls\"]\n            ]\n        \n        return MessageView(\n            clarity=ClarityLevel.MEDIUM,\n            content=view_content,\n            tokens=self._estimate_tokens(json.dumps(view_content)),\n            generated_at=datetime.now()\n        )\n    \n    def _generate_low_clarity_view(self, message: Dict) -> MessageView:\n        \"\"\"生成低清晰度视图（30%）\"\"\"\n        # 生成一句话摘要\n        summary = self._generate_summary(message)\n        \n        view_content = {\n            \"role\": message.get(\"role\"),\n            \"summary\": summary\n        }\n        \n        return MessageView(\n            clarity=ClarityLevel.LOW,\n            content=view_content,\n            tokens=self._estimate_tokens(json.dumps(view_content)),\n            generated_at=datetime.now()\n        )\n    \n    def _generate_minimal_view(self, message: Dict) -> MessageView:\n        \"\"\"生成最小视图（10%）\"\"\"\n        # 极简标记\n        role = message.get(\"role\", \"\")\n        \n        if role == \"assistant\" and \"tool_calls\" in message:\n            marker = f\"[{role}:tools]\"\n        elif role == \"tool\":\n            marker = f\"[{role}:result]\"\n        else:\n            marker = f\"[{role}]\"\n        \n        view_content = {\"marker\": marker}\n        \n        return MessageView(\n            clarity=ClarityLevel.MINIMAL,\n            content=view_content,\n            tokens=5,  # 固定的极小token数\n            generated_at=datetime.now()\n        )\n    \n    def _generate_summary(self, message: Dict) -> str:\n        \"\"\"生成消息摘要\"\"\"\n        role = message.get(\"role\", \"\")\n        \n        if role == \"assistant\" and \"tool_calls\" in message:\n            tools = [call[\"function\"][\"name\"] for call in message[\"tool_calls\"]]\n            return f\"调用了{len(tools)}个工具: {', '.join(tools[:3])}\"\n        \n        elif role == \"tool\":\n            content = message.get(\"content\", \"\")\n            if \"error\" in content.lower():\n                return \"工具执行出错\"\n            elif \"success\" in content.lower() or \"成功\" in content:\n                return \"工具执行成功\"\n            else:\n                return \"工具返回结果\"\n        \n        elif message.get(\"content\"):\n            content = message[\"content\"]\n            return content[:100] + (\"...\" if len(content) > 100 else \"\")\n        \n        return f\"{role}消息\"\n    \n    def _estimate_tokens(self, text: str) -> int:\n        \"\"\"估算token数\"\"\"\n        return len(text) // 4\n    \n    def _cache_views(self, multi_view_msg: MultiViewMessage):\n        \"\"\"缓存视图到磁盘\"\"\"\n        if not self.cache_dir:\n            return\n        \n        cache_file = self.cache_dir / f\"{multi_view_msg.id}.json\"\n        cache_data = {\n            \"id\": multi_view_msg.id,\n            \"timestamp\": multi_view_msg.timestamp.isoformat(),\n            \"metadata\": multi_view_msg.metadata,\n            \"views\": {\n                clarity.name: {\n                    \"content\": view.content,\n                    \"tokens\": view.tokens,\n                    \"generated_at\": view.generated_at.isoformat()\n                }\n                for clarity, view in multi_view_msg.views.items()\n            }\n        }\n        \n        with open(cache_file, 'w', encoding='utf-8') as f:\n            json.dump(cache_data, f, ensure_ascii=False, indent=2)\n    \n    def load_cached_views(self, message_id: str) -> Optional[MultiViewMessage]:\n        \"\"\"从缓存加载视图\"\"\"\n        if not self.cache_dir:\n            return None\n        \n        cache_file = self.cache_dir / f\"{message_id}.json\"\n        if not cache_file.exists():\n            return None\n        \n        try:\n            with open(cache_file, 'r', encoding='utf-8') as f:\n                cache_data = json.load(f)\n            \n            # 重建MultiViewMessage\n            # 这里简化处理，实际需要完整恢复\n            return None  # TODO: 实现缓存恢复\n            \n        except Exception as e:\n            print(f\"加载缓存失败: {e}\")\n            return None\n    \n    def get_optimized_history(self, \n                             max_tokens: int = 200000,\n                             time_decay: bool = True) -> List[Dict]:\n        \"\"\"\n        获取优化后的历史消息\n        \n        Args:\n            max_tokens: 最大token限制\n            time_decay: 是否应用时间衰减\n            \n        Returns:\n            优化后的消息列表\n        \"\"\"\n        optimized = []\n        used_tokens = 0\n        \n        # 从最新到最旧遍历\n        for i, multi_msg in enumerate(reversed(self.messages)):\n            # 计算该消息的目标清晰度\n            if time_decay:\n                # 根据距离计算清晰度\n                distance = i\n                if distance < 10:\n                    target_clarity = ClarityLevel.FULL\n                elif distance < 50:\n                    target_clarity = ClarityLevel.HIGH\n                elif distance < 100:\n                    target_clarity = ClarityLevel.MEDIUM\n                elif distance < 200:\n                    target_clarity = ClarityLevel.LOW\n                else:\n                    target_clarity = ClarityLevel.MINIMAL\n            else:\n                target_clarity = ClarityLevel.FULL\n            \n            # 获取合适的视图\n            view = multi_msg.get_view(target_clarity)\n            if not view:\n                # 如果目标视图还未生成，降级到可用视图\n                view = multi_msg.get_best_view(max_tokens - used_tokens)\n            \n            if view and used_tokens + view.tokens <= max_tokens:\n                optimized.insert(0, view.content)  # 插入到开头保持时间顺序\n                used_tokens += view.tokens\n            elif view:\n                # 尝试使用更小的视图\n                minimal_view = multi_msg.get_view(ClarityLevel.MINIMAL)\n                if minimal_view and used_tokens + minimal_view.tokens <= max_tokens:\n                    optimized.insert(0, minimal_view.content)\n                    used_tokens += minimal_view.tokens\n                else:\n                    break  # 无法再添加更多消息\n        \n        return optimized\n    \n    def get_statistics(self) -> Dict:\n        \"\"\"获取处理统计\"\"\"\n        total_views = 0\n        completed_views = 0\n        \n        for msg in self.messages:\n            total_views += len(ClarityLevel)\n            completed_views += len(msg.views)\n        \n        return {\n            \"total_messages\": len(self.messages),\n            \"total_views\": total_views,\n            \"completed_views\": completed_views,\n            \"completion_rate\": completed_views / total_views if total_views > 0 else 0,\n            \"cache_enabled\": self.cache_dir is not None\n        }\n    \n    def cleanup(self):\n        \"\"\"清理资源\"\"\"\n        self.executor.shutdown(wait=True)\n        \n        # 清理过期缓存\n        if self.cache_dir:\n            # TODO: 实现缓存过期策略\n            pass"
      },
      "tokens": 4363,
      "generated_at": "2025-08-19T21:57:04.084346"
    },
    "MINIMAL": {
      "content": {
        "marker": "[tool:result]"
      },
      "tokens": 5,
      "generated_at": "2025-08-19T21:57:04.084365"
    },
    "HIGH": {
      "content": {
        "role": "tool",
        "content": "#!/usr/bin/env python3\n\"\"\"\n异步记忆处理器 - 预计算多清晰度视图\n\n设计理念：\n- 每条消息预先生成多个清晰度级别的视图\n- 使用时直接选择合适的视图，无需实时压缩\n- 后台异步更新，不阻塞主流程\n\"\"\"\n\nimport json\nimport hashlib\nimport asyncio\nimport threading\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom datetime import datetime\nfrom enum import Enum\nfrom dataclasses import dataclass\nfrom concurrent.futures import ThreadPoolExecutor\nfrom pathlib import Path\n\nclass ClarityLevel(Enum):\n    \"\"\"预定义的清晰度级别\"\"\"\n    FULL = 1.0      # 完整视图\n    HIGH = 0.7      # 高清晰度视图\n    MEDIUM = 0.5    # 中等清晰度视图\n    LOW = 0.3       # 低清晰度视图\n    MINIMAL = 0.1   # 最小视图\n\n@dataclass\nclass Mes\n...[部分内容省略]...\nne\n        }\n    \n    def cleanup(self):\n        \"\"\"清理资源\"\"\"\n        self.executor.shutdown(wait=True)\n        \n        # 清理过期缓存\n        if self.cache_dir:\n            # TODO: 实现缓存过期策略\n            pass"
      },
      "tokens": 390,
      "generated_at": "2025-08-19T21:57:04.084818"
    },
    "MEDIUM": {
      "content": {
        "role": "tool",
        "content_preview": "#!/usr/bin/env python3\n\"\"\"\n异步记忆处理器 - 预计算多清晰度视图\n\n设计理念：\n- 每条消息预先生成多个清晰度级别的视图\n- 使用时直接选择合适的视图，无需实时压缩\n- 后台异步更新，不阻塞主流程\n\"\"\"\n\nimport json\nimport hashlib\nimport asyncio\nimport threading\nfrom typing import Dict, List, Optional, Tuple, Any\nfrom datetime import datetime\nfrom enum import Enum\nfrom dataclasses im..."
      },
      "tokens": 180,
      "generated_at": "2025-08-19T21:57:04.084860"
    },
    "LOW": {
      "content": {
        "role": "tool",
        "summary": "工具执行出错"
      },
      "tokens": 16,
      "generated_at": "2025-08-19T21:57:04.085001"
    }
  }
}