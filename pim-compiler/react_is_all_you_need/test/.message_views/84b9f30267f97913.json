{
  "id": "84b9f30267f97913",
  "timestamp": "2025-08-19T21:57:15.188537",
  "metadata": {
    "role": "tool",
    "round": 74,
    "importance": null
  },
  "views": {
    "FULL": {
      "content": {
        "role": "tool",
        "tool_call_id": "call_220587145125426786b59207",
        "name": "read_file",
        "content": "#!/usr/bin/env python3\n\"\"\"\n过程记忆管理 - 基于时间衰减的消息压缩\n\n设计理念：\n- 时间越久的记忆，清晰度越低\n- 重要事件保持更高清晰度\n- 自动压缩和衰减\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport hashlib\n\nclass MessageImportance(Enum):\n    \"\"\"消息重要性级别\"\"\"\n    CRITICAL = 5    # 关键决策、错误修复\n    HIGH = 4        # 重要工具调用、文件创建\n    MEDIUM = 3      # 常规工具调用\n    LOW = 2         # 查询、读取操作\n    TRIVIAL = 1     # 思考过程、中间步骤\n\nclass TimeResolution(Enum):\n    \"\"\"时间分辨率 - 距离现在越远，分辨率越低\"\"\"\n    IMMEDIATE = 5   # 最近10轮 - 完整保留\n    RECENT = 4      # 最近50轮 - 轻度压缩\n    NEAR = 3        # 最近100轮 - 中度压缩\n    FAR = 2         # 最近200轮 - 重度压缩\n    DISTANT = 1     # 200轮以前 - 仅保留摘要\n\nclass ProcessMemory:\n    \"\"\"过程记忆管理器\"\"\"\n    \n    def __init__(self, max_context_tokens: int = 262144):\n        \"\"\"\n        初始化过程记忆\n        \n        Args:\n            max_context_tokens: 最大上下文tokens\n        \"\"\"\n        self.max_tokens = max_context_tokens\n        \n        # 时间衰减配置\n        self.time_thresholds = {\n            TimeResolution.IMMEDIATE: 10,    # 最近10轮\n            TimeResolution.RECENT: 50,       # 最近50轮\n            TimeResolution.NEAR: 100,        # 最近100轮\n            TimeResolution.FAR: 200,         # 最近200轮\n            TimeResolution.DISTANT: float('inf')  # 更早\n        }\n        \n        # 分辨率对应的信息清晰度\n        self.clarity_levels = {\n            TimeResolution.IMMEDIATE: 1.0,    # 100%清晰度\n            TimeResolution.RECENT: 0.7,       # 70%清晰度\n            TimeResolution.NEAR: 0.4,         # 40%清晰度\n            TimeResolution.FAR: 0.2,          # 20%清晰度\n            TimeResolution.DISTANT: 0.05      # 5%清晰度（仅摘要）\n        }\n        \n        # 重要性对清晰度的调整系数\n        self.importance_modifiers = {\n            MessageImportance.CRITICAL: 2.0,   # 双倍清晰度\n            MessageImportance.HIGH: 1.5,       # 1.5倍清晰度\n            MessageImportance.MEDIUM: 1.0,     # 标准清晰度\n            MessageImportance.LOW: 0.7,        # 降低清晰度\n            MessageImportance.TRIVIAL: 0.3     # 最低清晰度\n        }\n        \n        # 压缩历史\n        self.compression_history = []\n    \n    def classify_message_importance(self, message: Dict) -> MessageImportance:\n        \"\"\"\n        判断消息重要性\n        \n        Args:\n            message: 消息字典\n            \n        Returns:\n            重要性级别\n        \"\"\"\n        role = message.get(\"role\", \"\")\n        content = message.get(\"content\", \"\")\n        \n        # 工具调用的重要性分析\n        if role == \"assistant\" and \"tool_calls\" in message:\n            tool_calls = message[\"tool_calls\"]\n            for call in tool_calls:\n                tool_name = call[\"function\"][\"name\"]\n                \n                # 关键操作\n                if tool_name in [\"write_file\", \"execute_python\", \"execute_command\"]:\n                    return MessageImportance.HIGH\n                \n                # 读取操作\n                elif tool_name in [\"read_file\", \"list_directory\"]:\n                    return MessageImportance.LOW\n                \n                # 文件追加\n                elif tool_name == \"append_file\":\n                    return MessageImportance.MEDIUM\n        \n        # 工具结果的重要性\n        elif role == \"tool\":\n            # 错误结果更重要\n            if \"错误\" in content or \"error\" in content.lower() or \"失败\" in content:\n                return MessageImportance.CRITICAL\n            \n            # 成功的写入操作\n            elif \"成功\" in content and (\"写入\" in content or \"创建\" in content):\n                return MessageImportance.HIGH\n            \n            # 普通结果\n            else:\n                return MessageImportance.MEDIUM\n        \n        # 用户消息\n        elif role == \"user\":\n            # 任务描述通常很重要\n            if len(content) > 200:  # 长任务描述\n                return MessageImportance.HIGH\n            else:\n                return MessageImportance.MEDIUM\n        \n        # 系统消息\n        elif role == \"system\":\n            return MessageImportance.HIGH\n        \n        # 助手思考过程\n        else:\n            if len(content) < 100:\n                return MessageImportance.TRIVIAL\n            else:\n                return MessageImportance.LOW\n    \n    def get_time_resolution(self, round_index: int, current_round: int) -> TimeResolution:\n        \"\"\"\n        根据时间距离确定分辨率\n        \n        Args:\n            round_index: 消息所在轮次\n            current_round: 当前轮次\n            \n        Returns:\n            时间分辨率级别\n        \"\"\"\n        distance = current_round - round_index\n        \n        for resolution in TimeResolution:\n            if distance <= self.time_thresholds[resolution]:\n                return resolution\n        \n        return TimeResolution.DISTANT\n    \n    def compress_message(self, \n                        message: Dict, \n                        importance: MessageImportance,\n                        resolution: TimeResolution) -> Optional[Dict]:\n        \"\"\"\n        根据信息清晰度压缩消息\n        \n        Args:\n            message: 原始消息\n            importance: 重要性级别\n            resolution: 时间分辨率\n            \n        Returns:\n            压缩后的消息或None（完全模糊）\n        \"\"\"\n        # 计算信息清晰度\n        base_clarity = self.clarity_levels[resolution]\n        importance_modifier = self.importance_modifiers[importance]\n        info_clarity = min(1.0, base_clarity * importance_modifier)\n        \n        # 系统消息和初始用户消息始终保持完全清晰\n        if message.get(\"role\") == \"system\" or \\\n           (message.get(\"role\") == \"user\" and message.get(\"is_initial\")):\n            return message\n        \n        # 根据信息清晰度决定呈现方式\n        if info_clarity >= 0.9:\n            # 高清晰度 - 完整信息\n            return message\n        \n        elif info_clarity >= 0.5:\n            # 中等清晰度 - 保留关键信息，模糊细节\n            compressed = {\"role\": message[\"role\"]}\n            \n            if message.get(\"content\"):\n                content = message[\"content\"]\n                # 保留核心内容，模糊边缘细节\n                if len(content) > 500:\n                    compressed[\"content\"] = content[:200] + \"\\n...[细节已模糊]...\\n\" + content[-100:]\n                else:\n                    compressed[\"content\"] = content\n            \n            # 工具调用只保留概要\n            if \"tool_calls\" in message:\n                compressed[\"tool_summary\"] = f\"调用了{len(message['tool_calls'])}个工具\"\n            \n            return compressed\n        \n        elif info_clarity >= 0.2:\n            # 低清晰度 - 仅保留要点\n            return {\n                \"role\": message[\"role\"],\n                \"summary\": self._generate_summary(message)\n            }\n        \n        elif info_clarity >= 0.05:\n            # 极低清晰度 - 单行印象\n            if importance.value >= MessageImportance.HIGH.value:\n                return {\n                    \"role\": \"summary\",\n                    \"content\": f\"[{message['role']}] {self._generate_oneline_summary(message)}\"\n                }\n        \n        # 完全模糊 - 遗忘\n        return None\n    \n    def _generate_summary(self, message: Dict) -> str:\n        \"\"\"生成消息摘要\"\"\"\n        role = message.get(\"role\", \"\")\n        \n        if role == \"assistant\" and \"tool_calls\" in message:\n            tools = [call[\"function\"][\"name\"] for call in message[\"tool_calls\"]]\n            return f\"调用工具: {', '.join(tools)}\"\n        \n        elif role == \"tool\":\n            content = message.get(\"content\", \"\")[:100]\n            return f\"工具结果: {content}...\"\n        \n        elif message.get(\"content\"):\n            content = message[\"content\"]\n            if len(content) > 100:\n                return content[:100] + \"...\"\n            return content\n        \n        return \"[空消息]\"\n    \n    def _generate_oneline_summary(self, message: Dict) -> str:\n        \"\"\"生成单行摘要\"\"\"\n        summary = self._generate_summary(message)\n        # 去除换行，限制长度\n        return summary.replace('\\n', ' ')[:50]\n    \n    def compress_messages(self, messages: List[Dict]) -> Tuple[List[Dict], Dict]:\n        \"\"\"\n        压缩消息列表\n        \n        Args:\n            messages: 原始消息列表\n            \n        Returns:\n            (压缩后的消息列表, 压缩统计)\n        \"\"\"\n        if not messages:\n            return [], {}\n        \n        compressed = []\n        stats = {\n            \"original_count\": len(messages),\n            \"compressed_count\": 0,\n            \"dropped_count\": 0,\n            \"original_tokens\": 0,\n            \"compressed_tokens\": 0,\n            \"compression_ratio\": 0\n        }\n        \n        # 识别轮次\n        current_round = sum(1 for msg in messages if msg.get(\"role\") == \"assistant\")\n        \n        # 处理每条消息\n        for i, message in enumerate(messages):\n            # 估算轮次\n            round_index = sum(1 for msg in messages[:i] if msg.get(\"role\") == \"assistant\")\n            \n            # 判断重要性和分辨率\n            importance = self.classify_message_importance(message)\n            resolution = self.get_time_resolution(round_index, current_round)\n            \n            # 压缩消息\n            compressed_msg = self.compress_message(message, importance, resolution)\n            \n            if compressed_msg:\n                compressed.append(compressed_msg)\n                stats[\"compressed_count\"] += 1\n            else:\n                stats[\"dropped_count\"] += 1\n            \n            # 统计tokens（简化估算）\n            if message.get(\"content\"):\n                stats[\"original_tokens\"] += len(message[\"content\"]) // 4\n            if compressed_msg and compressed_msg.get(\"content\"):\n                stats[\"compressed_tokens\"] += len(compressed_msg[\"content\"]) // 4\n        \n        # 计算压缩率\n        if stats[\"original_tokens\"] > 0:\n            stats[\"compression_ratio\"] = 1 - (stats[\"compressed_tokens\"] / stats[\"original_tokens\"])\n        \n        # 记录压缩历史\n        self.compression_history.append({\n            \"timestamp\": datetime.now().isoformat(),\n            \"stats\": stats\n        })\n        \n        return compressed, stats\n    \n    def batch_compress_by_time(self, messages: List[Dict]) -> List[Dict]:\n        \"\"\"\n        批量压缩历史消息 - 按时间段分组压缩\n        \n        Args:\n            messages: 原始消息列表\n            \n        Returns:\n            压缩后的消息列表\n        \"\"\"\n        if len(messages) < 20:  # 消息太少不压缩\n            return messages\n        \n        result = []\n        current_round = sum(1 for msg in messages if msg.get(\"role\") == \"assistant\")\n        \n        # 分段处理\n        segments = {\n            TimeResolution.IMMEDIATE: [],\n            TimeResolution.RECENT: [],\n            TimeResolution.NEAR: [],\n            TimeResolution.FAR: [],\n            TimeResolution.DISTANT: []\n        }\n        \n        # 将消息分配到不同时间段\n        for i, message in enumerate(messages):\n            round_index = sum(1 for msg in messages[:i] if msg.get(\"role\") == \"assistant\")\n            resolution = self.get_time_resolution(round_index, current_round)\n            segments[resolution].append((i, message))\n        \n        # 分段压缩\n        for resolution, segment_messages in segments.items():\n            if not segment_messages:\n                continue\n            \n            if resolution == TimeResolution.IMMEDIATE:\n                # 最近的消息完整保留\n                result.extend([msg for _, msg in segment_messages])\n            \n            elif resolution == TimeResolution.DISTANT:\n                # 最远的消息合并为摘要\n                if len(segment_messages) > 5:\n                    summary = self._merge_distant_messages(segment_messages)\n                    if summary:\n                        result.append(summary)\n                else:\n                    for _, msg in segment_messages:\n                        importance = self.classify_message_importance(msg)\n                        compressed = self.compress_message(msg, importance, resolution)\n                        if compressed:\n                            result.append(compressed)\n            \n            else:\n                # 中间段落正常压缩\n                for _, msg in segment_messages:\n                    importance = self.classify_message_importance(msg)\n                    compressed = self.compress_message(msg, importance, resolution)\n                    if compressed:\n                        result.append(compressed)\n        \n        return result\n    \n    def _merge_distant_messages(self, messages: List[Tuple[int, Dict]]) -> Optional[Dict]:\n        \"\"\"\n        合并远期消息为单个摘要\n        \n        Args:\n            messages: (索引, 消息)列表\n            \n        Returns:\n            合并后的摘要消息\n        \"\"\"\n        if not messages:\n            return None\n        \n        # 统计信息\n        tool_calls = []\n        important_results = []\n        errors = []\n        \n        for _, msg in messages:\n            if msg.get(\"role\") == \"assistant\" and \"tool_calls\" in msg:\n                for call in msg[\"tool_calls\"]:\n                    tool_calls.append(call[\"function\"][\"name\"])\n            \n            elif msg.get(\"role\") == \"tool\":\n                content = msg.get(\"content\", \"\")\n                if \"错误\" in content or \"error\" in content.lower():\n                    errors.append(content[:50])\n                elif \"成功\" in content and \"写入\" in content:\n                    important_results.append(content[:50])\n        \n        # 生成摘要\n        summary_parts = []\n        \n        if tool_calls:\n            tool_summary = {}\n            for tool in tool_calls:\n                tool_summary[tool] = tool_summary.get(tool, 0) + 1\n            summary_parts.append(f\"工具调用: {', '.join(f'{k}({v}次)' for k, v in tool_summary.items())}\")\n        \n        if important_results:\n            summary_parts.append(f\"重要操作: {len(important_results)}个文件操作\")\n        \n        if errors:\n            summary_parts.append(f\"错误记录: {len(errors)}个错误\")\n        \n        if summary_parts:\n            return {\n                \"role\": \"system\",\n                \"content\": f\"[历史摘要 - {len(messages)}条消息]\\n\" + \"\\n\".join(summary_parts)\n            }\n        \n        return None\n    \n    def adaptive_compress(self, \n                         messages: List[Dict], \n                         target_tokens: int = 200000) -> List[Dict]:\n        \"\"\"\n        自适应压缩 - 根据目标token数动态调整压缩强度\n        \n        Args:\n            messages: 原始消息列表\n            target_tokens: 目标token数\n            \n        Returns:\n            压缩后的消息列表\n        \"\"\"\n        # 先尝试标准压缩\n        compressed = self.batch_compress_by_time(messages)\n        \n        # 估算tokens\n        estimated_tokens = sum(\n            len(msg.get(\"content\", msg.get(\"summary\", \"\"))) // 4 \n            for msg in compressed\n        )\n        \n        # 如果还是太大，增加压缩强度\n        if estimated_tokens > target_tokens:\n            # 调整分辨率阈值，更激进地压缩\n            self.time_thresholds[TimeResolution.IMMEDIATE] = 5\n            self.time_thresholds[TimeResolution.RECENT] = 20\n            self.time_thresholds[TimeResolution.NEAR] = 50\n            \n            compressed = self.batch_compress_by_time(messages)\n            \n            # 恢复默认阈值\n            self.time_thresholds[TimeResolution.IMMEDIATE] = 10\n            self.time_thresholds[TimeResolution.RECENT] = 50\n            self.time_thresholds[TimeResolution.NEAR] = 100\n        \n        return compressed"
      },
      "tokens": 5031,
      "generated_at": "2025-08-19T21:57:15.187756"
    },
    "MINIMAL": {
      "content": {
        "marker": "[tool:result]"
      },
      "tokens": 5,
      "generated_at": "2025-08-19T21:57:15.187774"
    },
    "HIGH": {
      "content": {
        "role": "tool",
        "content": "#!/usr/bin/env python3\n\"\"\"\n过程记忆管理 - 基于时间衰减的消息压缩\n\n设计理念：\n- 时间越久的记忆，清晰度越低\n- 重要事件保持更高清晰度\n- 自动压缩和衰减\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport hashlib\n\nclass MessageImportance(Enum):\n    \"\"\"消息重要性级别\"\"\"\n    CRITICAL = 5    # 关键决策、错误修复\n    HIGH = 4        # 重要工具调用、文件创建\n    MEDIUM = 3      # 常规工具调用\n    LOW = 2         # 查询、读取操作\n    TRIVIAL = 1     # 思考过程、中间步骤\n\nclass TimeResolution(Enum):\n    \"\"\"时间分辨率 - 距离现在越远，分辨率越低\"\"\"\n    IMMEDIATE = 5   # 最近10轮 - 完整保留\n    RECENT = 4      # 最近50轮 - 轻度压缩\n    NEAR = 3        #\n...[部分内容省略]...\nme_thresholds[TimeResolution.IMMEDIATE] = 10\n            self.time_thresholds[TimeResolution.RECENT] = 50\n            self.time_thresholds[TimeResolution.NEAR] = 100\n        \n        return compressed"
      },
      "tokens": 398,
      "generated_at": "2025-08-19T21:57:15.188349"
    },
    "MEDIUM": {
      "content": {
        "role": "tool",
        "content_preview": "#!/usr/bin/env python3\n\"\"\"\n过程记忆管理 - 基于时间衰减的消息压缩\n\n设计理念：\n- 时间越久的记忆，清晰度越低\n- 重要事件保持更高清晰度\n- 自动压缩和衰减\n\"\"\"\n\nimport json\nfrom typing import List, Dict, Any, Optional, Tuple\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport hashlib\n\nclass MessageImportance(Enum):\n    \"\"\"消息重要性级别\"\"\"\n    CRIT..."
      },
      "tokens": 168,
      "generated_at": "2025-08-19T21:57:15.188368"
    },
    "LOW": {
      "content": {
        "role": "tool",
        "summary": "工具执行出错"
      },
      "tokens": 16,
      "generated_at": "2025-08-19T21:57:15.188453"
    }
  }
}