# 服务级流程调试器集成方案

## 概述

为每个由MDA生成的服务自动集成流程调试器，提供类似OpenAPI文档的调试界面。每个服务在 `/debug` 端点提供可视化的业务流程调试功能。

## 架构设计

### 1. 服务结构扩展

```
user-service/
├── app/
│   ├── __init__.py
│   ├── main.py
│   ├── models/
│   ├── api/
│   ├── services/
│   ├── core/
│   └── debug/                    # 新增调试模块
│       ├── __init__.py
│       ├── flow_debugger.py      # 流程调试器核心
│       ├── flow_models.py        # 流程模型定义
│       ├── debug_routes.py       # 调试API路由
│       ├── debug_ui.py           # UI资源服务
│       └── static/               # 调试界面静态资源
│           ├── index.html
│           ├── debugger.js
│           └── debugger.css
```

### 2. 调试器集成到FastAPI

```python
# app/main.py 扩展
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from app.debug import debug_routes, DebugMiddleware

app = FastAPI(
    title="User Service",
    docs_url="/docs",
    redoc_url="/redoc"
)

# 添加调试中间件
app.add_middleware(DebugMiddleware)

# 挂载调试路由
app.include_router(debug_routes.router, prefix="/debug", tags=["debug"])

# 挂载调试UI静态文件
app.mount("/debug-ui", StaticFiles(directory="app/debug/static"), name="debug-ui")

@app.get("/")
async def root():
    return {
        "service": "user-service",
        "endpoints": {
            "api_docs": "/docs",
            "redoc": "/redoc",
            "debug": "/debug",  # 新增调试入口
            "health": "/health"
        }
    }
```

## 核心实现

### 1. 流程调试器基类

```python
# app/debug/flow_debugger.py
from typing import Dict, List, Any, Optional, Callable
from datetime import datetime
import asyncio
import uuid
from enum import Enum

class ExecutionMode(Enum):
    NORMAL = "normal"      # 正常执行
    DEBUG = "debug"        # 调试模式
    STEP = "step"          # 单步执行

class ServiceDebugger:
    """服务级流程调试器"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.flows: Dict[str, BusinessFlow] = {}
        self.sessions: Dict[str, DebugSession] = {}
        self.mode = ExecutionMode.NORMAL
        
    def register_flow(self, flow: BusinessFlow):
        """注册业务流程"""
        self.flows[flow.name] = flow
        
    async def create_session(self, flow_name: str) -> str:
        """创建调试会话"""
        if flow_name not in self.flows:
            raise ValueError(f"Flow {flow_name} not found")
            
        session_id = str(uuid.uuid4())
        session = DebugSession(
            id=session_id,
            flow=self.flows[flow_name],
            created_at=datetime.now()
        )
        self.sessions[session_id] = session
        return session_id
        
    async def execute_with_debug(self, 
                                flow_name: str, 
                                context: Dict[str, Any],
                                mode: ExecutionMode = ExecutionMode.NORMAL) -> Any:
        """带调试功能的流程执行"""
        session_id = await self.create_session(flow_name)
        session = self.sessions[session_id]
        
        if mode == ExecutionMode.DEBUG:
            # 调试模式下自动在每个步骤设置断点
            for step in session.flow.steps:
                session.add_breakpoint(step.id)
                
        return await session.execute(context)
```

### 2. 流程装饰器

```python
# app/debug/decorators.py
from functools import wraps
import inspect
from typing import Callable

# 全局调试器实例
debugger = ServiceDebugger("user-service")

def flow(name: str, description: str = ""):
    """标记一个函数为可调试的业务流程"""
    def decorator(func: Callable):
        # 解析函数获取流程信息
        flow_model = parse_function_to_flow(func, name, description)
        debugger.register_flow(flow_model)
        
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 检查是否在调试模式
            if debugger.mode == ExecutionMode.NORMAL:
                return await func(*args, **kwargs)
            else:
                # 使用调试器执行
                context = extract_context(args, kwargs, func)
                return await debugger.execute_with_debug(
                    name, 
                    context, 
                    debugger.mode
                )
        
        # 保存原始函数引用
        wrapper._original = func
        wrapper._flow_name = name
        return wrapper
    
    return decorator

def step(name: str, step_type: str = "action"):
    """标记流程中的一个步骤"""
    def decorator(func: Callable):
        func._step_name = name
        func._step_type = step_type
        return func
    
    return decorator
```

### 3. 实际服务集成示例

```python
# app/services/user_service.py
from app.debug.decorators import flow, step
from app.models.domain import UserCreate, User
from app.core.database import get_db

@flow(name="创建用户流程", description="处理用户注册的完整流程")
async def create_user(user_data: UserCreate, db: Session) -> User:
    """创建用户的业务流程"""
    
    @step(name="验证用户数据", step_type="validation")
    async def validate_data():
        # 验证邮箱格式
        if not is_valid_email(user_data.email):
            raise ValueError("Invalid email format")
        
        # 验证必填字段
        if not user_data.name:
            raise ValueError("Name is required")
            
        return {"validated": True, "data": user_data}
    
    @step(name="检查邮箱唯一性", step_type="validation") 
    async def check_email_exists():
        existing = await get_user_by_email(db, user_data.email)
        if existing:
            raise ValueError("Email already exists")
        return {"email_available": True}
    
    @step(name="创建用户记录", step_type="action")
    async def create_user_record():
        user = User(
            id=uuid.uuid4(),
            name=user_data.name,
            email=user_data.email,
            phone=user_data.phone,
            status=UserStatus.ACTIVE,
            created_at=datetime.now()
        )
        db.add(user)
        db.commit()
        return {"user": user}
    
    @step(name="发送欢迎邮件", step_type="action")
    async def send_welcome_email(user: User):
        # 异步发送邮件
        await email_service.send_welcome(user.email, user.name)
        return {"email_sent": True}
    
    # 执行流程
    validation_result = await validate_data()
    await check_email_exists()
    user_result = await create_user_record()
    await send_welcome_email(user_result["user"])
    
    return user_result["user"]
```

### 4. 调试API路由

```python
# app/debug/debug_routes.py
from fastapi import APIRouter, WebSocket, HTTPException
from typing import List, Dict

router = APIRouter()

@router.get("/")
async def debug_home():
    """调试器主页"""
    return {
        "service": debugger.service_name,
        "flows": list(debugger.flows.keys()),
        "active_sessions": len(debugger.sessions),
        "ui_url": "/debug/ui"
    }

@router.get("/flows")
async def list_flows():
    """列出所有可调试的流程"""
    flows = []
    for name, flow in debugger.flows.items():
        flows.append({
            "name": name,
            "description": flow.description,
            "steps": len(flow.steps),
            "start_step": flow.start_step
        })
    return {"flows": flows}

@router.get("/flows/{flow_name}")
async def get_flow_detail(flow_name: str):
    """获取流程详细信息"""
    if flow_name not in debugger.flows:
        raise HTTPException(404, "Flow not found")
    
    flow = debugger.flows[flow_name]
    return {
        "name": flow.name,
        "description": flow.description,
        "steps": [step.dict() for step in flow.steps],
        "diagram": generate_mermaid_diagram(flow)
    }

@router.post("/sessions")
async def create_debug_session(flow_name: str, initial_context: dict):
    """创建调试会话"""
    try:
        session_id = await debugger.create_session(flow_name)
        session = debugger.sessions[session_id]
        await session.set_context(initial_context)
        
        return {
            "session_id": session_id,
            "flow_name": flow_name,
            "status": "created",
            "websocket_url": f"/debug/sessions/{session_id}/ws"
        }
    except Exception as e:
        raise HTTPException(400, str(e))

@router.websocket("/sessions/{session_id}/ws")
async def debug_websocket(websocket: WebSocket, session_id: str):
    """调试会话WebSocket连接"""
    if session_id not in debugger.sessions:
        await websocket.close(code=4004, reason="Session not found")
        return
        
    session = debugger.sessions[session_id]
    await websocket.accept()
    
    try:
        while True:
            # 接收调试命令
            data = await websocket.receive_json()
            command = data.get("command")
            
            if command == "start":
                await session.start()
            elif command == "continue":
                await session.continue_execution()
            elif command == "step":
                await session.step_over()
            elif command == "stop":
                await session.stop()
                break
            elif command == "add_breakpoint":
                step_id = data.get("step_id")
                session.add_breakpoint(step_id)
            elif command == "remove_breakpoint":
                step_id = data.get("step_id")
                session.remove_breakpoint(step_id)
            elif command == "inspect":
                path = data.get("path")
                value = session.inspect_context(path)
                await websocket.send_json({
                    "type": "inspection",
                    "path": path,
                    "value": value
                })
            
            # 发送状态更新
            await websocket.send_json({
                "type": "state_update",
                "current_step": session.current_step,
                "context": session.context,
                "status": session.status,
                "history": session.get_recent_history(10)
            })
            
    except Exception as e:
        await websocket.send_json({
            "type": "error",
            "message": str(e)
        })
    finally:
        await websocket.close()

@router.get("/ui")
async def debug_ui():
    """返回调试界面HTML"""
    return HTMLResponse(content=open("app/debug/static/index.html").read())
```

### 5. 可视化调试界面

```html
<!-- app/debug/static/index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Service Flow Debugger</title>
    <link rel="stylesheet" href="/debug-ui/debugger.css">
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
    <div id="app">
        <div class="debugger-container">
            <header>
                <h1>{{ serviceName }} Flow Debugger</h1>
                <div class="flow-selector">
                    <select v-model="selectedFlow" @change="loadFlow">
                        <option value="">Select a flow...</option>
                        <option v-for="flow in flows" :value="flow.name">
                            {{ flow.name }}
                        </option>
                    </select>
                </div>
            </header>
            
            <div class="debugger-main">
                <!-- 流程图区域 -->
                <div class="flow-diagram">
                    <div id="mermaid-diagram"></div>
                </div>
                
                <!-- 控制面板 -->
                <div class="control-panel">
                    <button @click="startDebug" :disabled="!canStart">
                        <i class="icon-play"></i> Start
                    </button>
                    <button @click="continueDebug" :disabled="!canContinue">
                        <i class="icon-continue"></i> Continue
                    </button>
                    <button @click="stepOver" :disabled="!canStep">
                        <i class="icon-step"></i> Step Over
                    </button>
                    <button @click="stopDebug" :disabled="!canStop">
                        <i class="icon-stop"></i> Stop
                    </button>
                </div>
                
                <!-- 上下文查看器 -->
                <div class="context-viewer">
                    <h3>Context</h3>
                    <div class="json-viewer">
                        <pre>{{ JSON.stringify(context, null, 2) }}</pre>
                    </div>
                </div>
                
                <!-- 断点管理 -->
                <div class="breakpoint-panel">
                    <h3>Breakpoints</h3>
                    <div v-for="step in currentFlow?.steps" :key="step.id">
                        <label>
                            <input 
                                type="checkbox" 
                                :checked="breakpoints.has(step.id)"
                                @change="toggleBreakpoint(step.id)"
                            >
                            {{ step.name }}
                        </label>
                    </div>
                </div>
                
                <!-- 执行历史 -->
                <div class="history-panel">
                    <h3>Execution History</h3>
                    <div class="history-list">
                        <div 
                            v-for="record in history" 
                            :key="record.timestamp"
                            class="history-item"
                            :class="{ current: record.step_id === currentStep }"
                        >
                            <span class="timestamp">
                                {{ formatTime(record.timestamp) }}
                            </span>
                            <span class="step-name">
                                {{ record.step_name }}
                            </span>
                            <span class="result" :class="record.success ? 'success' : 'error'">
                                {{ record.success ? '✓' : '✗' }}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="/debug-ui/debugger.js"></script>
</body>
</html>
```

### 6. 调试器JavaScript客户端

```javascript
// app/debug/static/debugger.js
const { createApp } = Vue;

createApp({
    data() {
        return {
            serviceName: '',
            flows: [],
            selectedFlow: '',
            currentFlow: null,
            sessionId: null,
            ws: null,
            currentStep: null,
            context: {},
            breakpoints: new Set(),
            history: [],
            status: 'idle'
        }
    },
    
    computed: {
        canStart() {
            return this.selectedFlow && this.status === 'idle';
        },
        canContinue() {
            return this.status === 'paused';
        },
        canStep() {
            return this.status === 'paused';
        },
        canStop() {
            return this.status !== 'idle';
        }
    },
    
    async mounted() {
        // 加载服务信息
        const response = await fetch('/debug/');
        const data = await response.json();
        this.serviceName = data.service;
        
        // 加载流程列表
        await this.loadFlows();
    },
    
    methods: {
        async loadFlows() {
            const response = await fetch('/debug/flows');
            const data = await response.json();
            this.flows = data.flows;
        },
        
        async loadFlow() {
            if (!this.selectedFlow) return;
            
            const response = await fetch(`/debug/flows/${this.selectedFlow}`);
            const data = await response.json();
            this.currentFlow = data;
            
            // 渲染流程图
            this.renderDiagram(data.diagram);
        },
        
        renderDiagram(mermaidCode) {
            const element = document.getElementById('mermaid-diagram');
            element.innerHTML = mermaidCode;
            mermaid.init(undefined, element);
            
            // 添加节点点击事件
            setTimeout(() => {
                document.querySelectorAll('.node').forEach(node => {
                    node.addEventListener('click', (e) => {
                        const stepId = e.target.getAttribute('data-step-id');
                        if (stepId) {
                            this.toggleBreakpoint(stepId);
                        }
                    });
                });
            }, 100);
        },
        
        async startDebug() {
            // 创建调试会话
            const response = await fetch('/debug/sessions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    flow_name: this.selectedFlow,
                    initial_context: {}
                })
            });
            
            const data = await response.json();
            this.sessionId = data.session_id;
            
            // 连接WebSocket
            this.connectWebSocket();
        },
        
        connectWebSocket() {
            const wsUrl = `ws://localhost:8000/debug/sessions/${this.sessionId}/ws`;
            this.ws = new WebSocket(wsUrl);
            
            this.ws.onopen = () => {
                this.status = 'connected';
                this.ws.send(JSON.stringify({ command: 'start' }));
            };
            
            this.ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                this.handleWebSocketMessage(data);
            };
            
            this.ws.onclose = () => {
                this.status = 'idle';
                this.sessionId = null;
            };
        },
        
        handleWebSocketMessage(data) {
            switch (data.type) {
                case 'state_update':
                    this.currentStep = data.current_step;
                    this.context = data.context;
                    this.status = data.status;
                    this.history = data.history;
                    this.highlightCurrentStep();
                    break;
                    
                case 'breakpoint_hit':
                    this.status = 'paused';
                    this.showBreakpointNotification(data.step);
                    break;
                    
                case 'error':
                    this.showError(data.message);
                    break;
            }
        },
        
        highlightCurrentStep() {
            // 清除所有高亮
            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('current', 'executed');
            });
            
            // 高亮当前步骤
            if (this.currentStep) {
                const currentNode = document.querySelector(`[data-step-id="${this.currentStep}"]`);
                if (currentNode) {
                    currentNode.classList.add('current');
                }
            }
            
            // 标记已执行步骤
            this.history.forEach(record => {
                const node = document.querySelector(`[data-step-id="${record.step_id}"]`);
                if (node) {
                    node.classList.add('executed');
                }
            });
        },
        
        continueDebug() {
            this.ws.send(JSON.stringify({ command: 'continue' }));
        },
        
        stepOver() {
            this.ws.send(JSON.stringify({ command: 'step' }));
        },
        
        stopDebug() {
            this.ws.send(JSON.stringify({ command: 'stop' }));
            this.ws.close();
        },
        
        toggleBreakpoint(stepId) {
            if (this.breakpoints.has(stepId)) {
                this.breakpoints.delete(stepId);
                this.ws?.send(JSON.stringify({ 
                    command: 'remove_breakpoint', 
                    step_id: stepId 
                }));
            } else {
                this.breakpoints.add(stepId);
                this.ws?.send(JSON.stringify({ 
                    command: 'add_breakpoint', 
                    step_id: stepId 
                }));
            }
        },
        
        formatTime(timestamp) {
            return new Date(timestamp).toLocaleTimeString();
        },
        
        showBreakpointNotification(step) {
            // 显示断点通知
            console.log(`Breakpoint hit at: ${step.name}`);
        },
        
        showError(message) {
            console.error(`Debug error: ${message}`);
        }
    }
}).mount('#app');
```

## 使用效果

### 1. 服务启动后的端点

```
http://localhost:8000/          # 服务主页
http://localhost:8000/docs      # OpenAPI文档
http://localhost:8000/redoc     # ReDoc文档
http://localhost:8000/debug     # 流程调试器入口
http://localhost:8000/debug/ui  # 可视化调试界面
```

### 2. 调试界面功能

- **流程选择**：下拉选择要调试的业务流程
- **流程图展示**：Mermaid渲染的流程图，实时显示执行位置
- **断点管理**：点击流程节点设置/取消断点
- **执行控制**：开始、继续、单步、停止
- **上下文查看**：实时查看流程执行的数据上下文
- **历史记录**：查看流程执行历史

### 3. 开发体验

```python
# 普通模式执行
user = await create_user(user_data, db)

# 调试模式执行
debugger.mode = ExecutionMode.DEBUG
user = await create_user(user_data, db)  # 会自动进入调试模式
```

## 自动生成集成

在 `/mda-generate-fastapi` 命令中自动生成调试器代码：

```python
def generate_debug_module(service_name: str, flows: List[BusinessFlow]):
    """生成服务的调试模块"""
    
    # 生成调试器配置
    generate_file("app/debug/__init__.py", debug_init_template)
    generate_file("app/debug/flow_debugger.py", debugger_template)
    generate_file("app/debug/debug_routes.py", routes_template)
    
    # 生成静态资源
    generate_file("app/debug/static/index.html", debug_ui_html)
    generate_file("app/debug/static/debugger.js", debug_ui_js)
    generate_file("app/debug/static/debugger.css", debug_ui_css)
    
    # 为每个业务流程生成调试配置
    for flow in flows:
        generate_flow_debugger(flow)
```

## 优势

1. **零配置**：调试器自动集成，无需额外配置
2. **可视化**：直观的流程图和执行状态展示
3. **实时调试**：WebSocket实时通信，响应迅速
4. **生产友好**：可以在生产环境关闭调试端点
5. **标准化**：每个服务都有统一的调试体验