# 模型调试器技术实现指南

## 概述

本文档详细描述了如何实现一个集成到每个MDA生成服务中的业务流程调试器。调试器通过解析PIM模型中的业务流程，提供可视化调试界面和实时执行跟踪能力。

## 技术栈

- **后端**: FastAPI + WebSocket
- **前端**: Vue 3 + Mermaid.js + D3.js
- **通信**: WebSocket (实时双向通信)
- **流程解析**: AST解析 + 装饰器模式
- **状态管理**: Redis (可选，用于分布式调试)

## 核心组件实现

### 1. 流程模型定义

```python
# app/debug/models.py
from typing import List, Dict, Any, Optional, Set, Union
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field
import uuid

class StepType(str, Enum):
    """步骤类型枚举"""
    ACTION = "action"              # 执行动作
    DECISION = "decision"          # 决策分支
    VALIDATION = "validation"      # 数据验证
    TRANSFORM = "transform"        # 数据转换
    ASYNC_ACTION = "async_action"  # 异步动作
    PARALLEL = "parallel"          # 并行执行
    LOOP = "loop"                  # 循环执行

class StepStatus(str, Enum):
    """步骤执行状态"""
    PENDING = "pending"        # 待执行
    RUNNING = "running"        # 执行中
    COMPLETED = "completed"    # 已完成
    FAILED = "failed"         # 执行失败
    SKIPPED = "skipped"       # 已跳过
    PAUSED = "paused"         # 暂停中

class FlowStep(BaseModel):
    """流程步骤定义"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    type: StepType
    description: str = ""
    
    # 输入输出定义
    inputs: Dict[str, str] = {}      # 参数名 -> 类型
    outputs: Dict[str, str] = {}     # 返回值名 -> 类型
    
    # 流程控制
    next_steps: List[str] = []       # 下一步骤ID列表
    conditions: Dict[str, str] = {}  # 条件表达式 stepId -> condition
    
    # 执行配置
    timeout: Optional[int] = None    # 超时时间（秒）
    retry_count: int = 0             # 重试次数
    async_execution: bool = False    # 是否异步执行
    
    # 调试配置
    breakpoint_enabled: bool = False
    log_level: str = "INFO"
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class BusinessFlow(BaseModel):
    """业务流程定义"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: str = ""
    version: str = "1.0.0"
    
    # 流程结构
    steps: List[FlowStep] = []
    start_step: str
    end_steps: List[str] = []
    
    # 数据模式
    context_schema: Dict[str, Any] = {}  # JSON Schema
    
    # 元数据
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    tags: List[str] = []
    
    def get_step(self, step_id: str) -> Optional[FlowStep]:
        """根据ID获取步骤"""
        return next((s for s in self.steps if s.id == step_id), None)
    
    def validate_flow(self) -> List[str]:
        """验证流程定义的完整性"""
        errors = []
        
        # 验证起始步骤
        if not self.get_step(self.start_step):
            errors.append(f"Start step {self.start_step} not found")
            
        # 验证结束步骤
        for end_step in self.end_steps:
            if not self.get_step(end_step):
                errors.append(f"End step {end_step} not found")
                
        # 验证步骤连接
        for step in self.steps:
            for next_id in step.next_steps:
                if not self.get_step(next_id):
                    errors.append(f"Step {step.id} references non-existent next step {next_id}")
                    
        return errors
```

### 2. 调试会话管理

```python
# app/debug/session.py
from typing import Dict, Any, List, Optional, Callable
import asyncio
from datetime import datetime
import json

class ExecutionRecord(BaseModel):
    """执行记录"""
    step_id: str
    step_name: str
    status: StepStatus
    started_at: datetime
    completed_at: Optional[datetime] = None
    
    # 执行数据
    inputs: Dict[str, Any] = {}
    outputs: Dict[str, Any] = {}
    error: Optional[str] = None
    
    # 性能指标
    duration_ms: Optional[int] = None
    memory_usage: Optional[int] = None

class DebugSession:
    """调试会话"""
    
    def __init__(self, session_id: str, flow: BusinessFlow):
        self.id = session_id
        self.flow = flow
        self.created_at = datetime.now()
        
        # 执行状态
        self.current_step: Optional[str] = None
        self.status: StepStatus = StepStatus.PENDING
        self.context: Dict[str, Any] = {}
        
        # 调试配置
        self.breakpoints: Set[str] = set()
        self.watch_expressions: Dict[str, str] = {}
        self.conditional_breakpoints: Dict[str, str] = {}
        
        # 执行历史
        self.execution_history: List[ExecutionRecord] = []
        self.call_stack: List[str] = []
        
        # 事件处理
        self.event_handlers: Dict[str, List[Callable]] = {
            'step_started': [],
            'step_completed': [],
            'breakpoint_hit': [],
            'error_occurred': [],
            'context_changed': []
        }
        
        # 控制标志
        self._continue_event = asyncio.Event()
        self._stop_requested = False
        
    async def start(self, initial_context: Dict[str, Any] = None):
        """启动调试会话"""
        self.context = initial_context or {}
        self.current_step = self.flow.start_step
        self.status = StepStatus.RUNNING
        
        try:
            await self._execute_flow()
        except Exception as e:
            await self._emit_event('error_occurred', {'error': str(e)})
            raise
            
    async def _execute_flow(self):
        """执行流程"""
        while self.current_step and not self._stop_requested:
            step = self.flow.get_step(self.current_step)
            if not step:
                raise ValueError(f"Step {self.current_step} not found")
                
            # 检查断点
            if await self._check_breakpoint(step):
                await self._handle_breakpoint(step)
                
            # 执行步骤
            await self._execute_step(step)
            
            # 确定下一步
            self.current_step = await self._determine_next_step(step)
            
            # 检查是否到达结束
            if self.current_step in self.flow.end_steps:
                self.status = StepStatus.COMPLETED
                break
                
    async def _execute_step(self, step: FlowStep):
        """执行单个步骤"""
        record = ExecutionRecord(
            step_id=step.id,
            step_name=step.name,
            status=StepStatus.RUNNING,
            started_at=datetime.now(),
            inputs=self._extract_inputs(step)
        )
        
        self.call_stack.append(step.id)
        await self._emit_event('step_started', {'step': step, 'record': record})
        
        try:
            # 执行步骤逻辑
            outputs = await self._process_step_logic(step, record.inputs)
            
            # 更新记录
            record.outputs = outputs
            record.status = StepStatus.COMPLETED
            record.completed_at = datetime.now()
            record.duration_ms = int((record.completed_at - record.started_at).total_seconds() * 1000)
            
            # 更新上下文
            self._update_context(outputs)
            
        except Exception as e:
            record.status = StepStatus.FAILED
            record.error = str(e)
            record.completed_at = datetime.now()
            raise
            
        finally:
            self.call_stack.pop()
            self.execution_history.append(record)
            await self._emit_event('step_completed', {'step': step, 'record': record})
            
    async def _process_step_logic(self, step: FlowStep, inputs: Dict[str, Any]) -> Dict[str, Any]:
        """处理步骤逻辑"""
        # 这里应该调用实际的业务逻辑
        # 在实际实现中，这会通过步骤ID查找并执行对应的函数
        
        # 模拟执行
        await asyncio.sleep(0.1)  # 模拟执行时间
        
        # 根据步骤类型处理
        if step.type == StepType.VALIDATION:
            return {"is_valid": True, "errors": []}
        elif step.type == StepType.TRANSFORM:
            return {"transformed_data": inputs}
        else:
            return {"result": "success"}
            
    async def _check_breakpoint(self, step: FlowStep) -> bool:
        """检查是否需要在断点处暂停"""
        # 普通断点
        if step.id in self.breakpoints:
            return True
            
        # 条件断点
        if step.id in self.conditional_breakpoints:
            condition = self.conditional_breakpoints[step.id]
            try:
                return eval(condition, {"context": self.context, "step": step})
            except:
                return False
                
        return False
        
    async def _handle_breakpoint(self, step: FlowStep):
        """处理断点"""
        self.status = StepStatus.PAUSED
        await self._emit_event('breakpoint_hit', {
            'step': step,
            'context': self.context,
            'call_stack': self.call_stack.copy()
        })
        
        # 等待继续信号
        self._continue_event.clear()
        await self._continue_event.wait()
        
        self.status = StepStatus.RUNNING
        
    async def continue_execution(self):
        """继续执行"""
        self._continue_event.set()
        
    async def step_over(self):
        """单步执行"""
        # 临时添加下一步的断点
        step = self.flow.get_step(self.current_step)
        if step:
            for next_id in step.next_steps:
                self.breakpoints.add(next_id)
                
        self._continue_event.set()
        
    async def stop(self):
        """停止执行"""
        self._stop_requested = True
        self._continue_event.set()
        self.status = StepStatus.COMPLETED
        
    def add_breakpoint(self, step_id: str, condition: str = None):
        """添加断点"""
        if condition:
            self.conditional_breakpoints[step_id] = condition
        else:
            self.breakpoints.add(step_id)
            
    def remove_breakpoint(self, step_id: str):
        """移除断点"""
        self.breakpoints.discard(step_id)
        self.conditional_breakpoints.pop(step_id, None)
        
    def add_watch(self, name: str, expression: str):
        """添加监视表达式"""
        self.watch_expressions[name] = expression
        
    def evaluate_expression(self, expression: str) -> Any:
        """计算表达式"""
        try:
            return eval(expression, {
                "context": self.context,
                "history": self.execution_history,
                "current_step": self.current_step
            })
        except Exception as e:
            return f"Error: {str(e)}"
            
    async def _emit_event(self, event_type: str, data: Dict[str, Any]):
        """触发事件"""
        for handler in self.event_handlers.get(event_type, []):
            await handler(data)
            
    def _extract_inputs(self, step: FlowStep) -> Dict[str, Any]:
        """从上下文提取步骤输入"""
        inputs = {}
        for param_name in step.inputs:
            if param_name in self.context:
                inputs[param_name] = self.context[param_name]
        return inputs
        
    def _update_context(self, outputs: Dict[str, Any]):
        """更新执行上下文"""
        self.context.update(outputs)
        
    async def _determine_next_step(self, step: FlowStep) -> Optional[str]:
        """确定下一个执行步骤"""
        if not step.next_steps:
            return None
            
        if len(step.next_steps) == 1:
            return step.next_steps[0]
            
        # 条件分支
        for next_id, condition in step.conditions.items():
            try:
                if eval(condition, {"context": self.context}):
                    return next_id
            except:
                continue
                
        # 默认第一个
        return step.next_steps[0]
```

### 3. 流程解析器

```python
# app/debug/parser.py
import ast
import inspect
from typing import Callable, List, Dict, Any
import re

class FlowParser:
    """流程解析器：从Python函数中提取流程定义"""
    
    @staticmethod
    def parse_function_to_flow(func: Callable, name: str, description: str = "") -> BusinessFlow:
        """解析函数转换为流程模型"""
        # 获取函数源代码
        source = inspect.getsource(func)
        tree = ast.parse(source)
        
        # 提取流程信息
        flow = BusinessFlow(
            name=name,
            description=description or func.__doc__ or "",
            start_step="start",
            end_steps=["end"]
        )
        
        # 解析函数体
        function_def = tree.body[0]
        steps = FlowParser._extract_steps(function_def)
        
        # 构建流程图
        flow.steps = steps
        flow = FlowParser._connect_steps(flow)
        
        return flow
        
    @staticmethod
    def _extract_steps(function_def: ast.FunctionDef) -> List[FlowStep]:
        """从函数定义中提取步骤"""
        steps = []
        
        for node in ast.walk(function_def):
            # 查找被装饰的内部函数
            if isinstance(node, ast.FunctionDef):
                step_info = FlowParser._extract_step_info(node)
                if step_info:
                    steps.append(step_info)
                    
            # 查找条件语句
            elif isinstance(node, ast.If):
                decision_step = FlowParser._create_decision_step(node)
                if decision_step:
                    steps.append(decision_step)
                    
        return steps
        
    @staticmethod
    def _extract_step_info(node: ast.FunctionDef) -> Optional[FlowStep]:
        """从函数节点提取步骤信息"""
        # 查找 @step 装饰器
        for decorator in node.decorator_list:
            if isinstance(decorator, ast.Call) and hasattr(decorator.func, 'id'):
                if decorator.func.id == 'step':
                    # 提取装饰器参数
                    step_name = ""
                    step_type = StepType.ACTION
                    
                    if decorator.args:
                        step_name = decorator.args[0].s
                        
                    for keyword in decorator.keywords:
                        if keyword.arg == 'step_type':
                            step_type = StepType(keyword.value.s)
                            
                    # 创建步骤
                    return FlowStep(
                        id=node.name,
                        name=step_name or node.name,
                        type=step_type,
                        description=ast.get_docstring(node) or "",
                        inputs=FlowParser._extract_function_params(node),
                        outputs=FlowParser._extract_return_values(node)
                    )
                    
        return None
        
    @staticmethod
    def _extract_function_params(node: ast.FunctionDef) -> Dict[str, str]:
        """提取函数参数"""
        params = {}
        for arg in node.args.args:
            # 跳过 self
            if arg.arg != 'self':
                # 尝试获取类型注解
                type_str = "Any"
                if arg.annotation:
                    type_str = ast.unparse(arg.annotation)
                params[arg.arg] = type_str
        return params
        
    @staticmethod
    def _extract_return_values(node: ast.FunctionDef) -> Dict[str, str]:
        """提取返回值"""
        # 简化实现：查找 return 语句
        for child in ast.walk(node):
            if isinstance(child, ast.Return):
                if isinstance(child.value, ast.Dict):
                    # 返回字典
                    outputs = {}
                    for key, value in zip(child.value.keys, child.value.values):
                        if isinstance(key, ast.Str):
                            outputs[key.s] = "Any"
                    return outputs
                    
        return {"result": "Any"}
        
    @staticmethod
    def _create_decision_step(node: ast.If) -> Optional[FlowStep]:
        """从条件语句创建决策步骤"""
        # 提取条件表达式
        condition = ast.unparse(node.test)
        
        return FlowStep(
            id=f"decision_{id(node)}",
            name=f"Decision: {condition[:30]}...",
            type=StepType.DECISION,
            description=f"Condition: {condition}",
            next_steps=["true_branch", "false_branch"],
            conditions={
                "true_branch": condition,
                "false_branch": f"not ({condition})"
            }
        )
```

### 4. WebSocket通信协议

```python
# app/debug/protocol.py
from typing import Dict, Any, Optional
from pydantic import BaseModel
from enum import Enum

class MessageType(str, Enum):
    """消息类型"""
    # 客户端 -> 服务器
    COMMAND = "command"
    EVALUATE = "evaluate"
    WATCH_ADD = "watch_add"
    WATCH_REMOVE = "watch_remove"
    
    # 服务器 -> 客户端
    STATE_UPDATE = "state_update"
    BREAKPOINT_HIT = "breakpoint_hit"
    STEP_EXECUTED = "step_executed"
    ERROR = "error"
    EVALUATION_RESULT = "evaluation_result"
    WATCH_UPDATE = "watch_update"

class DebugCommand(str, Enum):
    """调试命令"""
    START = "start"
    CONTINUE = "continue"
    STEP_OVER = "step_over"
    STEP_INTO = "step_into"
    STEP_OUT = "step_out"
    STOP = "stop"
    RESTART = "restart"
    
    # 断点管理
    ADD_BREAKPOINT = "add_breakpoint"
    REMOVE_BREAKPOINT = "remove_breakpoint"
    TOGGLE_BREAKPOINT = "toggle_breakpoint"
    
    # 数据操作
    INSPECT_VARIABLE = "inspect_variable"
    MODIFY_VARIABLE = "modify_variable"
    
class DebugMessage(BaseModel):
    """调试消息基类"""
    type: MessageType
    timestamp: datetime = Field(default_factory=datetime.now)
    session_id: Optional[str] = None

class CommandMessage(DebugMessage):
    """命令消息"""
    type: MessageType = MessageType.COMMAND
    command: DebugCommand
    params: Dict[str, Any] = {}

class StateUpdateMessage(DebugMessage):
    """状态更新消息"""
    type: MessageType = MessageType.STATE_UPDATE
    current_step: Optional[str]
    status: StepStatus
    context: Dict[str, Any]
    call_stack: List[str]
    breakpoints: List[str]
    watch_values: Dict[str, Any]

class BreakpointHitMessage(DebugMessage):
    """断点命中消息"""
    type: MessageType = MessageType.BREAKPOINT_HIT
    step: Dict[str, Any]  # FlowStep.dict()
    reason: str
    call_stack: List[str]
    local_variables: Dict[str, Any]

class WebSocketHandler:
    """WebSocket消息处理器"""
    
    def __init__(self, session: DebugSession):
        self.session = session
        self.websocket: Optional[WebSocket] = None
        
        # 注册事件处理器
        self._setup_event_handlers()
        
    def _setup_event_handlers(self):
        """设置事件处理器"""
        self.session.event_handlers['step_started'].append(self._on_step_started)
        self.session.event_handlers['step_completed'].append(self._on_step_completed)
        self.session.event_handlers['breakpoint_hit'].append(self._on_breakpoint_hit)
        self.session.event_handlers['error_occurred'].append(self._on_error)
        
    async def handle_connection(self, websocket: WebSocket):
        """处理WebSocket连接"""
        self.websocket = websocket
        await websocket.accept()
        
        try:
            # 发送初始状态
            await self._send_state_update()
            
            # 消息循环
            while True:
                data = await websocket.receive_json()
                message = self._parse_message(data)
                await self._handle_message(message)
                
        except Exception as e:
            await self._send_error(str(e))
        finally:
            await websocket.close()
            
    async def _handle_message(self, message: DebugMessage):
        """处理接收到的消息"""
        if isinstance(message, CommandMessage):
            await self._handle_command(message)
        # 处理其他消息类型...
        
    async def _handle_command(self, message: CommandMessage):
        """处理调试命令"""
        command = message.command
        params = message.params
        
        if command == DebugCommand.START:
            await self.session.start(params.get('context', {}))
            
        elif command == DebugCommand.CONTINUE:
            await self.session.continue_execution()
            
        elif command == DebugCommand.STEP_OVER:
            await self.session.step_over()
            
        elif command == DebugCommand.STOP:
            await self.session.stop()
            
        elif command == DebugCommand.ADD_BREAKPOINT:
            step_id = params['step_id']
            condition = params.get('condition')
            self.session.add_breakpoint(step_id, condition)
            await self._send_state_update()
            
        elif command == DebugCommand.REMOVE_BREAKPOINT:
            step_id = params['step_id']
            self.session.remove_breakpoint(step_id)
            await self._send_state_update()
            
        elif command == DebugCommand.INSPECT_VARIABLE:
            path = params['path']
            value = self._get_variable_value(path)
            await self._send_evaluation_result(path, value)
            
    async def _send_state_update(self):
        """发送状态更新"""
        message = StateUpdateMessage(
            session_id=self.session.id,
            current_step=self.session.current_step,
            status=self.session.status,
            context=self.session.context,
            call_stack=self.session.call_stack,
            breakpoints=list(self.session.breakpoints),
            watch_values=self._evaluate_watches()
        )
        await self._send_message(message)
        
    async def _send_message(self, message: DebugMessage):
        """发送消息到客户端"""
        if self.websocket:
            await self.websocket.send_json(message.dict())
```

### 5. 可视化界面核心组件

```javascript
// app/debug/static/js/debugger-core.js

class FlowDebugger {
    constructor(options = {}) {
        this.serviceUrl = options.serviceUrl || '/debug';
        this.wsUrl = options.wsUrl || 'ws://localhost:8000/debug';
        
        // 状态管理
        this.state = {
            flows: [],
            currentFlow: null,
            sessionId: null,
            currentStep: null,
            context: {},
            breakpoints: new Set(),
            watchExpressions: new Map(),
            executionHistory: [],
            callStack: [],
            status: 'idle'
        };
        
        // WebSocket连接
        this.ws = null;
        
        // 事件总线
        this.eventBus = new EventTarget();
        
        // UI组件
        this.components = {
            flowDiagram: null,
            contextViewer: null,
            historyPanel: null,
            controlPanel: null
        };
    }
    
    async initialize() {
        // 加载流程列表
        await this.loadFlows();
        
        // 初始化UI组件
        this.initializeComponents();
        
        // 设置事件监听
        this.setupEventListeners();
    }
    
    async loadFlows() {
        const response = await fetch(`${this.serviceUrl}/flows`);
        const data = await response.json();
        this.state.flows = data.flows;
        this.emit('flows-loaded', { flows: this.state.flows });
    }
    
    async selectFlow(flowName) {
        const response = await fetch(`${this.serviceUrl}/flows/${flowName}`);
        const flow = await response.json();
        this.state.currentFlow = flow;
        
        // 渲染流程图
        this.renderFlowDiagram(flow);
        
        this.emit('flow-selected', { flow });
    }
    
    renderFlowDiagram(flow) {
        // 使用D3.js渲染交互式流程图
        const container = document.getElementById('flow-diagram');
        
        // 清空容器
        d3.select(container).selectAll('*').remove();
        
        const svg = d3.select(container)
            .append('svg')
            .attr('width', '100%')
            .attr('height', '100%');
            
        // 创建图形组
        const g = svg.append('g');
        
        // 添加缩放功能
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });
            
        svg.call(zoom);
        
        // 转换流程数据为D3格式
        const nodes = flow.steps.map(step => ({
            id: step.id,
            label: step.name,
            type: step.type,
            x: 0,
            y: 0
        }));
        
        const links = [];
        flow.steps.forEach(step => {
            step.next_steps.forEach(nextId => {
                links.push({
                    source: step.id,
                    target: nextId,
                    condition: step.conditions[nextId]
                });
            });
        });
        
        // 使用dagre布局
        this.layoutFlow(nodes, links);
        
        // 渲染连接线
        const link = g.selectAll('.link')
            .data(links)
            .enter()
            .append('g')
            .attr('class', 'link');
            
        link.append('path')
            .attr('d', d => this.createLinkPath(d))
            .attr('fill', 'none')
            .attr('stroke', '#999')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrowhead)');
            
        // 渲染节点
        const node = g.selectAll('.node')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${d.x}, ${d.y})`)
            .on('click', (event, d) => this.onNodeClick(d))
            .on('dblclick', (event, d) => this.toggleBreakpoint(d.id));
            
        // 节点背景
        node.append('rect')
            .attr('x', -50)
            .attr('y', -25)
            .attr('width', 100)
            .attr('height', 50)
            .attr('rx', 5)
            .attr('fill', d => this.getNodeColor(d.type))
            .attr('stroke', '#333')
            .attr('stroke-width', 2);
            
        // 节点文本
        node.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '.35em')
            .text(d => d.label)
            .style('font-size', '12px')
            .style('fill', 'white');
            
        // 断点指示器
        node.append('circle')
            .attr('class', 'breakpoint-indicator')
            .attr('cx', -40)
            .attr('cy', -15)
            .attr('r', 5)
            .attr('fill', 'red')
            .style('display', d => this.state.breakpoints.has(d.id) ? 'block' : 'none');
            
        this.components.flowDiagram = { svg, g, nodes, links };
    }
    
    layoutFlow(nodes, links) {
        // 使用dagre进行自动布局
        const g = new dagre.graphlib.Graph();
        g.setGraph({
            rankdir: 'TB',
            nodesep: 50,
            edgesep: 10,
            ranksep: 50
        });
        g.setDefaultEdgeLabel(() => ({}));
        
        // 添加节点
        nodes.forEach(node => {
            g.setNode(node.id, { width: 100, height: 50 });
        });
        
        // 添加边
        links.forEach(link => {
            g.setEdge(link.source, link.target);
        });
        
        // 执行布局
        dagre.layout(g);
        
        // 更新节点位置
        nodes.forEach(node => {
            const n = g.node(node.id);
            node.x = n.x;
            node.y = n.y;
        });
    }
    
    getNodeColor(type) {
        const colors = {
            'action': '#4CAF50',
            'decision': '#FF9800',
            'validation': '#2196F3',
            'transform': '#9C27B0',
            'async_action': '#00BCD4',
            'parallel': '#FFC107',
            'loop': '#795548'
        };
        return colors[type] || '#607D8B';
    }
    
    async startDebugSession() {
        if (!this.state.currentFlow) {
            throw new Error('No flow selected');
        }
        
        // 创建调试会话
        const response = await fetch(`${this.serviceUrl}/sessions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                flow_name: this.state.currentFlow.name,
                initial_context: {}
            })
        });
        
        const data = await response.json();
        this.state.sessionId = data.session_id;
        
        // 连接WebSocket
        this.connectWebSocket();
    }
    
    connectWebSocket() {
        const wsUrl = `${this.wsUrl}/sessions/${this.state.sessionId}/ws`;
        this.ws = new WebSocket(wsUrl);
        
        this.ws.onopen = () => {
            this.state.status = 'connected';
            this.emit('ws-connected');
        };
        
        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleWebSocketMessage(message);
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.emit('ws-error', { error });
        };
        
        this.ws.onclose = () => {
            this.state.status = 'disconnected';
            this.emit('ws-disconnected');
        };
    }
    
    handleWebSocketMessage(message) {
        switch (message.type) {
            case 'state_update':
                this.updateState(message);
                break;
                
            case 'breakpoint_hit':
                this.handleBreakpointHit(message);
                break;
                
            case 'step_executed':
                this.handleStepExecuted(message);
                break;
                
            case 'error':
                this.handleError(message);
                break;
                
            case 'evaluation_result':
                this.handleEvaluationResult(message);
                break;
                
            case 'watch_update':
                this.handleWatchUpdate(message);
                break;
        }
    }
    
    updateState(message) {
        this.state.currentStep = message.current_step;
        this.state.status = message.status;
        this.state.context = message.context;
        this.state.callStack = message.call_stack;
        
        // 更新UI
        this.updateFlowVisualization();
        this.updateContextViewer();
        this.updateCallStack();
        
        this.emit('state-updated', { state: this.state });
    }
    
    updateFlowVisualization() {
        if (!this.components.flowDiagram) return;
        
        const { g } = this.components.flowDiagram;
        
        // 重置所有节点样式
        g.selectAll('.node')
            .classed('current', false)
            .classed('executed', false)
            .classed('failed', false);
            
        // 高亮当前节点
        if (this.state.currentStep) {
            g.select(`[data-node-id="${this.state.currentStep}"]`)
                .classed('current', true);
        }
        
        // 标记已执行节点
        this.state.executionHistory.forEach(record => {
            const node = g.select(`[data-node-id="${record.step_id}"]`);
            node.classed('executed', true);
            
            if (record.status === 'failed') {
                node.classed('failed', true);
            }
        });
    }
    
    sendCommand(command, params = {}) {
        if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket not connected');
        }
        
        const message = {
            type: 'command',
            command: command,
            params: params,
            timestamp: new Date().toISOString()
        };
        
        this.ws.send(JSON.stringify(message));
    }
    
    // 调试控制方法
    async start() {
        this.sendCommand('start', { context: this.getInitialContext() });
    }
    
    async continue() {
        this.sendCommand('continue');
    }
    
    async stepOver() {
        this.sendCommand('step_over');
    }
    
    async stepInto() {
        this.sendCommand('step_into');
    }
    
    async stepOut() {
        this.sendCommand('step_out');
    }
    
    async stop() {
        this.sendCommand('stop');
        if (this.ws) {
            this.ws.close();
        }
    }
    
    toggleBreakpoint(stepId) {
        if (this.state.breakpoints.has(stepId)) {
            this.state.breakpoints.delete(stepId);
            this.sendCommand('remove_breakpoint', { step_id: stepId });
        } else {
            this.state.breakpoints.add(stepId);
            this.sendCommand('add_breakpoint', { step_id: stepId });
        }
        
        this.updateBreakpointIndicators();
    }
    
    updateBreakpointIndicators() {
        if (!this.components.flowDiagram) return;
        
        const { g } = this.components.flowDiagram;
        
        g.selectAll('.breakpoint-indicator')
            .style('display', d => this.state.breakpoints.has(d.id) ? 'block' : 'none');
    }
    
    // 事件发射
    emit(eventType, data) {
        const event = new CustomEvent(eventType, { detail: data });
        this.eventBus.dispatchEvent(event);
    }
    
    // 事件监听
    on(eventType, handler) {
        this.eventBus.addEventListener(eventType, handler);
    }
    
    off(eventType, handler) {
        this.eventBus.removeEventListener(eventType, handler);
    }
}

// 导出供Vue组件使用
window.FlowDebugger = FlowDebugger;
```

### 6. 性能监控和分析

```python
# app/debug/profiler.py
import time
import tracemalloc
import psutil
from typing import Dict, List, Any
import asyncio

class PerformanceProfiler:
    """性能分析器"""
    
    def __init__(self):
        self.metrics: Dict[str, List[float]] = {
            'step_duration': [],
            'memory_usage': [],
            'cpu_usage': []
        }
        self.step_timings: Dict[str, List[float]] = {}
        
    async def profile_step(self, step_id: str, func: Callable):
        """分析步骤执行性能"""
        # 开始内存跟踪
        tracemalloc.start()
        
        # 记录开始状态
        start_time = time.time()
        start_memory = tracemalloc.get_traced_memory()[0]
        process = psutil.Process()
        start_cpu = process.cpu_percent()
        
        try:
            # 执行函数
            result = await func()
            
            # 记录结束状态
            end_time = time.time()
            current, peak = tracemalloc.get_traced_memory()
            end_cpu = process.cpu_percent()
            
            # 计算指标
            duration = (end_time - start_time) * 1000  # 毫秒
            memory_delta = (current - start_memory) / 1024 / 1024  # MB
            cpu_usage = (end_cpu - start_cpu)
            
            # 记录指标
            self.metrics['step_duration'].append(duration)
            self.metrics['memory_usage'].append(memory_delta)
            self.metrics['cpu_usage'].append(cpu_usage)
            
            if step_id not in self.step_timings:
                self.step_timings[step_id] = []
            self.step_timings[step_id].append(duration)
            
            return result
            
        finally:
            tracemalloc.stop()
            
    def get_performance_report(self) -> Dict[str, Any]:
        """生成性能报告"""
        report = {
            'summary': {
                'total_steps': len(self.metrics['step_duration']),
                'avg_duration': sum(self.metrics['step_duration']) / len(self.metrics['step_duration']) if self.metrics['step_duration'] else 0,
                'max_duration': max(self.metrics['step_duration']) if self.metrics['step_duration'] else 0,
                'total_memory': sum(self.metrics['memory_usage']),
                'avg_cpu': sum(self.metrics['cpu_usage']) / len(self.metrics['cpu_usage']) if self.metrics['cpu_usage'] else 0
            },
            'step_analysis': {},
            'bottlenecks': []
        }
        
        # 分析每个步骤
        for step_id, timings in self.step_timings.items():
            avg_time = sum(timings) / len(timings)
            report['step_analysis'][step_id] = {
                'executions': len(timings),
                'avg_duration': avg_time,
                'min_duration': min(timings),
                'max_duration': max(timings)
            }
            
            # 识别瓶颈
            if avg_time > 1000:  # 超过1秒
                report['bottlenecks'].append({
                    'step_id': step_id,
                    'avg_duration': avg_time,
                    'severity': 'high' if avg_time > 5000 else 'medium'
                })
                
        return report
```

## 部署和配置

### 1. 自动集成到服务

```python
# app/debug/__init__.py
from .flow_debugger import ServiceDebugger
from .decorators import flow, step
from .debug_routes import create_debug_router

def setup_debugger(app: FastAPI, service_name: str):
    """设置调试器"""
    # 创建全局调试器实例
    debugger = ServiceDebugger(service_name)
    
    # 添加调试路由
    debug_router = create_debug_router(debugger)
    app.include_router(debug_router, prefix="/debug", tags=["debug"])
    
    # 挂载静态文件
    app.mount("/debug-ui", StaticFiles(directory="app/debug/static"), name="debug-ui")
    
    # 添加调试中间件
    @app.middleware("http")
    async def debug_middleware(request: Request, call_next):
        # 检查调试模式
        if request.headers.get("X-Debug-Mode") == "true":
            # 启用调试模式
            debugger.mode = ExecutionMode.DEBUG
            
        response = await call_next(request)
        
        # 重置调试模式
        debugger.mode = ExecutionMode.NORMAL
        
        return response
        
    return debugger

# 导出装饰器
__all__ = ['flow', 'step', 'setup_debugger']
```

### 2. 环境配置

```python
# app/core/config.py 添加调试配置
class Settings(BaseSettings):
    # ... 其他配置
    
    # 调试配置
    DEBUG_ENABLED: bool = True
    DEBUG_UI_ENABLED: bool = True
    DEBUG_BREAKPOINT_TIMEOUT: int = 300  # 断点超时时间（秒）
    DEBUG_MAX_SESSIONS: int = 10  # 最大并发调试会话数
    DEBUG_HISTORY_SIZE: int = 1000  # 历史记录大小
    
    class Config:
        env_file = ".env"
```

## 使用指南

### 1. 标记可调试的流程

```python
from app.debug import flow, step

@flow(name="用户注册流程", description="处理用户注册")
async def register_user(user_data: UserCreate, db: Session):
    
    @step(name="验证邮箱", step_type="validation")
    async def validate_email():
        if not is_valid_email(user_data.email):
            raise ValueError("Invalid email")
        return {"email_valid": True}
    
    @step(name="创建用户", step_type="action")
    async def create_user():
        user = User(**user_data.dict())
        db.add(user)
        db.commit()
        return {"user": user}
    
    # 执行流程
    await validate_email()
    result = await create_user()
    
    return result["user"]
```

### 2. 访问调试界面

1. 启动服务
2. 访问 `http://localhost:8000/debug/ui`
3. 选择要调试的流程
4. 设置断点并开始调试

### 3. 使用调试API

```bash
# 列出所有流程
curl http://localhost:8000/debug/flows

# 创建调试会话
curl -X POST http://localhost:8000/debug/sessions \
  -H "Content-Type: application/json" \
  -d '{"flow_name": "用户注册流程", "initial_context": {}}'

# 使用WebSocket连接进行调试
wscat -c ws://localhost:8000/debug/sessions/{session_id}/ws
```

## 最佳实践

1. **合理设置步骤粒度**：步骤不宜过细，应该代表有意义的业务动作
2. **添加有意义的描述**：步骤名称和描述应该清晰表达业务含义
3. **使用条件断点**：对于复杂流程，使用条件断点可以更精确地调试
4. **监控性能**：定期查看性能报告，识别和优化瓶颈
5. **生产环境配置**：在生产环境中应该禁用调试UI，只保留API用于问题诊断